include libs/linux_x86/sys.corth
include libs/linux_x86/io/output.corth
include libs/linux_x86/io/input.corth
include libs/core/stack.corth
include libs/core/arithmetic.corth
include libs/core/memory.corth


macro malloc.ARRAY-SIZE       0x4000000 endmacro
macro malloc.AVAIL-QUEUE-SIZE 0x10000 endmacro
include libs/dynamic/malloc.corth
include libs/dynamic/utils.corth

include libs/collections/list64.corth
include libs/collections/deque64.corth
include libs/collections/queue64.corth
include libs/collections/str_map64.corth
include libs/collections/str_set8.corth

include CorthCompiler/lexer.corth
include CorthCompiler/debug.corth
include CorthCompiler/enums.corth


// TODO: Make not hard-coded.
macro SOURCE-NAME "./example.corth" endmacro
macro OUTPUT-NAME "./o.asm"         endmacro

proc create-name-token
  // ptr: file-name file-desc: file-desc
  ptr file-desc
  // int: start-line int: start-char int: start-at
  int int int
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: buffer ptr: buffer-end
  ptr ptr
  // file-desc: log-stream --
  file-desc --
  // int: token-type ptr: address [int|ptr]: arg
  int ptr int
  
  // Checks if the name is a keyword or an intrinsic, and creates a new token.
  // After the keyword and intrinsic checks, macros are checked for any match. If there is any macro with the same name, the macro tokens are loaded to a buffer.
in let
    file-name file
    start-line start-char start-at
    line-no char-no
    buffer buffer-end
    log-stream
  in

  // Get full token.
  file line-no char-no buffer buffer-end log-stream parse-next-token

  buffer-end @64 buffer - let buffer-size in
    // Check if the token is a keyword.
    // I hate my life.
         buffer buffer-size KEYWORD-INCLUDE-STR    memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-INCLUDE    
    else buffer buffer-size KEYWORD-MACRO-STR      memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-MACRO      
    else buffer buffer-size KEYWORD-ENDMACRO-STR   memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-ENDMACRO   
    else buffer buffer-size KEYWORD-PROC-STR       memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-PROC       
    else buffer buffer-size KEYWORD-END-STR        memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-END        
    else buffer buffer-size KEYWORD-RETURN-STR     memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-RETURN     
    else buffer buffer-size KEYWORD-RETURNS-STR    memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-RETURNS    
    else buffer buffer-size KEYWORD-MEMORY-STR     memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-MEMORY     
    else buffer buffer-size KEYWORD-AND-STR        memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-AND        
    else buffer buffer-size KEYWORD-IN-STR         memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-IN         
    else buffer buffer-size KEYWORD-LET-STR        memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-LET        
    else buffer buffer-size KEYWORD-IF-STR         memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-IF         
    else buffer buffer-size KEYWORD-ELSE-STR       memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-ELSE       
    else buffer buffer-size KEYWORD-WHILE-STR      memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-WHILE      
    else buffer buffer-size KEYWORD-DO-STR         memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-DO         
    else buffer buffer-size KEYWORD-BREAK-STR      memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-BREAK      
    
    // I still hate my life.
    else buffer buffer-size INTRINSIC-ADD-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-ADD      
    else buffer buffer-size INTRINSIC-FULLMUL-STR  memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-FULLMUL  
    else buffer buffer-size INTRINSIC-DIVMOD-STR   memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-DIVMOD   
    else buffer buffer-size INTRINSIC-UFULLMUL-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UFULLMUL 
    else buffer buffer-size INTRINSIC-UDIVMOD-STR  memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UDIVMOD  
    else buffer buffer-size INTRINSIC-BOR-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BOR      
    else buffer buffer-size INTRINSIC-BNOT-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BNOT     
    else buffer buffer-size INTRINSIC-NOTEQUAL-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-NOTEQUAL 
    else buffer buffer-size INTRINSIC-LESS-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-LESS     
    else buffer buffer-size INTRINSIC-TRUE-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-TRUE     
    else buffer buffer-size INTRINSIC-FALSE-STR    memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-FALSE    
    else buffer buffer-size INTRINSIC-LOAD8-STR    memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-LOAD8    
    else buffer buffer-size INTRINSIC-STORE8-STR   memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-STORE8   
    else buffer buffer-size INTRINSIC-LOAD64-STR   memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-LOAD64   
    else buffer buffer-size INTRINSIC-STORE64-STR  memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-STORE64  
    else buffer buffer-size INTRINSIC-SYSCALL6-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL6 
    
    else buffer buffer-size TYPE-INT-STR           memeq8 if TYPE-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address TYPE-INT           
    else buffer buffer-size TYPE-BOOL-STR          memeq8 if TYPE-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address TYPE-BOOL          
    
    else
      // Return token type, address and argument.
      TYPE-NAME file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address buffer buffer-size to-dynamic8

    // This is nightmare fuel.
    end end end end end end end end end end end end end end end end end
    end end end end end end end end end end end end end end end end end
  end
end end


proc get-next-token
  // ptr: file-name file-desc: file-desc
  ptr file-desc 
  // ptr: line-no ptr: char-no
  ptr ptr 
  // ptr: extended-tokens-array ptr: extended-tokens-start-index ptr: extended-tokens-end-index
  ptr ptr ptr
  // ptr: macro-names ptr: macro-tokens ptr: macros-length
  ptr ptr ptr
  // file-desc: log-stream bool: extend-macros --
  file-desc bool --
  // int: token-type ptr: address [int|ptr]: arg bool: is-available 
  int ptr int bool
  
  // Generates a token and returns.
  // NOTE: If there is no token available, every other parameter is either NULLPTR or invalid.
in let
    file-name file
    line-no char-no
    extended-array extended-start extended-end
    macro-names macro-tokens macros-length
    log-stream extend-macros
  in

  extended-end @64 extended-start @64 - let extended-length in
    // If there are remaining tokens in the extended queue, return the remaining item.
    extended-length isn-zero if
      extended-length 3 % isn-zero if
        LOG.ERR  log-stream fputs "Extended array length is not a multiple of 3.\n" log-stream fputs
        log-stream report-bug
        ERROR-EXIT-CODE exit drop
      end

      extended-array EXTENDED-MAX-LENGTH extended-start extended-end deque64.pop-first
      extended-array EXTENDED-MAX-LENGTH extended-start extended-end deque64.pop-first
      extended-array EXTENDED-MAX-LENGTH extended-start extended-end deque64.pop-first
      
    else
      memory buffer     TOKEN-MAX-LENGTH in
      memory buffer-end sizeof(int)      in

        file line-no char-no strip-file if
          TYPE-UNKNOWN NULLPTR 0 false return
        end

        buffer buffer-end !64

        line-no @64 char-no @64 file ftell let start-line start-char start-at in
          buffer 1 file fgets drop
          buffer-end @inc64

          buffer @8 is-ddigit if
            // -------- Integer type --------

            // Get full token.
            file line-no char-no buffer buffer-end log-stream parse-next-token

            file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address let address in
              memory number sizeof(int) in
                buffer buffer-end @64 buffer - number convint ! if
                  LOG.ERR log-stream fputs "Could not convert integer.\n" log-stream fputs
                  address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                end

                TYPE-INTEGER address number @64
              end
            end

          else buffer @8 '\'' = if
            // -------- Characters --------
            // TODO: Add multpile character pushing.

            buffer inc 1 file fgets is-zero if
              // Reached EOF while expecting a character.
              LOG.ERR log-stream fputs "Reached EOF before finding a character after single quote.\n" log-stream fputs 
              ERROR-EXIT-CODE exit drop
            end

            // Get the character
            buffer inc @8 let character in
              character '\\' = if
                // -------- Escapes --------
                // TODO: Add escapes.
                LOG.TODO log-stream fputs "Escapes are not implemented yet.\n" log-stream fputs
                ERROR-EXIT-CODE exit drop
              end

              buffer 2 + 1 file fgets is-zero if
                // Reached EOF while expecting a single quote.
                LOG.ERR log-stream fputs "Reached EOF before finding a single quote after single quote and character.\n" log-stream fputs
                ERROR-EXIT-CODE exit drop
              end

              buffer 2 + @8 '\'' != if
                // Was expecting a single quote, but found another character.
                LOG.ERR log-stream fputs "Expected a single quote, found '" log-stream fputs buffer 2 + 1 log-stream fputs "'.\n" log-stream fputs
                ERROR-EXIT-CODE exit drop
              end

              // Return token type, address and argument.
              TYPE-INTEGER file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address character
            end

          else buffer @8 '"' = if
            // -------- String type --------

            // Move the buffer-end left once, so the quote is removed.
            buffer-end @dec64

            char-no @inc64

            // Get full string.
            file line-no char-no buffer buffer-end log-stream parse-next-string

            // Return token type, address and argument.
            TYPE-STRING file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address buffer buffer-end @64 buffer - to-dynamic8

          else buffer @8 '/' = if
            // -------- Slash (Name and comments) --------

            buffer inc 1 file fgets is-zero if
              LOG.ERR log-stream fputs "Reached EOF while expecting character after slash (/).\n" log-stream fputs
              ERROR-EXIT-CODE exit drop
            end

            buffer inc @8 '/' = if
              // -------- Single line comment --------

              // Skip this line.
              file line-no char-no log-stream skip-line

              // Get next token and return it.
              file-name file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream extend-macros isn-zero get-next-token ! if false return end

            else buffer inc @8 '*' = if
              // -------- Block comment --------

              // Skip the block comment.
              file line-no char-no log-stream skip-block-comment

              // Get next token and return it.
              file-name file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream extend-macros isn-zero get-next-token ! if false return end
            else
              // -------- Name and keyword types --------
              file 1 neg SEEK-CUR lseek drop

              file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream create-name-token
            end end

          else
            // -------- Name and keyword types --------
            file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream create-name-token
          end end end end
        end
      end end
    end

    extend-macros is-zero if
      true return
    end

    // Check if the token is a macro call.
    let type address arg in
      type TYPE-NAME = if
        arg macro-names macro-tokens macros-length str-map64.get if
          let tokens in
            tokens tokens mlength 8 / extended-array EXTENDED-MAX-LENGTH extended-start extended-end deque64.extend-left
            file-name file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream extend-macros isn-zero get-next-token
          end
        else drop
          type address arg true
        end
      else
        type address arg true
      end
    end
  end
end end


proc create-int
  // -- ptr: stack-data
  -- ptr
in
  8 malloc let x in
    x is-null if
      "'malloc' failed while creating an integer stack value.\n" STDERR fputs
      ERROR-EXIT-CODE exit drop
    end

    TYPE-INT x !64
  x end
end


proc create-bool
  // -- ptr: stack-data
  -- ptr
in
  8 malloc let x in
    x is-null if
      "'malloc' failed while creating a boolean stack value.\n" STDERR fputs
      ERROR-EXIT-CODE exit drop
    end

    TYPE-BOOL x !64
  x end
end


proc push-int-constant
  // file-desc: output-file ptr: local-stack ptr: local-stack-length int: constant --
  file-desc ptr ptr int --
in let output-file local-stack local-stack-length constant in
  constant is-zero if
      "    xor     rax, rax\n" output-file fputs
  else
      "    mov     rax, " output-file fputs constant output-file fputu output-file fputnl
  end

  "    push    rax\n" output-file fputs
  
  create-int local-stack local-stack-length queue64.append
end end


proc compile-intrinsic-inside-procedure
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // file-desc: log-stream
  file-desc --

  // Compiles an intrinsic in a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let 
  source-name source-file output-file
  line-no char-no
  procedure-name procedure-address
  local-stack local-stack-length
  token-type token-address token-arg
  log-stream
in
  
  token-arg INTRINSIC-ADD = if
    // -------- Intrinsic '+' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '+' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    pop     rax\n"        output-file fputs
    "    add     [rsp], rax\n" output-file fputs

    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-BOR = if
    // -------- Intrinsic '||' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '||' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    pop     rax\n"        output-file fputs
    "    or      [rsp], rax\n" output-file fputs
    
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-BNOT = if
    // -------- Intrinsic '!!' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 1 < if
      LOG.ERR log-stream fputs "Intrinsic '!!' requires an integer, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    not     qword [rsp]\n"    output-file fputs
    
    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append
    
  else token-arg INTRINSIC-FULLMUL = if
    // -------- Intrinsic '**' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '**' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    xor     rdx, rdx\n"        output-file fputs
    "    mov     rbx, [rsp]\n"      output-file fputs
    "    mov     rax, [rsp+8]\n"    output-file fputs
    "    imul    rbx\n"             output-file fputs
    "    mov     [rsp], rax\n"      output-file fputs
    "    mov     [rsp+8], rdx\n"    output-file fputs
    
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append
    create-int local-stack local-stack-length queue64.append
    
  else token-arg INTRINSIC-DIVMOD = if
    // -------- Intrinsic '/%' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '/%' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    xor     rdx, rdx\n"        output-file fputs
    "    mov     rbx, [rsp]\n"      output-file fputs
    "    mov     rax, [rsp+8]\n"    output-file fputs
    "    idiv    rbx\n"             output-file fputs
    "    mov     [rsp+8], rax\n"    output-file fputs
    "    mov     [rsp], rdx\n"      output-file fputs
    
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append
    create-int local-stack local-stack-length queue64.append
    
  else token-arg INTRINSIC-UFULLMUL = if
    // -------- Intrinsic 'u**' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic 'u**' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    xor     rdx, rdx\n"        output-file fputs
    "    mov     rbx, [rsp]\n"      output-file fputs
    "    mov     rax, [rsp+8]\n"    output-file fputs
    "    mul     rbx\n"             output-file fputs
    "    mov     [rsp], rax\n"      output-file fputs
    "    mov     [rsp+8], rdx\n"    output-file fputs
    
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append
    create-int local-stack local-stack-length queue64.append
    
  else token-arg INTRINSIC-UDIVMOD = if
    // -------- Intrinsic 'u/%' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic 'u/%' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    xor     rdx, rdx\n"        output-file fputs
    "    mov     rbx, [rsp]\n"      output-file fputs
    "    mov     rax, [rsp+8]\n"    output-file fputs
    "    div     rbx\n"             output-file fputs
    "    mov     [rsp+8], rax\n"    output-file fputs
    "    mov     [rsp], rdx\n"      output-file fputs
    
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append
    create-int local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-NOTEQUAL = if
    // -------- Intrinsic '!=' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '!=' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    pop     rax\n"         output-file fputs
    "    sub     [rsp], rax\n"  output-file fputs

    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    create-bool local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-LESS = if
    // -------- Intrinsic '<' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '<' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    pop     rax\n"               output-file fputs
    "    pop     rbx\n"               output-file fputs
    "    sub     rax, rbx\n"          output-file fputs
    "    pushf\n"                     output-file fputs
    "    and     qword [rsp], 0x80\n" output-file fputs

    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    create-bool local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-LOAD8 = if
    // -------- Intrinsic '@8' --------
    
    // TODO: Check the type of arguments.
    local-stack-length @64 is-zero if
      LOG.ERR log-stream fputs "Intrinsic '@8' requires an integer, there was no item in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    xor     rax, rax\n"      output-file fputs
    "    pop     rbx\n"           output-file fputs
    "    mov     al, byte[rbx]\n" output-file fputs
    "    push    rax\n"           output-file fputs

    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-STORE8 = if
    // -------- Intrinsic '!8' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '!8' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    pop     rax\n"            output-file fputs
    "    pop     rbx\n"            output-file fputs
    "    mov     byte [rax], bl\n" output-file fputs

    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop

  else token-arg INTRINSIC-LOAD64 = if
    // -------- Intrinsic '@64' --------
    
    // TODO: Check the type of arguments.
    local-stack-length @64 is-zero if
      LOG.ERR log-stream fputs "Intrinsic '@64' requires an integer, there was no item in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    pop     rax\n"         output-file fputs
    "    push    qword [rax]\n" output-file fputs

    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-STORE64 = if
    // -------- Intrinsic '!64' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '!64' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    pop     rax\n"         output-file fputs
    "    pop     qword [rax]\n" output-file fputs

    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop

  else token-arg INTRINSIC-TRUE = if
    // -------- Intrinsic 'true' --------

    "    mov     rax, 0xffffffffffffffff\n" output-file fputs
    "    push    rax\n"                     output-file fputs

    create-bool local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-FALSE = if
    // -------- Intrinsic 'false' -------
    
    "    xor     rax, rax\n" output-file fputs
    "    push    rax\n"      output-file fputs

    create-bool local-stack local-stack-length queue64.append
    
  else token-arg INTRINSIC-SYSCALL6 = if
    // -------- Intrinsic 'syscall6' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 7 < if
      LOG.ERR log-stream fputs "'syscall6' requires 7 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end

    "    pop     rax\n" output-file fputs
    "    pop     r9\n" output-file fputs
    "    pop     r8\n" output-file fputs
    "    pop     r10\n" output-file fputs
    "    pop     rdx\n" output-file fputs
    "    pop     rsi\n" output-file fputs
    "    pop     rdi\n" output-file fputs
    "    syscall\n"     output-file fputs
    "    push    rax\n" output-file fputs

    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    local-stack local-stack-length queue64.pop-last drop
    create-int local-stack local-stack-length queue64.append

  else
    LOG.TODO log-stream fputs "Intrinsic '" log-stream fputs token-arg log-stream fput-intrinsic "' is not implemented yet.\n" log-stream fputs
    token-address log-stream fput-here
    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end end end end end end end end end end end end end end end end
end end


proc compile-procedure
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // file-desc: log-stream -- 
  file-desc --
  // local-memory-max: int
  int
  
  // Compiles a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let 
  source-name source-file output-file
  line-no char-no
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names macro-tokens macros-length
  procedure-name procedure-address
  local-stack local-stack-length
  extended-array extended-start extended-end
  log-stream
in
    
  "proc_" output-file fputs procedure-name procedure-name mlength output-file fputs ":\n" output-file fputs

  memory levels-list      sizeof(ptr)                     in

         // level-id-counter allows to create unique IDs for level labels.
  memory level-id-counter sizeof(int)                     in

         // let-names, let-addresses and let-vars-length create a str_map64.
  memory let-names        sizeof(ptr) LET-MAX-COUNT **    in
  memory let-addresses    sizeof(ptr) LET-MAX-COUNT **    in
  memory let-vars-length  sizeof(int)                     in
         
         // local-names, local-addresses and locals-length create a str_map64.
  memory local-names      sizeof(ptr) LOCALS-MAX-COUNT ** in
  memory local-addresses  sizeof(ptr) LOCALS-MAX-COUNT ** in
  memory locals-length    sizeof(int)                     in

         // local-memory-end keeps track of the first available position on the local memory.
  memory local-memory-end sizeof(int)                     in

         // local-memory-max keeps track of the maximum length of the local memory, to later allocate enough space.
  memory local-memory-max sizeof(int)                     in

         // branch-active keeps track of if the branch of the code ended.
  memory branch-active    1                               in

    16 list64.init let dynamic in
      dynamic is-null if
        LOG.ERR log-stream fputs "Could not create a list dynamic object.\n" log-stream fputs
        procedure-name procedure-address log-stream fput-inside-procedure
        ERROR-EXIT-CODE exit drop
      end
    dynamic levels-list !64 end

    0 level-id-counter !64
    0 let-vars-length  !64
    0 locals-length    !64
    0 local-memory-end !64
    0 local-memory-max !64
    
    0xff branch-active !8

    while true do
      source-name source-file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream true get-next-token ! if
        LOG.ERR log-stream fputs "Reached EOF while expecting procedure definition or 'end'.\n" log-stream fputs
        procedure-name procedure-address log-stream fput-inside-procedure
        ERROR-EXIT-CODE exit drop
      end

      let token-type token-address token-arg in
        token-type TYPE-INTEGER = if
          // -------- Constant integer --------

          branch-active @8 is-zero if
            LOG.SOFT log-stream fputs "Tried to push an immediate integer, but the branch was finished.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            ERROR-EXIT-CODE exit drop
          end

          output-file local-stack local-stack-length token-arg push-int-constant
          
        else token-type TYPE-STRING = if
          // -------- Strings --------

          branch-active @8 is-zero if
            LOG.SOFT log-stream fputs "Tried to create a string, but the branch was finished.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            ERROR-EXIT-CODE exit drop
          end

          // TODO: Change this to GLOBAL ADDRESS DATA
          "    mov     rax, data_" output-file fputs data-definitions-list list64.length output-file fputu output-file fputnl
          "    push    rax\n" output-file fputs
          
          create-int local-stack local-stack-length queue64.append
          
          output-file local-stack local-stack-length token-arg mlength push-int-constant

          token-arg data-definitions-list list64.append

        else token-type TYPE-NAME = if
          // -------- Names --------

          branch-active @8 is-zero if
            LOG.ERR log-stream fputs "Tried to call name '" log-stream fputs token-arg token-arg mlength log-stream fputs "', but the branch was finished.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            ERROR-EXIT-CODE exit drop
          end
            
          token-arg let-names let-addresses let-vars-length str-map64.get if
            // -------- 'let' variables --------
                        
            let address in
              "    mov     rax, qword [local_ptr]\n" output-file fputs
              
              "    push    qword [rax" output-file fputs address isn-zero if " + " output-file fputs address output-file fputu end "]\n" output-file fputs

              create-int local-stack local-stack-length queue64.append
            end
            
          else drop token-arg local-names local-addresses locals-length str-map64.get if
            // -------- 'memory' variables --------
            
            let address in
              "    push    qword [local_ptr]\n" output-file fputs
              
              address isn-zero if
                "    add     qword [rsp], " output-file fputs address output-file fputu output-file fputnl
              end
              
              create-int local-stack local-stack-length queue64.append
            end

          else drop token-arg proc-names-array proc-names-array procs-length @64 8 * + str-sorted8.available if
            // -------- 'proc' calls --------
            
            let name-address in name-address proc-names-array - let delta in
              delta proc-inputs-array + delta proc-outputs-array + let input-address output-address in
                memory input-length  sizeof(int) in
                memory output-length sizeof(int) in
                
                  input-address  @64 mlength 8 / input-length  !64
                  output-address @64 mlength 8 / output-length !64

                  // TODO: This system must be changed.
                  while input-length @64 isn-zero do
                    input-address @64 input-length queue64.pop-last let expect in

                      local-stack-length @64 is-zero if
                        LOG.ERR log-stream fputs "Not enough items in the stack to call procedure '" log-stream fputs token-arg token-arg mlength log-stream fputs "'.\n" log-stream fputs
                        token-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end

                      local-stack local-stack-length queue64.pop-last let got in
                        expect got @64 != if
                          LOG.ERR log-stream fputs "Stack does not match with the argument types of procedure '" log-stream fputs token-arg token-arg mlength log-stream fputs "'.\n" log-stream fputs
                          token-address log-stream fput-here
                          procedure-name procedure-address log-stream fput-inside-procedure
                          ERROR-EXIT-CODE exit drop
                        end
                      end
                    end
                  end

                  "    xchg    rsp, [call_ptr]\n"              output-file fputs         
                  "    push    .level_"                        output-file fputs level-id-counter @64 output-file fputu output-file fputnl
                  "    push    qword [local_ptr]\n"            output-file fputs         
                  "    add     qword [local_ptr], "            output-file fputs local-memory-end @64 output-file fputu output-file fputnl
                  "    xchg    rsp, [call_ptr]\n"              output-file fputs         
                  "    jmp     proc_"                          output-file fputs token-arg token-arg mlength output-file fputs output-file fputnl
                  ".level_"                                    output-file fputs level-id-counter @64 output-file fputu ":\n" output-file fputs

                  level-id-counter @inc64
                  // TODO: This system must be changed.
                  0 while dup output-length @64 < do let i in                    
                    i 8 * output-address @64 + @64 let output in                      
                      output TYPE-INT = if
                        create-int local-stack local-stack-length queue64.append
                      else output TYPE-BOOL = if
                        create-bool local-stack local-stack-length queue64.append
                      else
                        log-stream report-bug
                        token-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end end
                    end
                  i end inc end drop
                end end
              end
            end end
            
          else drop
            // TODO: Add Levenshtein distance algoritm to show the nearest matchs; which can be definitions, macros, procedures, keywords and intrinsics.
            
            LOG.ERR log-stream fputs "Name '" log-stream fputs token-arg token-arg mlength log-stream fputs "' is not defined as a local variable or a macro.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            ERROR-EXIT-CODE exit drop
          end end end

        else token-type TYPE-INTRINSIC = if
          // -------- Intrinsics --------

          branch-active @8 is-zero if
            LOG.SOFT log-stream fputs "Tried to call intrinsic '" log-stream fputs token-arg log-stream fput-intrinsic "', but the branch was finished.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            ERROR-EXIT-CODE exit drop
          end
          
          source-name source-file output-file
          line-no char-no
          procedure-name procedure-address
          local-stack local-stack-length
          token-type token-address token-arg
          log-stream
          compile-intrinsic-inside-procedure

        else token-type TYPE-KEYWORD = if          
          // -------- Keywords --------

          token-arg KEYWORD-END = if
            // -------- Keyword 'end' --------

            levels-list list64.length is-zero if
              // -------- End of 'proc' --------

              branch-active @8 is-zero if
                LOG.SOFT log-stream fputs "Branch was cut right before end of procedure.\n" log-stream fputs
                token-address log-stream fput-here
                procedure-name procedure-address log-stream fput-inside-procedure
                ERROR-EXIT-CODE exit drop
              end              

              local-memory-max @64 return
            end

            levels-list list64.pop-last let level in
              level @64 level 8 + @64 let start-keyword start-address in                
                start-keyword KEYWORD-IF = if
                  // -------- End of 'if' --------
                  // TODO: Check for stack change.

                  branch-active @8 is-zero if
                    level 16 + @64 level 24 + @64 let start-id start-stack in
                      start-stack local-stack start-stack mlength 8 / memcpy64
                      start-stack mlength 8 / local-stack-length !64
                    end

                    // Reset the branch.
                    0xff branch-active !8
                  end

                  level 16 + @64 level 24 + @64 let start-id start-stack in
                    ".level_" output-file fputs start-id output-file fputu ":\n" output-file fputs
                  end

                else start-keyword KEYWORD-ELSE = if
                  // -------- End of 'else' --------
                  // TODO: Check for stack change.

                  branch-active @8 is-zero if
                    LOG.SOFT log-stream fputs "Branch cutting in an 'else-end' statement is unnecessary. Invert the condition and use an 'if-end' instead.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    ERROR-EXIT-CODE exit drop
                  end

                  ".level_" output-file fputs level 16 + @64 output-file fputu ":\n" output-file fputs
                else start-keyword KEYWORD-WHILE = if
                  // -------- End of 'while' --------
                  
                  LOG.ERR  log-stream fputs "You probably forgot a 'do' after 'while'.\n" log-stream fputs
                  LOG.INFO log-stream fputs "A 'while-do' loop can be created as: 'while <condition> do <code> end'\n" log-stream fputs
                  token-address log-stream fput-here
                  start-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop

                else start-keyword KEYWORD-DO = if
                  // -------- End of 'do' --------
                  
                  branch-active @8 is-zero if
                    LOG.ERR log-stream fputs "A 'while-do' loop should not be cut, use 'if' instead" log-stream fputs
                    token-address log-stream fput-here
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    ERROR-EXIT-CODE exit drop
                  end              
                  
                  level 16 + @64 level 24 + @64 let  start-id start-stack in
                    levels-list list64.length is-zero if
                      LOG.ERR  log-stream fputs "Expected a 'while' before 'do'.\n" log-stream fputs
                      LOG.INFO log-stream fputs "A 'while-do' loop can be created as: 'while <condition> do <code> end'\n" log-stream fputs
                      token-address log-stream fput-here
                      start-address log-stream fput-here
                      procedure-name procedure-address log-stream fput-inside-procedure
                      ERROR-EXIT-CODE exit drop
                    end

                    levels-list list64.pop-last let while-level in
                      while-level @64 while-level 8 + @64 let while-keyword while-address in
                        while-keyword KEYWORD-WHILE != if
                          LOG.ERR  log-stream fputs "Expected a 'while' before 'do', got '" log-stream fputs while-keyword log-stream fput-keyword "'.\n" log-stream fputs
                          LOG.INFO log-stream fputs "A 'while-do' loop can be created as: 'while <condition> do <code> end'\n" log-stream fputs
                          token-address log-stream fput-here
                          while-address log-stream fput-here
                          start-address log-stream fput-here
                          procedure-name procedure-address log-stream fput-inside-procedure
                          ERROR-EXIT-CODE exit drop
                        end

                        while-level 16 + @64 while-level 24 + @64 let while-id while-stack in
                          // TODO: Check for stack changes.

                          "    jmp     .level_" output-file fputs while-id output-file fputu output-file fputnl
                          ".level_"             output-file fputs start-id output-file fputu ":\n" output-file fputs

                          start-stack local-stack start-stack mlength 8 / memcpy64
                          start-stack mlength 8 / local-stack-length !64
                        end
                      end
                    end
                  end

                else start-keyword KEYWORD-LET = if
                  // -------- End of 'let' --------
                  
                  level 16 + @64 level 24 + @64 let new-names old-local-memory-end in
                    0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
                      name mlength 1 = if name @8 '_' != else true end if
                        name let-names let-addresses let-vars-length str-map64.remove ! if
                          LOG.ERR  log-stream fputs "Could not find the 'let' variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                          LOG.INFO log-stream fputs "This is probably caused by a bug in the compiler.\n" log-stream fputs
                          token-address log-stream fput-here
                          start-address log-stream fput-here
                          procedure-name procedure-address log-stream fput-inside-procedure
                          ERROR-EXIT-CODE exit drop
                        end
                      end
                    end i end inc end drop

                    old-local-memory-end local-memory-end !64
                  end

                else start-keyword KEYWORD-MEMORY = if
                  // -------- End of 'memory' --------

                  level 16 + @64 level 24 + @64 let new-names old-local-memory-end in
                    0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
                      name local-names local-addresses locals-length str-map64.remove ! if
                        LOG.ERR  log-stream fputs "Could not find the local variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                        LOG.INFO log-stream fputs "This is probably caused by a bug in the compiler.\n" log-stream fputs
                        token-address log-stream fput-here
                        start-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end
                    end i end inc end drop

                    old-local-memory-end local-memory-end !64
                  end

                else
                  LOG.TODO log-stream fputs "'end' after keyword '" log-stream fputs start-keyword log-stream fput-keyword "' is not implemented yet.\n" log-stream fputs
                  token-address log-stream fput-here
                  start-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
                end end end end end end
              end
            end

          else token-arg KEYWORD-IF = if
            // -------- Keyword 'if' --------
            // <condition> if <any> end
            // <condition> if <any> else <any> end

            // TODO: These are not implemented yet.
            // <condition> if <any> (elif <condition> if <any>)* end
            
            // Level structure:
            //  0- 7 -> KEYWORD-IF
            //  8-15 -> Starter address
            // 16-23 -> Level ID
            // 24-32 -> Old stack

            branch-active @8 is-zero if
              LOG.SOFT log-stream fputs "Branch was cut before 'if'.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end

            local-stack-length @64 is-zero if
              LOG.ERR log-stream fputs "'if' requires a bool, there was no items in the stack.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end

            // TODO: Check for the data type
            local-stack-length @dec64

            local-stack local-stack-length @64 to-dynamic64 let copy-stack in
              copy-stack is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while copying the stack for 'if'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
              end

              32 malloc let obj in
                obj is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while creating a level object for 'if'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
                end

                KEYWORD-IF           obj      !64
                token-address        obj 8  + !64
                level-id-counter @64 obj 16 + !64
                copy-stack           obj 24 + !64

                obj levels-list list64.append

                "    pop     rax\n"      output-file fputs
                "    test    rax, rax\n" output-file fputs
                "    jz      .level_"    output-file fputs level-id-counter @64 output-file fputu output-file fputnl

                level-id-counter @inc64
              end
            end

          else token-arg KEYWORD-ELSE = if
            // -------- Keyword 'else' --------
            // <condition> if <any> else <any> end

            // Level structure:
            //  0- 7 -> KEYWORD-ELSE
            //  8-15 -> If address
            // 16-23 -> Else address
            // 24-31 -> Level ID
            // 32-39 -> Old stack

            // TODO: Add stack check.

            branch-active @8 is-zero if
              LOG.SOFT log-stream fputs "Using an 'else' after the branch is cut is unnecessary, just use 'if-end'.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end

            levels-list list64.length is-zero if
              LOG.ERR log-stream fputs "'else' requires 'if'.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end

            levels-list list64.pop-last let level in
              level @64 KEYWORD-IF != if
                LOG.ERR log-stream fputs "'else' requires an 'if', but there was an unclosed '" log-stream fputs level @64 log-stream fput-keyword "'.\n" log-stream fputs
                token-address log-stream fput-here
                level 8 + @64 log-stream fput-here
                procedure-name procedure-address log-stream fput-inside-procedure
                ERROR-EXIT-CODE exit drop
              end

              level 8 + @64 level 16 + @64 level 24 + @64 let start-address start-id start-stack in
                start-stack local-stack start-stack mlength 8 / memcpy64
                start-stack mlength 8 / local-stack-length !64

                "    jmp     .level_" output-file fputs level-id-counter @64 output-file fputu output-file fputnl
                ".level_" output-file fputs start-id output-file fputu ":\n" output-file fputs

                local-stack local-stack-length @64 to-dynamic64 let copy-stack in
                  copy-stack is-null if
                    LOG.ERR log-stream fputs "'malloc' failed while copying the stack for 'while'.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    ERROR-EXIT-CODE exit drop
                  end

                  40 malloc let new-level in
                    new-level is-null if
                      LOG.ERR log-stream fputs "'malloc' failed while creating a level object for 'else'.\n" log-stream fputs
                      token-address log-stream fput-here
                      procedure-name procedure-address log-stream fput-inside-procedure
                      ERROR-EXIT-CODE exit drop
                    end

                    KEYWORD-ELSE         new-level      !64
                    start-address        new-level 8  + !64
                    token-address        new-level 16 + !64
                    level-id-counter @64 new-level 24 + !64
                    copy-stack           new-level 32 + !64

                    new-level levels-list list64.append
                  end
                end

                level-id-counter @inc64
              end
            end

          else token-arg KEYWORD-WHILE = if
            // -------- Keyword 'while' --------
            // while <condition> do <any> end
            
            // Level structure:
            //  0- 7 -> KEYWORD-WHILE
            //  8-15 -> Starter address 
            // 16-23 -> Level ID
            // 24-31 -> Old stack

            branch-active @8 is-zero if
              LOG.SOFT log-stream fputs "Branch was cut before 'while'.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end
            
            local-stack local-stack-length @64 to-dynamic64 let copy-stack in
              copy-stack is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while copying the stack for 'while'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
              end

              32 malloc let new-level in
                new-level is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while creating a level object for 'while'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
                end

                KEYWORD-WHILE        new-level      !64
                token-address        new-level 8  + !64
                level-id-counter @64 new-level 16 + !64
                copy-stack           new-level 24 + !64

                new-level levels-list list64.append
              end
            end
            
            ".level_" output-file fputs level-id-counter @64 output-file fputu ":\n" output-file fputs
            level-id-counter @inc64

          else token-arg KEYWORD-DO = if
            // -------- Keyword 'do' --------
            // while <condition> do <any> end
            
            // Level structure:
            //  0- 7 -> KEYWORD-DO
            //  8-15 -> Starter address
            // 16-23 -> Level ID
            // 24-32 -> Old stack

            // TODO: 'do' level struct should contain the 'while' level components.

            branch-active @8 is-zero if
              LOG.ERR log-stream fputs "Branch was cut before 'do'.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end
            
            local-stack-length @64 is-zero if
              LOG.ERR log-stream fputs "'do' requires a bool, there was no items in the stack.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end

            // TODO: Unfinished, should add stack value type check.
            local-stack local-stack-length queue64.pop-last drop
            
            local-stack local-stack-length @64 to-dynamic64 let copy-stack in
              copy-stack is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while copying the stack for 'do'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
              end

              32 malloc let obj in
                obj is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while creating a level object for 'do'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
                end

                KEYWORD-DO           obj      !64
                token-address        obj 8  + !64
                level-id-counter @64 obj 16 + !64
                copy-stack           obj 24 + !64

                obj levels-list list64.append

                "    pop     rax\n"      output-file fputs
                "    test    rax, rax\n" output-file fputs
                "    jz      .level_"    output-file fputs level-id-counter @64 output-file fputu output-file fputnl

                level-id-counter @inc64
              end
            end

          else token-arg KEYWORD-MEMORY = if
            // -------- Keyword 'memory' -------
            // memory <name> <size> in <any> end

            // TODO: These are not implemented yet.
            // memory <name> <size> (and <name> <size>)* in <any> end
            
            // Level structure:
            //  0- 7 -> KEYWORD-MEMORY
            //  8-15 -> Starter address
            // 16-23 -> New names
            // 24-31 -> Old local-memory-end
            
            branch-active @8 is-zero if
              LOG.ERR log-stream fputs "Branch was cut before 'do'.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end

            // New names are stored in new-names and new-names-length queue. When the 'end' of 'memory' is reached, new names are deleted from the namespace.
            memory new-names        sizeof(ptr) VARS-MAX-ONCE ** in
            memory new-names-length sizeof(int)                  in

              0 new-names-length !64

              32 malloc let obj in
                obj is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while creating a level object for 'memory'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
                end

                KEYWORD-MEMORY          obj      !64
                token-address    dcopy8 obj  8 + !64
                local-memory-end @64    obj 24 + !64

                // TODO: Add 'and' keyword.
                // TODO: Add proper pre-compilation for memory size.

                // Get the variable name.
                source-name source-file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream false get-next-token ! if
                  LOG.ERR log-stream fputs "Reached EOF while expecting a local variable name after 'memory'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
                end

                let memory-name-type memory-name-address memory-name-arg in
                  memory-name-type TYPE-NAME != if
                    LOG.ERR log-stream fputs "Expected 'name' for local variable name after 'memory', got '" log-stream fputs memory-name-type log-stream fput-type "'.\n" log-stream fputs
                    memory-name-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    ERROR-EXIT-CODE exit drop
                  end

                  // Get the variable size.
                  source-name source-file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream true get-next-token ! if
                    LOG.ERR log-stream fputs "Reached EOF while expecting a local variable size after 'memory'.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    ERROR-EXIT-CODE exit drop
                  end

                  let memory-size-type memory-size-address memory-size-arg in
                    memory-size-type TYPE-INTEGER != if
                      LOG.ERR log-stream fputs "Expected 'integer' for local variable size after 'memory', got '" log-stream fputs memory-size-type log-stream fput-type "'.\n" log-stream fputs
                      memory-size-address log-stream fput-here
                      procedure-name procedure-address log-stream fput-inside-procedure
                      ERROR-EXIT-CODE exit drop
                    end

                    source-name source-file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream true get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting a local variable size after 'memory'.\n" log-stream fputs
                      token-address log-stream fput-here
                      procedure-name procedure-address log-stream fput-inside-procedure
                      ERROR-EXIT-CODE exit drop
                    end

                    let memory-end-type memory-end-address memory-end-arg in
                      memory-end-type TYPE-KEYWORD != if
                        LOG.ERR log-stream fputs "Expected 'keyword' after 'memory', got '" log-stream fputs memory-end-type log-stream fput-type "'.\n" log-stream fputs
                        memory-end-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end

                      memory-end-arg KEYWORD-AND = if
                        LOG.TODO log-stream fputs "'and' after 'memory' for local variable allocation is not implemented yet.\n" log-stream fputs
                        memory-end-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                        
                      else memory-end-arg KEYWORD-IN = if
                        // TODO: Check if the new-names queue is full.

                        memory-name-arg new-names new-names-length queue64.append
                        memory-name-arg local-memory-end @64 local-names local-addresses locals-length str-map64.set if
                          LOG.ERR log-stream fputs "Local variable '" log-stream fputs memory-name-arg memory-name-arg mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                          memory-name-address log-stream fput-here
                          procedure-name procedure-address log-stream fput-inside-procedure
                          ERROR-EXIT-CODE exit drop
                        end

                        local-memory-end @64 memory-size-arg + local-memory-end !64
                      else
                        LOG.ERR log-stream fputs "Expected 'and' or 'in' after local variable, got '" log-stream fputs memory-end-arg log-stream fput-keyword "'.\n" log-stream fputs
                        memory-end-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end end
                    end
                  end
                end

                local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

                new-names new-names-length @64 to-dynamic64 let new in
                  new is-null if
                    LOG.ERR log-stream fputs "'malloc' failed while allocating space for new-names after 'memory'.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    ERROR-EXIT-CODE exit drop
                  end

                  new obj 16 + !64
                end

                obj levels-list list64.append
              end
            end end

          else token-arg KEYWORD-LET = if
            // -------- Keyword 'let' --------
            // let <name>* in <any> end
            
            // Level structure:
            //  0- 7 -> KEYWORD-LET
            //  8-15 -> Starter address
            // 16-23 -> New names
            // 24-32 -> Old local-memory-end
            
            branch-active @8 is-zero if
              LOG.ERR log-stream fputs "Branch was cut before 'do'.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end

            // New names are stored in new-names and new-names-length queue. When the 'end' of 'let' is reached, new names are deleted from the namespace.
            // TODO: Convert new-names and new-names-length to a vector, so that it can have infinite storage.
            memory new-names        sizeof(ptr) VARS-MAX-ONCE ** in
            memory new-names-length sizeof(int)                  in

              0 new-names-length !64

              32 malloc let obj in
                obj is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while creating a level object for 'let'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  ERROR-EXIT-CODE exit drop
                end

                KEYWORD-LET             obj      !64
                token-address    dcopy8 obj  8 + !64
                local-memory-end @64    obj 24 + !64

                while true do
                  source-name source-file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream false get-next-token ! if
                    LOG.ERR log-stream fputs "Reached EOF while expecting a name for let variable.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    ERROR-EXIT-CODE exit drop
                  end

                  let new-token-type new-token-address new-token-arg in
                    new-token-type TYPE-KEYWORD = if
                      new-token-arg KEYWORD-IN != if
                        LOG.ERR log-stream fputs "Unexpected keyword while expecting a name for 'let' variable or 'in', got '" log-stream fputs new-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                        new-token-address log-stream fput-here
                        token-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end

                      break
                    end

                    new-token-type TYPE-NAME = if
                      new-names-length VARS-MAX-ONCE = if
                        LOG.ERR log-stream fputs "new-names-length was equal to VARS-MAX-ONCE.\n" log-stream fputs
                        new-token-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end
                      
                      // TODO: Change the way that the variables are stored, so that we can also store their addresses.
                      new-token-arg dcopy8 new-names new-names-length queue64.append

                    else
                      LOG.ERR log-stream fputs "Unexpected type while expecting a name for 'let' variable or 'in', got '" log-stream fputs new-token-type log-stream fput-type "'.\n" log-stream fputs
                      new-token-address log-stream fput-here
                      token-address log-stream fput-here
                      procedure-name procedure-address log-stream fput-inside-procedure
                      ERROR-EXIT-CODE exit drop
                    end
                  end
                end

                // This loop is seperated from the one above, since this loop must run in the reverse order.
                new-names-length @64 while dup isn-zero do dec let i in
                  local-stack-length @64 is-zero if
                    LOG.ERR log-stream fputs "Expected a data before 'let' variable, but the stack was empty.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    ERROR-EXIT-CODE exit drop
                  end

                  local-stack local-stack-length queue64.pop-last drop

                  new-names i 8 * + @64 mlength 1 = if new-names i 8 * + @64 @8 '_' = else false end if
                    "    pop     rax\n" output-file fputs
                  else
                    "    mov     rax, qword [local_ptr]\n" output-file fputs
                    "    pop     qword [rax" output-file fputs local-memory-end @64 isn-zero if " + " output-file fputs local-memory-end @64 output-file fputu end "]\n" output-file fputs

                    new-names i 8 * + @64 local-memory-end @64 let-names let-addresses let-vars-length str-map64.set if
                      LOG.ERR log-stream fputs "'let' variable '" log-stream fputs new-names i 8 * + @64 dup mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                      procedure-name procedure-address log-stream fput-inside-procedure
                      ERROR-EXIT-CODE exit drop
                    end

                    local-memory-end @64 8 + local-memory-end !64
                  end
                  
                i end end drop

                local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

                new-names new-names-length @64 to-dynamic64 let new in
                  new is-null if
                    LOG.ERR log-stream fputs "'malloc' failed while allocating space for new-names after 'memory'.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    ERROR-EXIT-CODE exit drop
                  end

                  new obj 16 + !64
                end

                obj levels-list list64.append
              end
            end end
            
          else token-arg KEYWORD-RETURN = if
            // -------- Keyword 'return' --------
          
            branch-active @8 is-zero if
              LOG.ERR log-stream fputs "Branch was cut before 'return'.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              ERROR-EXIT-CODE exit drop
            end

            // TODO: Add stack checks.

            "    jmp     .return\n" output-file fputs

            0 branch-active !8
            
          else
            LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            ERROR-EXIT-CODE exit drop
          end end end end end end end end

        else
          LOG.ERR log-stream fputs "Unexpected type while expecting a keyword, an intrinsic, a string or an integer, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
          token-address log-stream fput-here
          procedure-name procedure-address log-stream fput-inside-procedure
          ERROR-EXIT-CODE exit drop
        end end end end end
      end
    end
  end end end end end end end end end end end
end 0 end // dummy return


proc compile-file
  // ptr: source-name file-desc: output-file
  ptr file-desc
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // libraries-set
  ptr 
  // file-desc: log-stream
  file-desc --
  
  // Compiles a Corth source file.
  // Compilation warning and errors are dumped to log-stream.

  // TODO: Add called-from to improve debugging.
in let
  source-name output-file
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names-array macro-tokens-array macros-length
  libraries-set
  log-stream
in
  // Check if the library was included already.
  source-name libraries-set str-set8.add ! if
    // TODO: Use called-from to improve debugging.
    LOG.INFO log-stream fputs "Skipping library '" log-stream fputs source-name source-name mlength log-stream fputs "' because it was already included.\n" log-stream fputs
    return
  end
  
  LOG.INFO log-stream fputs "Including library '" log-stream fputs source-name source-name mlength log-stream fputs "'.\n" log-stream fputs

  // Open the source file.
  source-name null-term8 fopen-r

  let source-file in
    // Check if the source is opened.
    source-file isn-pos if
      LOG.ERR log-stream fputs "Could not open source file '" log-stream fputs source-name source-name mlength dec log-stream fputs "'\n" log-stream fputs
      ERROR-EXIT-CODE exit drop
    end

    memory extended-array  sizeof(int) EXTENDED-MAX-LENGTH ** in
    memory extended-start  sizeof(int)                        in
    memory extended-end    sizeof(int)                        in
           
    memory line-no         sizeof(int)                        in
    memory char-no         sizeof(int)                        in

      // Reset extended-tokens.
      0 extended-start !64
      0 extended-end   !64

      // Reset line-no and char-no variables.
      1 line-no !64
      0 char-no !64

      // Get next token and check if there is one available.
      while source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream true get-next-token do
        let token-type token-address token-arg in
          token-type TYPE-KEYWORD = if
            // -------- Global keywords --------
            token-arg KEYWORD-INCLUDE = if
              // -------- Keyword 'include' -------- 
              // TODO: Create a function to include.
              // TODO: Allow including packages.
              // TODO: Add library search locations.

              // Get the next token, which should be the include path.
              source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream false get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting an include path.\n" log-stream fputs
                token-address log-stream fput-here
                ERROR-EXIT-CODE exit drop
              end

              let path-token-type path-token-address path-token-arg in
                path-token-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for path after 'include', got '" log-stream fputs path-token-type log-stream fput-type "'.\n" log-stream fputs
                  path-token-address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                end

                path-token-arg null-term8 let termed-path in
                  memory stats sizeof(stat) in
                    termed-path stats stat drop

                    stats 24 + @64 S_IFMT && let masked in
                      // Check if the include path exists.
                      termed-path F_OK access isn-zero if
                        LOG.ERR log-stream fputs "Path '" log-stream fputs path-token-arg path-token-arg mlength log-stream fputs "' does not exist.\n" log-stream fputs
                        path-token-address log-stream fput-here
                        ERROR-EXIT-CODE exit drop
                      end

                      // Check if the user has read permission for this file.
                      termed-path R_OK access isn-zero if
                        LOG.ERR log-stream fputs "Path '" log-stream fputs path-token-arg path-token-arg mlength log-stream fputs "' can not be read, because the user does not have permissions.\n" log-stream fputs
                        path-token-address log-stream fput-here
                        ERROR-EXIT-CODE exit drop
                      end
                      
                      masked S_IFREG = if
                        // File including, call compile-file on the file.
                        path-token-arg output-file
                        data-definitions-list
                        global-names-array global-sizes-array globals-length
                        proc-names-array proc-inputs-array proc-outputs-array procs-length
                        macro-names-array macro-tokens-array macros-length
                        libraries-set
                        log-stream compile-file
                        
                      else masked S_IFDIR = if
                        // Directory including, should include all sub paths.
                        LOG.TODO log-stream fputs "Including directories is not implemented yet.\n" log-stream fputs 
                        ERROR-EXIT-CODE exit drop
                        
                      else
                        LOG.ERR log-stream fputs "Invalid file type, got " log-stream fputs masked log-stream fputo ".\n" log-stream fputs
                        path-token-address log-stream fput-here
                        ERROR-EXIT-CODE exit drop
                      end end
                    end
                  end
                end
              end
              
            else token-arg KEYWORD-MEMORY = if
              // -------- Keyword 'memory' --------
              
              // Get the next token, which sould be the include path.
              source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream false get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a global variable name after 'memory'.\n" log-stream fputs
                token-address log-stream fput-here
                ERROR-EXIT-CODE exit drop
              end

              let memory-name-type memory-name-address memory-name-arg in
                memory-name-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for global variable name after 'memory', got '" log-stream fputs memory-name-type log-stream fput-type "'.\n" log-stream fputs
                  memory-name-address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                end

                // TODO: Implement size calculation.
                source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream false get-next-token ! if
                  LOG.ERR log-stream fputs "Reached EOF while expecting a global variable size after 'memory'.\n" log-stream fputs
                  token-address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                end

                let memory-size-type memory-size-address memory-size-arg in
                  memory-size-type TYPE-INTEGER != if
                    LOG.ERR log-stream fputs "Expected an 'int' for global variable size after 'memory', got '" log-stream fputs memory-size-type log-stream fput-type ".\n" log-stream fputs
                    memory-size-type log-stream fput-here
                    ERROR-EXIT-CODE exit drop
                  end

                  source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream true get-next-token ! if
                    LOG.ERR log-stream fputs "Reached EOF while expecting global variable size after 'memory'.\n" log-stream fputs
                    token-address log-stream fput-here
                    ERROR-EXIT-CODE exit drop
                  end

                  let end-token-type end-token-address end-token-arg in
                    end-token-type TYPE-KEYWORD != if
                      LOG.ERR log-stream fputs "Expected an 'int' for global variable size after 'memory', got '" log-stream fputs end-token-type log-stream fput-type "'.\n" log-stream fputs
                      end-token-address log-stream fput-here
                      ERROR-EXIT-CODE exit drop
                    end

                    end-token-arg KEYWORD-END != if
                      LOG.ERR log-stream fputs "Unexpected keyword while expecting global variable size, got '" log-stream fputs end-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                      end-token-address log-stream fput-here
                      ERROR-EXIT-CODE exit drop
                    end
                  end

                  // TODO: Check if the global variable queue was filled.
                  memory-name-arg memory-size-arg global-names-array global-sizes-array globals-length str-map64.set drop
                end
              end
              
            else token-arg KEYWORD-MACRO = if
              // -------- Keyword 'macro' --------

              // Get the next token, which should be the name of the macro.
              source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream false get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a macro name.\n" log-stream fputs
                token-address log-stream fput-here
                ERROR-EXIT-CODE exit drop
              end

              let macro-name-token-type macro-name-token-address macro-name-token-arg in
                macro-name-token-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for macro name after 'macro', got '" log-stream fputs macro-name-token-type log-stream fput-type "'.\n" log-stream fputs
                  macro-name-token-address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                end

                // macro-tokens-array and macro-tokens-length are used to create a QUEUE for macro tokens.
                memory macro-tokens-list sizeof(ptr) in
                  16 list64.init let dynamic in
                    dynamic is-null if
                      LOG.ERR log-stream fputs "Could not create list dynamic object.\n" log-stream fputs
                      ERROR-EXIT-CODE exit drop
                    end
                  dynamic macro-tokens-list !64 end
                       
                  while true do
                    // Get next tokens, until an 'endmacro' is found.
                    source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream false get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting an 'endmacro' in macro '" log-stream fputs macro-name-token-arg macro-name-token-arg mlength log-stream fputs "'.\n" log-stream fputs
                      token-address log-stream fput-here
                      ERROR-EXIT-CODE exit drop
                    end

                    let macro-new-token-type macro-new-token-address macro-new-token-arg in
                      macro-new-token-type TYPE-KEYWORD = if
                        macro-new-token-arg KEYWORD-ENDMACRO = if
                          break
                        end
                      end

                      macro-new-token-type    macro-tokens-list list64.append
                      macro-new-token-address macro-tokens-list list64.append
                      macro-new-token-arg     macro-tokens-list list64.append
                    end
                  end

                  // TODO: Check if the macros queue was filled.
                  macro-tokens-list list64.array-addr macro-tokens-list list64.length to-dynamic64 let object in
                    macro-name-token-arg object macro-names-array macro-tokens-array macros-length str-map64.set drop
                  end
                end
              end
              
            else token-arg KEYWORD-PROC = if
              // -------- 'proc' keyword --------

              // Get the next token, which should be the name of the procedure.
              source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream false get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a procedure name.\n" log-stream fputs
                token-address log-stream fput-here
                ERROR-EXIT-CODE exit drop
              end

              let proc-name-token-type proc-name-token-address proc-name-token-arg in
                proc-name-token-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for procedure name after 'proc', got " log-stream fputs proc-name-token-type log-stream fput-type "'.\n" log-stream fputs
                  proc-name-token-address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                end

                memory input-list sizeof(ptr) in
                memory output-list sizeof(ptr) in

                  16 list64.init input-list !64
                  16 list64.init output-list !64

                  // Get the input types.
                  while true do
                    // Get the token.
                    source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream true get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting procedure input type.\n" log-stream fputs
                      token-address log-stream fput-here
                      proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                      ERROR-EXIT-CODE exit drop
                    end

                    let input-token-type input-token-address input-token-arg in
                      input-token-type TYPE-KEYWORD = if
                        // If the token was a keyword, it must be a 'KEYWORD-RETURN'.
                        input-token-arg KEYWORD-RETURNS != if
                          LOG.ERR log-stream fputs "Unexpected keyword while expecting input type or '--', got '" log-stream fputs input-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                          token-address log-stream fput-here
                          proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                          ERROR-EXIT-CODE exit drop
                        end

                        // If the token was a 'KEYWORD-RETURN', break the loop.
                        break
                      end
                      
                      input-token-type TYPE-TYPE = if
                        // TODO: Check if the input queue was filled.
                        input-token-arg input-list list64.append
                        
                      else
                        LOG.ERR log-stream fputs "Expected a 'type' for input type or '--', got '" log-stream fputs input-token-type log-stream fput-type "'.\n" log-stream fputs
                        input-token-address log-stream fput-here
                        proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end
                    end
                  end

                  // Get the output types.
                  while true do
                    // Get the token.
                    source-name source-file line-no char-no extended-array extended-start extended-end macro-names-array macro-tokens-array macros-length log-stream true get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting procedure output type.\n" log-stream fputs
                      token-address log-stream fput-here
                      proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                      ERROR-EXIT-CODE exit drop
                    end

                    let output-token-type output-token-address output-token-arg in
                      output-token-type TYPE-KEYWORD = if
                        // If the token is a keyword, it must be a 'KEYWORD-IN'.
                        output-token-arg KEYWORD-IN != if
                          LOG.ERR log-stream fputs "Unexpected keyword while expecting output type or 'in', got '" log-stream fputs output-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                          token-address log-stream fput-here
                          proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                          ERROR-EXIT-CODE exit drop
                        end

                        // If the token was a 'KEYWORD-IN', break the loop.
                        break
                      end

                      // Check if the token is of type-type.
                      output-token-type TYPE-TYPE != if
                        LOG.ERR log-stream fputs "Expected a 'type' for output type or 'in', got '" log-stream fputs output-token-type log-stream fput-type "'.\n" log-stream fputs
                        output-token-address log-stream fput-here
                        proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end

                      output-token-arg output-list list64.append
                    end
                  end

                  // Store the procedure name, input and outputs.
                  // Check if the procedure was defined already.
                  proc-name-token-arg proc-names-array proc-names-array procs-length @64 8 * + str-sorted8.available if
                    drop
                    LOG.ERR log-stream fputs "Procedure '" log-stream fputs proc-name-token-arg proc-name-token-arg mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                    proc-name-token-address log-stream fput-here
                    ERROR-EXIT-CODE exit drop
                    return
                  end

                  let name-address in
                    name-address proc-names-array - let delta in
                      proc-inputs-array delta + proc-outputs-array delta + let input-address output-address in
                        // Shift the array to insert the name, input and output.
                        name-address   name-address   8 + procs-length @64 name-address   proc-names-array   - 8 / - memcpy64i
                        input-address  input-address  8 + procs-length @64 input-address  proc-inputs-array  - 8 / - memcpy64i
                        output-address output-address 8 + procs-length @64 output-address proc-outputs-array - 8 / - memcpy64i

                        // Save the name, inputs and outputs of the procedure.
                        proc-name-token-arg            dcopy8 name-address   !64
                        input-list          list64.copy-array input-address  !64 
                        output-list         list64.copy-array output-address !64

                        procs-length @inc64
                      end
                    end
                  end

                  // Create the stack for the procedure.
                  memory local-stack        sizeof(int) STACK-MAX-ITEMS ** in
                  memory local-stack-length sizeof(int)                    in

                    0 local-stack-length !64

                    // TODO: This system must be changed.
                    0 while dup input-list list64.length < do let i in
                      i input-list list64.array-addr array64.get let type in
                        type TYPE-INT = if
                          create-int local-stack local-stack-length queue64.append
                        else type TYPE-BOOL = if
                          create-bool local-stack local-stack-length queue64.append
                        else
                          LOG.ERR log-stream fputs "Input types for procedure '" log-stream fputs proc-name-token-arg proc-name-token-arg mlength log-stream fputs "' had an unknown type, got '" log-stream fputs type log-stream fputu "'.\n" log-stream fputs
                          log-stream report-bug
                          proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                          ERROR-EXIT-CODE exit drop
                        end end
                      end
                    i end inc end drop

                    source-name source-file output-file
                    line-no char-no
                    data-definitions-list
                    global-names-array global-sizes-array globals-length
                    proc-names-array proc-inputs-array proc-outputs-array procs-length
                    macro-names-array macro-tokens-array macros-length
                    proc-name-token-arg proc-name-token-address
                    local-stack local-stack-length
                    extended-array extended-start extended-end
                    log-stream
                    compile-procedure
                    
                    LOG.INFO log-stream fputs "Procedure '" log-stream fputs proc-name-token-arg proc-name-token-arg mlength log-stream fputs "' requires at least " log-stream fputs log-stream fputu " bytes of allocated local memory.\n" log-stream fputs
                    
                    ".return:\n"                        output-file fputs
                    "    xchg    rsp, [call_ptr]\n"     output-file fputs
                    "    pop     qword [local_ptr]\n"   output-file fputs
                    "    pop     rax\n"                 output-file fputs
                    "    xchg    rsp, [call_ptr]\n"     output-file fputs
                    "    jmp     rax\n"                 output-file fputs

                    // TODO: This system must be changed.
                    memory temp-outputs-length sizeof(int) in
                      output-list list64.length temp-outputs-length !64
                      
                      while local-stack-length @64 isn-zero do
                        local-stack local-stack-length queue64.pop-last let type in
                          temp-outputs-length @64 is-zero if
                            LOG.ERR log-stream fputs "Procedure's stack has " log-stream fputs local-stack-length @64 inc log-stream fputu " items more than what was defined\n" log-stream fputs
                            proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                            ERROR-EXIT-CODE exit drop
                          end
                          
                          output-list list64.array-addr temp-outputs-length queue64.pop-last let check in
                            type @64 check != if
                              LOG.ERR log-stream fputs "Procedure's stack does not match with its return types.\n" log-stream fputs
                              LOG.INFO log-stream fputs "Expected '" log-stream fputs check log-stream fputu "', got '" log-stream fputs type @64 log-stream fputu "'.\n" log-stream fputs
                              proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                              ERROR-EXIT-CODE exit drop
                            end
                          end
                        end
                      end
                      
                      temp-outputs-length @64 isn-zero if
                        LOG.ERR log-stream fputs "Procedure's stack is missing " log-stream fputs temp-outputs-length @64 log-stream fputu " returns.\n" log-stream fputs 
                        proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                        ERROR-EXIT-CODE exit drop
                      end
                    end
                  end end
                end end 
              end
            else
              LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
              token-address log-stream fput-here
              ERROR-EXIT-CODE exit drop
            end end end end
            
          else
            LOG.ERR log-stream fputs "Expected a keyword type, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
            token-address log-stream fput-here
            ERROR-EXIT-CODE exit drop
          end
        end
      end drop drop drop
    end end end end end
    
    source-file fclose drop
    LOG.INFO log-stream fputs "Successfully included '" log-stream fputs source-name source-name mlength log-stream fputs "'.\n" log-stream fputs
  end
end end


proc compile-nasm
  // ptr: source-name ptr: output-name file-desc: log-stream --
  ptr ptr file-desc --
in let source-name output-name log-stream in
  // Remove the output file.
  output-name unlink drop

  // Create the output file.
  output-name 0o777 creat dup isn-pos if
    LOG.ERR log-stream fputs "Could not create output file '" log-stream fputs output-name output-name mlength log-stream fputs "'.\n" log-stream fputs
    ERROR-EXIT-CODE exit drop
  end

  let output-file in
    // Check if the file is opened successfully.
    output-file isn-pos if
      LOG.ERR log-stream fputs "Could not open output file '" log-stream fputs output-name output-name mlength log-stream fputs "'.\n" log-stream fputs
      ERROR-EXIT-CODE exit drop
    end

    "segment .text\n"                                   output-file fputs
    "global _start\n"                                   output-file fputs

    "_start:\n"                                         output-file fputs
    "    mov     qword [call_ptr], call_stack\n"        output-file fputs
    "    add     qword [call_ptr], 0x4000\n"            output-file fputs
    "    mov     qword [local_ptr], local_memory\n"     output-file fputs

    "    xchg    rsp, [call_ptr]\n"                     output-file fputs
    "    push    corth_endofprogram\n"                  output-file fputs
    "    push    qword [local_ptr]\n"                   output-file fputs
    "    xchg    rsp, [call_ptr]\n"                     output-file fputs
    "    jmp     proc_main\n"                           output-file fputs

    "corth_endofprogram:\n"                             output-file fputs
    "    mov     rax, 60\n"                             output-file fputs
    "    pop     rdi\n"                                 output-file fputs
    "    syscall\n"                                     output-file fputs

    memory global-names-array     sizeof(ptr) GLOBALS-MAX-COUNT   ** in
    memory global-sizes-array     sizeof(ptr) GLOBALS-MAX-COUNT   ** in
    memory globals-length         sizeof(int)                        in

    memory proc-names-array       sizeof(ptr) PROCS-MAX-COUNT     ** in
    memory proc-inputs-array      sizeof(ptr) PROCS-MAX-COUNT     ** in
    memory proc-outputs-array     sizeof(ptr) PROCS-MAX-COUNT     ** in
    memory procs-length           sizeof(int)                        in

    memory macro-names-array      sizeof(ptr) MACROS-MAX-COUNT    ** in
    memory macro-tokens-array     sizeof(ptr) MACROS-MAX-COUNT    ** in
    memory macros-length          sizeof(int)                        in

    memory data-definitions-list  sizeof(ptr)                        in

    memory libraries-set          sizeof(ptr)                        in

      0 globals-length   !64
      0 procs-length     !64
      0 macros-length    !64

      16 list64.init let dynamic in
        dynamic is-null if
          LOG.ERR log-stream fputs "Could not create a list dynamic object for data-definitions-list.\n" log-stream fputs
          ERROR-EXIT-CODE exit drop
        end
        dynamic data-definitions-list !64
      end

      16 list64.init let dynamic in
        dynamic is-null if
          LOG.ERR log-stream fputs "Could not create a list dynamic object for libraries-set.\n" log-stream fputs
          ERROR-EXIT-CODE exit drop
        end
        dynamic libraries-set !64
      end

      source-name output-file
      data-definitions-list
      global-names-array global-sizes-array globals-length
      proc-names-array proc-inputs-array proc-outputs-array procs-length
      macro-names-array macro-tokens-array macros-length
      libraries-set
      log-stream
      compile-file

      "segment .data\n" output-file fputs
      0 while dup data-definitions-list list64.length < do let i in
        "    data_" output-file fputs i output-file fputu ": db " output-file fputs
        i data-definitions-list list64.get let data in
          0 while dup data mlength < do let j in
            j data + @8 output-file fputu ", " output-file fputs
          j end inc end drop
        end
        output-file fputnl
      i end inc end drop
    end end end end end end end end end end end end

    "segment .bss\n"                                    output-file fputs
    "    local_memory:   resb 67108864\n"               output-file fputs
    "    local_ptr:      resq 1\n"                      output-file fputs
    "    call_stack:     resb 67108864\n"               output-file fputs
    "    call_ptr:       resq 1\n"                      output-file fputs

    // TODO: Print the global variables to file.

    output-file fclose drop
  end
end end


proc main
  int int -- int
in let argc argv in
  // Initialize malloc.
  malloc.init

  // Initialize debug.
  debug-init

  // Make file name dynamic.
  SOURCE-NAME to-dynamic8 let source-name in
    source-name is-null if
      "'malloc' failed while making the source name dynamic.\n" STDERR fputs
      ERROR-EXIT-CODE exit drop
    end

    OUTPUT-NAME to-dynamic8 null-term8 let output-name in
      output-name is-null if
        "'malloc' failed while making the output name dynamic.\n" STDERR fputs
      end

      source-name output-name STDERR compile-nasm
    end
  end
end SUCCESS-EXIT-CODE end


/*

Name definitions:
  Public:
    Global variables
    Macros
    Procedures

  Private:
    Local variables
    Let variables

Syscall register arguments:
  %rdi %rsi %rdx %r10 %r8 %r9
*/
