include libs/dynamic/debug_malloc.corth
include libs/dynamic/utils.corth
include libs/linux_x86/io/
include libs/core/

macro sizeof(address) 56 endmacro

macro ADDR.FILE  0  endmacro
macro ADDR.START 8  endmacro
macro ADDR.END   32 endmacro

macro POS.LINE   0  endmacro
macro POS.CHAR   8  endmacro
macro POS.AT     16 endmacro

macro LOG.INFO  "\x1b[1;97m[INFO]\x1b[0;97m "    endmacro
macro LOG.WARN  "\x1b[1;33m[WARNING]\x1b[0;97m " endmacro
macro LOG.SOFT  "\x1b[1;31m[SOFT]\x1b[0;97m "    endmacro
macro LOG.ERR   "\x1b[1;31m[ERROR]\x1b[0;97m "   endmacro
macro LOG.BUG   "\x1b[1;31m[BUG]\x1b[0;97m "     endmacro

macro LOG.CMD   "\x1b[1;32m[CMD]\x1b[0;97m "     endmacro
macro LOG.TODO  "\x1b[1;35m[TODO]\x1b[0;97m "    endmacro
macro LOG.HERE  "\x1b[1;32m[HERE]\x1b[0;97m "    endmacro


// This buffer can be used to easily write many spaces at once.
// NOTE: Trying to write more than .-BUFFER-SIZE characters may cause problems.
macro  SPACE-BUFFER-SIZE 256               endmacro
memory space-buffer      SPACE-BUFFER-SIZE end

macro  TILDE-BUFFER-SIZE 256               endmacro
memory tilde-buffer      TILDE-BUFFER-SIZE end


proc debug-init -- in
  // Set up the space-buffer.
  space-buffer SPACE-BUFFER-SIZE ' ' memset8
  
  // Set up the tilde-buffer.
  tilde-buffer TILDE-BUFFER-SIZE '~' memset8
end


// TODO: Add fput-token

proc generate-address
  // ptr: file-name int: start-line int: start-char int: start-at int: end-line int: end-char int: end-at file-sc: log-stream -- ptr: address
  ptr int int int int int int file-desc -- ptr
  // Returns a dynamicly-placed object to store the address of token.
in let log-stream in
  sizeof(address) malloc let address in
    address is-null if
      LOG.ERR log-stream fputs "'malloc' failed while generating address.\n" log-stream fputs
      1 exit drop
    end

    // Store the arguments.
    address ADDR.END   + POS.AT   + !64
    address ADDR.END   + POS.CHAR + !64
    address ADDR.END   + POS.LINE + !64
    address ADDR.START + POS.AT   + !64
    address ADDR.START + POS.CHAR + !64
    address ADDR.START + POS.LINE + !64
    address ADDR.FILE  + !64

    // Return the address.
    address
  end
end end


proc fput-position
  // ptr: position file-desc: file-desc
  ptr file-desc --
  // Prints a position.
in let position file in
  position POS.LINE + @64 file fputu ":" file fputs position POS.CHAR + @64 file fputu " (" file fputs position POS.AT + @64 file fputu ")" file fputs
end end


proc seek-line
  // int: line file-desc: file-desc
  int file-desc --
  // Shifts the file pointer by a specified amount of lines.
in let file in
  memory char 1 in
    while dup isn-zero do
      // If EOF is reached, returns immediately.
      char 1 file fgets is-zero if drop return end

      // If a newline is reached, decrease the counter.
      char @8 '\n' = if dec end
    end drop
  end
end end


proc fput-line
  // file-desc: source file-desc: file-desc -- int: line-length
  file-desc file-desc -- int
  // Keeps printing until a newline is found.
  // Returns the length of line read.
in let source file in
  memory char 1 in
    0 while true do
      // If EOF is reached, return immediately.
      char 1 source fgets is-zero if return end

      // If a newline character is reached, return immediately.
      char @8 '\n' = if return end
      
      // Print the byte to the file stream.
      char 1 file fputs
    inc end
  end
end end


macro fputu-full let _value_ _file_ in
  // int: int file-desc: file-desc

  memory _buffer_ 20 in
    _buffer_ _value_ intconvud let _buffer_start_ in
      ' ' _buffer_ _buffer_start_ _buffer_ - memset8
    end

    _buffer_ 20 _file_ fputs
  end
end endmacro


proc fput-address
  // ptr: address file-desc: log-stream
  ptr file-desc --
  // Prints the formatted address of a token.
in let address log-stream in
  address @64 address ADDR.START + address ADDR.END + let file-name start-pos end-pos in
    "from file '" log-stream fputs file-name dup mlength log-stream fputs "' between [" log-stream fputs start-pos log-stream fput-position "] to [" log-stream fputs end-pos log-stream fput-position "]" log-stream fputs
  end
end end


proc fput-lines
  // ptr: address file-desc: log-stream
  ptr file-desc --
  // Prints the formatted lines of a token.
in let address log-stream in
  address @64 address ADDR.START + address ADDR.END + let file-name start-pos end-pos in
    // Add a null character for fopen
    file-name null-term8 let c-file-name in
      c-file-name fopen-r c-file-name drop
    end

    // Open the source file.
    let file in
      // Check if file could be opened.
      file isn-pos if
        "<file-unavailable>\n" log-stream fputs
      end

      start-pos POS.LINE + @64 start-pos POS.CHAR + @64 end-pos POS.LINE + @64 end-pos POS.CHAR + @64 let start-line start-char end-line end-char in

        // Move the file pointer to the start.
        file 0 SEEK-SET lseek drop start-line dec file seek-line

        start-line end-line = if
          start-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
            "                      " log-stream fputs space-buffer start-char log-stream fputs tilde-buffer end-char start-char - log-stream fputs log-stream fputnl
          end
        else
          start-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
            "                      " log-stream fputs space-buffer start-char log-stream fputs tilde-buffer length start-char - log-stream fputs log-stream fputnl
          end

          start-line inc while dup end-line < do let line-no in
            line-no log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
              "                      " log-stream fputs tilde-buffer length log-stream fputs log-stream fputnl
            end
          line-no end inc end drop

          end-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
            "                      " log-stream fputs tilde-buffer end-char log-stream fputs log-stream fputnl
          end
        end

        // Close the file.
        file fclose drop
      end
    end
  end
end end


macro fput-here let _address_ _log_stream_ in
  // ptr: _address_ file-desc: _log_stream_ --
  LOG.HERE _log_stream_ fputs _address_ _log_stream_ fput-address ":\n" _log_stream_ fputs
  _address_ _log_stream_ fput-lines
end endmacro


macro fput-inside-procedure let _procedure_name_ _procedure_address_ _log_stream_ in
  // ptr: _address_ ptr: _procedure_name_ ptr: _procedure_address_ file-desc: _log_stream_ --
  LOG.INFO _log_stream_ fputs "Inside procedure '" _log_stream_ fputs _procedure_name_ _procedure_name_ mlength _log_stream_ fputs "'.\n" _log_stream_ fputs
  LOG.HERE _log_stream_ fputs _procedure_address_ _log_stream_ fput-address ":\n" _log_stream_ fputs
  _procedure_address_ _log_stream_ fput-lines
end endmacro


proc report-bug
  // file-desc: file-desc --
  file-desc --
in let log-stream in
  LOG.ERR log-stream fputs "This should have been impossible to reach.\n" log-stream fputs
  LOG.INFO log-stream fputs "This is probably caused by a bug in the compiler.\n" log-stream fputs
  LOG.INFO log-stream fputs "Malloc segments: \n" log-stream fputs
  log-stream debug-dynamic-memory
end end
