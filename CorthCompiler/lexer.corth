include CorthCompiler/enums.corth
include CorthCompiler/debug.corth


proc fgets-keep
  // ptr: start int: length file-desc: file-desc
  ptr int file-desc -- int
  // Reads a region of a file stream and returns file pointer to its original position.
in let start length file in
  // Get original position.
  file ftell let original in
  
    // Read bytes and return the total bytes read.
    start length file fgets

    // Return the file pointer to its original pointer.
    file original SEEK-SET lseek drop
  end
end end


proc strip-file
  // file-desc: file ptr: line-no ptr: char-no -- bool: reached-eof
  file-desc ptr ptr -- bool
  // Removes the newline and spaces from the start of a file stream
  // Keeps track the line and char number as the bytes are read.
  // Also, checks if EOF is reached.
in let file line-no char-no in
  memory char 1 in
    while true do
      char 1 file fgets is-zero if
        true return
      else char @8 is-zero if
        true return
      else char @8 CHAR-NEWLINE = if
        0 char-no !64
        line-no @inc64
      else char @8 CHAR-SPACE = if
        char-no @inc64
      else
        file 1 neg SEEK-CUR lseek drop
        false return
      end end end end
    end
  end
end false end  // dummy return


proc parse-next-token
  // file-desc: file-desc ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream --
  file-desc ptr ptr ptr ptr file-desc --
  // Gets the next token string before any newline or space and fills a buffer.
  // Keeps track of the line and char number as the bytes are read.
  // NOTE: If buffer-end exceeds buffer + TOKEN-MAX-LENGTH, exits program.
in let file line-no char-no buffer buffer-end log-stream in
  while true do
    buffer-end @64 1 file fgets-keep is-zero if                // Reached end of file.
      char-no @inc64
      return
    else buffer-end @64 @8 CHAR-NEWLINE = if              // Reached newline.
      char-no @inc64
      return
    else buffer-end @64 @8 CHAR-SPACE = if                // Reached space.
      char-no @inc64
      return
    else buffer-end @64 buffer - TOKEN-MAX-LENGTH >= if   // Reached the end of the buffer.
      LOG.ERR  log-stream fputs "Found a token longer than TOKEN-MAX-LENGTH, stopping execution.\n" log-stream fputs
      LOG.INFO log-stream fputs "Last read token was '" log-stream fputs buffer buffer-end @64 buffer - log-stream fputs "'.\n" log-stream fputs
      ERROR-EXIT-CODE exit drop
    else                                                  // There is still space in the buffer.
      file 1 SEEK-CUR lseek drop
      buffer-end @inc64
      char-no    @inc64
    end end end end
  end
end end


proc parse-next-string
  // file-desc: file-desc ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream --
  file-desc ptr ptr ptr ptr file-desc --
  // Gets the next string before a double quote.
  // Keeps track of the line and char number as the bytes are read.
  // NOTE: If buffer-end exceeds buffer + TOKEN-MAX-LENGTH, exits program.
  // NOTE: If EOF is reached before a double quote is found, exits program.
  // TODO: Add escapes.
in let file line-no char-no buffer buffer-end log-stream in
  while true do
    buffer-end @64 1 file fgets is-zero if                  // Reached end of file.
      LOG.ERR log-stream fputs "Reached EOF before finding any '\"'.\n" log-stream fputs
      ERROR-EXIT-CODE exit drop
    else buffer-end @64 @8 CHAR-DQUOTE = if                 // Reached double quote.
      char-no    @inc64
      return
    else buffer-end @64 buffer - TOKEN-MAX-LENGTH >= if     // Reached the end of the buffer.
      LOG.ERR log-stream fputs "Found a string longer than TOKEN-MAX-LENGTH, stopping execution.\n" log-stream fputs
      LOG.INFO log-stream fputs "Last read token was '" log-stream fputs buffer buffer-end @64 buffer - log-stream fputs "'.\n" log-stream fputs
      ERROR-EXIT-CODE exit drop
    else buffer-end @64 @8 CHAR-NEWLINE = if                // Reached new line.
      buffer-end @inc64
      line-no    @inc64
      0 char-no !64
    else                                                   
      buffer-end @inc64
      char-no    @inc64
    end end end end
  end
end end


proc skip-line
  // file-desc: file-desc ptr: line-no ptr: char-no file-desc: log-stream --
  file-desc ptr ptr file-desc --
  // Moves the file pointer until it passes a newline, or EOF is reached.
  // Keeps track of the line and char number as the bytes are read.
in let file line-no char-no log-stream in
  line-no @inc64
  0 char-no !64
  
  memory char 1 in
    while true do
      char 1 file fgets is-zero if
        return
      else char @8 CHAR-NEWLINE = if
        return
      end end
    end
  end
end end


proc skip-block-comment
  // file-desc: file-desc ptr: line-no ptr: char-np file-desc: log-stream --
  file-desc ptr ptr file-desc -- 
  // Moves the file pointer until it passes a block comment end, or EOF is reached.
  // Keeps track of the line and char number as the bytes are read.
in let file line-no char-no log-stream in
  memory char 1 in
    while true do
      char 1 file fgets is-zero if                          // Reached EOF while expecting a block comment end.
        LOG.WARN log-stream fputs "Reached EOF while expecting a block comment end.\n" log-stream fputs
        return
      end
        
      char @8 CHAR-ASTERISK = if                       // Reached asterisk.
        char 1 file fgets is-zero if                        // Reached EOF while expecting a block comment end.
          LOG.WARN log-stream fputs "Reached EOF while expecting a block comment end.\n" log-stream fputs
          return
        end

        char @8 CHAR-SLASH = if                             // Reached block comment end.
          return
        end
        
      else char @8 CHAR-NEWLINE = if                        // Reached a newline.
        line-no @inc64
        0 char-no !64
        
      else                                                  // Reached any other character
        char-no @inc64
      end end
    end
  end
end end
