/*
  Complex numbers for Corth

Complex numbers are implemented as:

  comp = (fixed: real-part fixed: imag-part)

This number represents the number, C = R + I * i

NOTE: There is no such a thing as 'unsigned complex number', since most results require a negative result already.
NOTE: Unless it is said to be otherwise, all fixed numbers are signed.

*/

include libs/math/fixed64.corth

macro comp fixed64 fixed64 endmacro
macro sizeof(comp) 2 sizeof(fixed64) * endmacro

macro ff-to-comp
  // fixed: R fixed: C -- comp: x
  // This macro does nothing, since the representation does not change
endmacro

proc dup-complex
  // comp: a -- comp: a comp: a'
  comp -- comp comp
in
  dupd
end

proc swp-complex
  // comp: a comp:b -- comp: b comp: a
  comp comp -- comp comp
in
  swpd
end

macro load-complex
  // int:*address
  dup load8 swp 8 + load8
endmacro

macro store-complex
  // int:*address comp: x
  rot dup 8 + rot store8 swp store8
endmacro

// COMPLEX -- FIXED macro and procedures
macro length-c
  // comp: x -- fixed64: length(x)
  // NOTE: length is unsigned fixed

  sqr-f swp sqr-f add-ff
endmacro


// COMPLEX -- COMPLEX macro and procedures
macro neg-c
  // comp: x -- comp: -x
  neg
endmacro

macro inv-c
  // comp: x -- comp: 1/x
  // NOTE: Even though length-c returns unsigned fixed, it is used like it is signed. Because of that, it may return a wrong result for very big complex numbers
  dup-complex conj-c
  swp-complex length-c div-cf
endmacro

macro conj-c
  // comp: x -- comp: conj(x)
  // Conjugate of a complex number a + bi is a - bi
  neg
endmacro

proc sqr-c
  // comp: x -- comp: x^2
  comp -- comp
in
  let xr xi in
    // Real part
    xr sqr-f
    xi sqr-f -

    // Imaginary part
    xr xi mul-ff 2 mul-fi
  end
end


// COMPLEX COMPLEX -- COMPLEX macro and procedures
macro add-cc
  // comp: a comp: b -- comp: a+b
  rot + rot rot + swp
endmacro

macro sub-cc
  // comp: a comp: b -- comp: a-b
  rot - neg rot rot - swp
endmacro

proc mul-cc
  // comp: a comp: b -- comp: a*b
  comp comp -- comp
in
  let ar ai br bi in
    // Real part
    // (ar * br - ai * bi)
    ar br mul-ff
    ai bi mul-ff sub-ff

    // Imaginary part
    // (ar * bi + ai * br)
    ar bi mul-ff
    ai br mul-ff add-ff
  end
end

macro div-cc
  // comp: a comp: b -- comp: a/b
  // a / b = a * (1/b) = mul-cc(a, inv-c(b))
  inv-c mul-cc
endmacro


// COMPLEX FIXED -- COMPLEX macro and procedures
// NOTE: fixed argument is used as a real number
macro add-cf
  // comp: a fixed64: b -- comp: a+b
  rot add-ff swp
endmacro

macro sub-cf
  // comp: a fixed64: b -- comp: a-b
  rot sub-ff swp
endmacro

macro mul-cf
  // comp: a fixed64: b -- comp: a*b
  dup rot mul-ff rot rot mul-ff swp
endmacro

macro div-cf
  // comp: a fixed64: b -- comp: a*b
  dup rot swp div-ff rot rot div-ff swp
endmacro


// This macro uses the putu, putu-plus and puts from the io.corth library
// Because of that, to use this macro, io.corth should already be included or putu, putu-plus and puts should be defined
macro put-complex
  // comp: x

  // Real part
  swp put-fixed

  // Imaginary part
  dup 0 < if
    " - " puts neg
  else
    " + " puts
  end
  
  put-fixed "i" puts
endmacro
