/*
  Complex numbers for Corth

Complex numbers are implemented as:

  comp = (fixed: real-part fixed: imag-part)

This number represents the number, C = R + I * i

NOTE: There is no such a thing as 'unsigned complex number', since most results require a negative result already.
NOTE: Unless it is said to be otherwise, all fixed numbers are signed.

*/

include libs/math/fixed_point.corth

macro comp fixed fixed endmacro
macro sizeof(comp) 2 sizeof(fixed) * endmacro

macro load-comp-arg
  // comp: x
  // This macro is used to quickly load a complex number to variables
  // This macro should not be used inside macros
  
  memory xr sizeof(fixed) end
  memory xi sizeof(fixed) end

  xi swp store8
  xr swp store8
endmacro

macro load-2-comp-args
  // comp: a comp: b
  // This macro is used to quickly load two complex numbers to variables
  // This macro should not be used inside macros
  
  memory ar sizeof(fixed) end
  memory ai sizeof(fixed) end
  memory br sizeof(fixed) end
  memory bi sizeof(fixed) end

  bi swp store8
  br swp store8
  ai swp store8
  ar swp store8
endmacro

macro ff-to-comp
  // fixed: R fixed: C -- comp: x
  // This macro does nothing, since the representation does not change
endmacro

proc dup-complex
  // comp: a -- comp: a comp: a'
  comp -- comp comp
in
  load-comp-arg

  xr load8 xi load8
  xr load8 xi load8
end

proc swp-complex
  // comp: a comp:b -- comp: b comp: a
  comp comp -- comp comp
in
  load-2-comp-args

  br load8 bi load8
  ar load8 ai load8
end

macro load-complex
  // int:*address
  dup load8 swp 8 + load8
endmacro

macro store-complex
  // int:*address comp: x
  rot dup 8 + rot store8 swp store8
endmacro

// COMPLEX -- FIXED macro and procedures
macro length-c
  // comp: x -- fixed: length(x)
  // NOTE: length is unsigned fixed

  sqr-f swp sqr-f add-ff
endmacro


// COMPLEX -- COMPLEX macro and procedures
macro neg-c
  // comp: x -- comp: -x
  neg
endmacro

macro inv-c
  // comp: x -- comp: 1/x
  // NOTE: Even though length-c returns unsigned fixed, it is used like it is signed. Because of that, it may return a wrong result for very big complex numbers
  dup-complex conj-c
  swp-complex length-c div-cf
endmacro

macro conj-c
  // comp: x -- comp: conj(x)
  // Conjugate of a complex number a + bi is a - bi
  neg
endmacro

proc sqr-c
  // comp: x -- comp: x^2
  comp -- comp
in
  load-comp-arg

  // Real part
  xr load8 sqr-f
  xi load8 sqr-f -

  // Imaginary part
  xr load8 xi load8 mul-ff 2 mul-fi
end


// COMPLEX COMPLEX -- COMPLEX macro and procedures
macro add-cc
  // comp: a comp: b -- comp: a+b
  rot + rot rot + swp
endmacro

macro sub-cc
  // comp: a comp: b -- comp: a-b
  rot - neg rot rot - swp
endmacro

proc mul-cc
  // comp: a comp: b -- comp: a*b
  comp comp -- comp
in
  load-2-comp-args

  // Real part
  // (ar * br - ai * bi)
  ar load8 br load8 mul-ff
  ai load8 bi load8 mul-ff sub-ff

  // Imaginary part
  // (ar * bi + ai * br)
  ar load8 bi load8 mul-ff
  ai load8 br load8 mul-ff add-ff
end

macro div-cc
  // comp: a comp: b -- comp: a/b
  // a / b = a * (1/b) = mul-cc(a, inv-c(b))
  inv-c mul-cc
endmacro


// COMPLEX FIXED -- COMPLEX macro and procedures
// NOTE: fixed argument is used as a real number
macro add-cf
  // comp: a fixed: b -- comp: a+b
  rot add-ff swp
endmacro

macro sub-cf
  // comp: a fixed: b -- comp: a-b
  rot sub-ff swp
endmacro

macro mul-cf
  // comp: a fixed: b -- comp: a*b
  dup rot mul-ff rot rot mul-ff swp
endmacro

macro div-cf
  // comp: a fixed: b -- comp: a*b
  dup rot swp div-ff rot rot div-ff swp
endmacro


// This macro uses the putu, putu-plus and puts from the io.corth library
// Because of that, to use this macro, io.corth should already be included or putu, putu-plus and puts should be defined
macro put-complex
  // comp: x

  // Real part
  swp put-fixed

  // Imaginary part
  dup 0 < if
    " - " puts neg
  else
    " + " puts
  end
  
  put-fixed "i" puts
endmacro
