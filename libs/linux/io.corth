// io.corth

include libs/core.corth
include libs/sys.corth
include libs/memory.corth


//    ================
//    ==== Output ====
//    ================


// == Strings ==
macro fputs
  // file-dc str-ptr str-len

  SYSWRITE syscall3 drop
endmacro

macro puts
  // str-ptr str-len

  STDOUT rot rot fputs
endmacro

macro eputs
  // str-ptr str-len

  STDERR rot rot fputs
endmacro


// == C-like strings ==
macro fputsc
  // file-dc str-ptr

  while
    dup load 0 !=
  do
    dup rot dup rot 1 fputs swp
    inc
  end

  drop drop
endmacro

macro putsc
  // str-ptr

  STDOUT swp fputsc
endmacro

macro eputsc
  // str-ptr
  
  STDERR swp fputsc
endmacro


// == Unsigned decimals ==
proc fputu
  // int: file-dc int: int
  int int --
in
  memory buffer 20 sizeof(char) * in
  
  buffer 20 +

  while
  swp 10 /% '0' +
  rot
  dec dup
  rot
  store
  swp dup
  rot swp
  0 !=
  do end

  dup buffer
  swp - 20 +
  fputs drop

  end
end

macro putu
  STDOUT swp fputu
endmacro

macro eputu
  STDERR swp fputu
endmacro


// == Signed decimals ==
macro fputi
  // int: file-dc int: int

  dup 0x7fffffffffffffff > if
    neg swp dup "-" fputs swp fputu
  else
    fputu
  end
endmacro

macro puti
  STDOUT swp fputi
endmacro

macro eputi
  STDERR swp fputi
endmacro


// == Hexadecimals ==
macro get-hex-digit
  // int: int -- int: char
  // Returns the char number for a hexadecimal digit
  // 0 -> '0', 1 -> '1' ... 9 -> '9', 10 -> 'a', 11 -> 'b' ... 15 -> 'f'
  // Argument should be between 0 and 15 (including)
  dup 9 > if 'W' else '0' end +
endmacro

proc fputx
  // int: file-dc int: int
  int int --
in
  swp
  
  let file-dc in
    memory char sizeof(char) in
      16 while dup 0 > do
        swp

	// Save the char
	dup 0xf000000000000000 && 0x1000000000000000 / get-hex-digit char swp store

	// Print the char
	file-dc char 1 fputs

	// Shift the number
	<<4

        swp dec
      end drop drop
    end
  end
end

macro putx
  // int: int
  STDOUT swp fputx
endmacro

macro eputx
  // int: int
  STDERR swp fputx
endmacro


// == Unsigned decimals (plus) ==
// The starting characters are always visible and the ending zeros are removed
// Also, does not print the first character if it is not 0
// Used in fixed_numbers.put-fixed
proc fputu-plus
  // int: file-dc int: int
  int int --
in
  dup 0 = if
  drop "0" fputs
  
  else
    memory value sizeof(int) and
	 end-of-buffer sizeof(int) and
	 buffer 20 sizeof(char) * in
      value swp store8

      let file-dc in
	buffer 20 +

	while dec value load8 10 % 0 = do
	  value dup load8 10 / store8
	end

	dup end-of-buffer swp store8

	while dup buffer >= do
	  dup value load8 10 /% rot swp '0' + store
	  value swp store8
	  dec
	end drop

	file-dc buffer inc end-of-buffer load8 buffer - fputs
      end
    end
  end
end

macro putu-plus
  // int: int
  STDOUT swp fputu-plus
endmacro

macro eputu-plus
  // int: int
  STDERR swp fputu-plus
endmacro


//  ===============
//  ==== Input ====
//  ===============

// == Strings ==
macro fgets
  // file-dc str-ptr str-len -- read
  
  SYSREAD syscall3
endmacro

macro gets
  // str-ptr str-len
  
  STDIN rot rot fgets
endmacro


// == Lines ==
// This algorithm is unsafe and should not be used
macro fgetl
  // file-dc str-ptr -- str-len
  dup rot swp

  while
  swp dup rot dup rot swp
  1 fgets
  dup load dup

  '\n' !=
  do
  dup 0 = if
    break
  end

  drop
  
  inc
  end
  
  drop

  dup 0 store

  rot - swp

  drop
endmacro

macro getl
  // str-ptr -- str-len
  STDIN swp fgetl
endmacro
