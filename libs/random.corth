include libs/core.corth

memory rng-seed sizeof(int) end

macro rand64
  // -- int: next
  // The result integer is in the range [0, 2^64) with the step size of 1
  
  // -- fixed64: next
  // The result fixed64 is in the range [0, 2^32) with the step size of 2^-32
  rng-seed @64
  18446744073709551557 u** + 23 +
  let x in
    x 0x400000000000 u/ x 0x20000 u/ u* x 2 / ^^ dup rng-seed !64
  end 
endmacro

// If precompilation gets added to the compiler, this procedure will lose its meaning and rand-unif-range will be as efficient as this function
// But until that day, this function will be more efficient for ranges of [0, b)
macro rand-unif
  // int: x -- int: uniform(x)
  // Returns a number in the range [0, x) with the step size of 1
  
  // fixed64: x -- fixed64: uniform(x)
  // Returns a number in the range [0, x) with the step size of 2^-32
  
  // uniform(x) = rand64 % x
  let _b_ in
    rand64 _b_ %
  end
endmacro

macro rand-unif-range
  // int: a int: b -- int: uniform-range(a, b)
  // Returns a number in the range [a, b) with the step size of 1

  // fixed64: a fixed64: b -- fixed64: uniform(a, b)
  // Returns a number in the range [a, b) with the step size of 2^-32
  
  // uniform-range(a, b) = a + uniform(b - a)
  let _b_ _c_ in
    rand64 _c_ _b_ - % _b_ +
  end
endmacro
