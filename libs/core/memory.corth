include libs/core/arithmetic.corth


macro ptr int endmacro


macro sizeof(ptr)  8 endmacro
macro sizeof(bool) 8 endmacro
macro sizeof(char) 1 endmacro


// TODO: This should be changed to ptr type, when 'ptr' type is implemented for real.
macro NULLPTR 0 endmacro


// ptr: x -- bool: f(x)
macro is-null  NULLPTR =  endmacro
macro isn-null NULLPTR != endmacro


proc memcmp8
  // ptr: a-start int: a-length ptr: b-start int: b-length -- bool: cmp(a, b)
  ptr int ptr int -- int
  // Returns -1 if a<b.
  // Returns  0 if a=b.
  // Returns +1 if a>b.
in let a-start a-length b-start b-length in
  a-length b-length min2 let compare-length in
    0 while dup compare-length < do let item-addr in
      // Get a[i] and b[i].
      a-start item-addr + @8 b-start item-addr + @8 let a-item b-item in
        // If a[i]<b[i], return -1.
        a-item b-item < if 0xffffffffffffffff return end

        // If a[i]>b[i], return 1.
        b-item a-item < if 1 return end
      end
    item-addr end inc end drop
  end

  // Compare the lengths.
  a-length b-length cmp
end end

proc memcmp64
  // ptr: a-start int: a-length ptr: b-start int: b-length -- bool: cmp(a, b)
  ptr int ptr int -- int
  // Returns -1 if a<b.
  // Returns  0 if a=b.
  // Returns +1 if a>b.
in let a-start a-length b-start b-length in
  a-length b-length min2 8 * let compare-length in
    0 while dup compare-length < do let item-addr in
      // Get a[i] and b[i].
      a-start item-addr + @64 b-start item-addr + @64 let a-item b-item in
        // If a[i]<b[i], return -1.
        a-item b-item < if 0xffffffffffffffff return end

        // If a[i]>b[i], return 1.
        b-item a-item < if 1 return end
      end
    item-addr end 8 + end drop
  end

  // Compare the lengths.
  a-length b-length cmp
end end


macro memlt8  memcmp8  is-neg  endmacro
macro memeq8  memcmp8  is-zero endmacro
macro memgt8  memcmp8  is-pos  endmacro

macro memlt64 memcmp64 is-neg  endmacro
macro memeq64 memcmp64 is-zero endmacro
macro memgt64 memcmp64 is-pos  endmacro


proc memset8
  // ptr: start int: length int: value
  ptr int int --
  // Sets every item in a collection to a value.
in let start length value in
  start length +
  let finish in
    start while dup finish < do
      let i in
        value i !8
      i end
    inc end drop
  end
end end


proc memset64
  // ptr: start int: length int: value
  ptr int int --
  // Sets every item in a collection to a value.
in let start length value in
  start length 8 * +
  let finish in
    start while dup finish < do
      let i in
        value i !64
      i end
    8 + end drop
  end
end end


// Decreases a value in the memory. (*-- operator)
macro @dec8  let _a_ in _a_ @8  dec _a_ !8  end endmacro // ptr: x
macro @dec64 let _a_ in _a_ @64 dec _a_ !64 end endmacro // ptr: x


// Increases a value in the memory. (*++ operator)
macro @inc8  let _a_ in _a_ @8  inc _a_ !8  end endmacro // ptr: x
macro @inc64 let _a_ in _a_ @64 inc _a_ !64 end endmacro // ptr: x


macro @swp8
  // ptr: a ptr: b
  // Swaps two bytes in the memory.
  // *a, *b = *b, *a
  let _a_ _b_ in
    _a_ @8 _b_ @8 _a_ !8 _b_ !8
  end
endmacro


macro @swp64
  // ptr: a ptr: b
  // Swaps two 8-byte values in the memory.
  // *a, *b = *b, *a
  let _a_ _b_ in
    _a_ @64 _b_ @64 _a_ !64 _b_ !64
  end
endmacro


proc memcpy8
  // ptr: src ptr: dst int: len 
  // Copies a part of memory to another location.
  // Bytes are read one-by-one.
  ptr ptr int --
in
  let src dst len in
    0 while dup len < do let i in
      src i + @8 
      dst i + !8
    i end inc end drop
  end
end


// memcpy64 only works a bit faster, no other functionality is changed.
// If the length is known to be divisible by 8, it is recommended to use memcpy64.
proc memcpy64
  // ptr: src ptr: dst int: len
  // Copies a part of memory to another location.
  // Bytes are read 8-by-8.
  ptr ptr int --
in
  let src dst len in
    0 while dup len 8 * < do let i in
      src i + @64
      dst i + !64
    i end 8 + end drop
  end
end


proc memcpy8i
  // ptr: src ptr: dst int: len
  // Copies a part of memory to another location.
  // Bytes are read one-by-one.
  // The copying is done in reverse order, aka from last item to first item.
  ptr ptr int --
in
  let src dst len in
    len while dup isn-zero do dec let i in
      src i + @8
      dst i + !8
    i end end drop
  end
end


proc memcpy64i
  // ptr: src ptr: dst int: len
  // Copies a part of memory to another location.
  // Bytes are read 8-by-8.
  // The copying is done in reverse order, aka from last item to first item.
  ptr ptr int --
in
  let src dst len in
    len 8 * while dup isn-zero do 8 - let i in
      src i + @64
      dst i + !64
    i end end drop
  end
end


proc memswp8
  // ptr: a ptr: b int: len
  // Swaps two regions of memory.
  // Swaps one byte per iteration.
  ptr ptr int --
in
  let a b len in
    0 while dup len < do let i in
      a i + b i + @swp8
    i end inc end drop
  end
end


// memswp64 only works a bit faster, no other functionality is changed.
// If the length is known to be divisible by 8, it is recommended to use memswp64.
proc memswp64
  // ptr: a ptr: b int: len
  // Swaps two regions of memory.
  // Swaps 8 bytes per iteration.
  ptr ptr int --
in
  let a b len in
    0 while dup len 8 * < do let i in
      a i + b i + @swp64
    i end 8 + end drop
  end
end
