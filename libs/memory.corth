include libs/core.corth

// This should be changed to ptr type, when ptr type is implemented for real.
// (Probably never :( )
macro NULLPTR 0 endmacro

proc memeq8
  // ptr: a-start int: a-length ptr: b-start int: b-length -- bool: a==b
  ptr int ptr int -- bool
  // Compares two staticly-placed collections.
  // Result is true if and only if for every integer i in [0, len(a)), a[i] == b[i].
in let a-start a-length b-start b-length in
  a-length b-length != if
    false return
  end

  0 while dup a-length < do let i in
    a-start i + @8 b-start i + @8 let ai bi in
      ai bi != if
        false return
      end
    end
  i end inc end drop
end true end

proc memeq64
  // ptr: a-start int: a-length ptr: b-start int: b-length -- bool: a==b
  ptr int ptr int -- bool
  // Compares two staticly-placed collections.
  // Result is true if and only if for every integer i in [0, len(a)), a[i] == b[i].
in let a-start a-length b-start b-length in
  a-length b-length != if
    false return
  end

  0 while dup a-length < do let i in
    a-start i 8 * + @64 b-start i 8 * + @64 let ai bi in
      ai bi != if
        false return
      end
    end
  i end inc end drop
end true end

proc memlt8
  // ptr: a-start int: a-length ptr: b-start int: b-length -- bool: a==b
  ptr int ptr int -- bool
  // Compares two staticly-placed collections.  
  // Result is true if and only if there is an integer i in [0, len(a) - 1), a[i] < b[i] and for every integer j in [0, i), a[i] == b[i].
in let a-start a-length b-start b-length in
  0 while dup a-length < do let i in
    a-start i + @8 b-start i + @8 let ai bi in
      ai bi > if
        false return
      else ai bi < if
        true return
      end end
    end
  i end inc end drop
end false end

proc memlt64
  // ptr: a-start int: a-length ptr: b-start int: b-length -- bool: a==b
  ptr int ptr int -- bool
  // Compares two staticly-placed collections.  
  // Result is true if and only if there is an integer i in [0, len(a) - 1), a[i] < b[i] and for every integer j in [0, i), a[i] == b[i].
in let a-start a-length b-start b-length in
  0 while dup a-length < do let i in
    a-start i 8 * + @64 b-start i 8 * + @64 let ai bi in
      ai bi > if
        false return
      else ai bi < if
        true return
      end end
    end
  i end inc end drop
end false end

proc memset8
  // ptr: start int: length int: value
  ptr int int --
  // Sets every item in a collection to a value.
in let start length value in
  start length +
  let finish in
    start while dup finish < do
      let i in
        value i !8
      i end
    inc end drop
  end
end end

proc memset64
  // ptr: start int: length int: value
  ptr int int --
  // Sets every item in a collection to a value.
in let start length value in
  start length 8 * +
  let finish in
    start while dup finish < do
      let i in
        value i !64
      i end
    8 + end drop
  end
end end

// Decreases a value in the memory (*-- operator)
macro @dec8  let _a_ in _a_ @8  dec _a_ !8  end endmacro // ptr: x
macro @dec64 let _a_ in _a_ @64 dec _a_ !64 end endmacro // ptr: x

// Increases a value in the memory (*++ operator)
macro @inc8  let _a_ in _a_ @8  inc _a_ !8  end endmacro // ptr: x
macro @inc64 let _a_ in _a_ @64 inc _a_ !64 end endmacro // ptr: x

macro @swp8
  // ptr: a ptr: b
  // Swaps two bytes in the memory
  // *a, *b = *b, *a
  let _a_ _b_ in
    _a_ @8 _b_ @8 _a_ !8 _b_ !8
  end
endmacro

macro @swp64
  // ptr: a ptr: b
  // Swaps two 8-byte values in the memory
  // *a, *b = *b, *a
  let _a_ _b_ in
    _a_ @64 _b_ @64 _a_ !64 _b_ !64
  end
endmacro

proc memcpy8
  // ptr: src ptr: dst int: len 
  // Copies a part of memory to another location
  // Bytes are read one-by-one
  ptr ptr int --
in
  let src dst len in
    0 while dup len < do
      let i in
        src i + @8 
        dst i + !8
      i end
    inc end drop
  end
end

// memcpy64 only works a bit faster, no other functionality is changed
// If the length is known to be divisible by 8, it is recommended to use memcpy64
proc memcpy64
  // ptr: src ptr: dst int: len
  // Copies a part of memory to another location
  // Bytes are read 8-by-8
  ptr ptr int --
in
  let src dst len in
    0 while dup len < do
      let i in
        src i 8 * + @64
        dst i 8 * + !64
      i end
    inc end drop
  end
end

proc memcpy8i
  // ptr: src ptr: dst int: len
  // Copies a part of memory to another location
  // Bytes are read one-by-one
  // The copying is done in reverse order, aka from last item to first item
  ptr ptr int --
in
  let src dst len in
    len while dup isn-zero do dec let i in
      src i + @8
      dst i + !8
    i end end drop
  end
end

proc memcpy64i
  // ptr: src ptr: dst int: len
  // Copies a part of memory to another location
  // Bytes are read 8-by-8
  // The copying is done in reverse order, aka from last item to first item
  ptr ptr int --
in
  let src dst len in
    len while dup isn-zero do dec let i in
      src i 8 * + @64
      dst i 8 * + !64
    i end end drop
  end
end

proc memswp8
  // ptr: a ptr: b int: len
  // Swaps two regions of memory
  // Swaps one byte per iteration
  ptr ptr int --
in
  let a b len in
    0 while dup len < do
      let i in
        a i + b i + @swp8
      i end
    inc end drop
  end
end

// memswp64 only works a bit faster, no other functionality is changed
// If the length is known to be divisible by 8, it is recommended to use memswp64
proc memswp64
  // ptr: a ptr: b int: len
  // Swaps two regions of memory
  // Swaps 8 bytes per iteration
  ptr ptr int --
in
  let a b len in
    0 while dup len < do
      let i in
        a i + b i + @swp64
      i end
    8 + end drop
  end
end
