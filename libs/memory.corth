include libs/core.corth

// This should be changed to ptr type, when ptr type is implemented for real.
// (Probably never :( )
macro NULLPTR 0 endmacro

macro get
  // ptr: src   int: index
  // int: index ptr: src

  + @8
endmacro

macro set
  // ptr: src   int: index int: value
  // int: index ptr: src   int: value

  arot + !8
endmacro

macro get8
  // ptr: src   int: index
  // int: index ptr: src

  + @64
endmacro

macro set8
  // ptr: src   int: index int: value
  // int: index ptr: src   int: value

  arot + !64
endmacro

proc memset8
  // ptr: dst int: len int: val
  // Sets every byte to a certain value between a range in memory
  ptr int int --
in
  let dst len val in
    dst len +
    let fin in
      dst while dup fin < do
        let i in
          val i !8
        i end
      inc end drop
    end
  end
end

proc memset64
  // ptr: dst int: len int: val
  // Sets every 8-bytes to a certain value between a range in memory
  ptr int int --
in
  let dst len val in
    dst len 8 * +
    let fin in
      dst while dup fin < do
        let i in
          val i !64
        i end
      8 + end drop
    end
  end
end

macro @dec8
  // ptr: x
  // Decreases a byte in the memory
  // *x--
  let _a_ in
    _a_ @8 dec _a_ !8
  end
endmacro

macro @dec64
  // ptr: x
  // Decreases an 8-byte value in the memory
  // *x--
  let _a_ in
    _a_ @64 dec _a_ !64
  end
endmacro

macro @inc8
  // ptr: x
  // Increases a byte in the memory
  // *x++
  let _a_ in
    _a_ @8 inc _a_ !8
  end
endmacro

macro @inc64
  // ptr: x
  // Increases an 8-byte value in the memory
  // *x++
  let _a_ in
    _a_ @64 inc _a_ !64
  end
endmacro

macro @swp8
  // ptr: a ptr: b
  // Swaps two bytes in the memory
  // *a, *b = *b, *a
  let _a_ _b_ in
    _a_ @8 _b_ @8 _a_ !8 _b_ !8
  end
endmacro

macro @swp64
  // ptr: a ptr: b
  // Swaps two 8-byte values in the memory
  // *a, *b = *b, *a
  let _a_ _b_ in
    _a_ @64 _b_ @64 _a_ !64 _b_ !64
  end
endmacro

proc memcpy8
  // ptr: src ptr: dst int: len 
  // Copies a part of memory to another location
  // Bytes are read one-by-one
  ptr ptr int --
in
  let src dst len in
    0 while dup len < do
      let i in
        src i + @8 
        dst i + !8
      i end
    inc end drop
  end
end

// memcpy64 only works a bit faster, no other functionality is changed
// If the length is known to be divisible by 8, it is recommended to use memcpy64
proc memcpy64
  // ptr: src ptr: dst int: len
  // Copies a part of memory to another location
  // Bytes are read 8-by-8
  ptr ptr int --
in
  let src dst len in
    0 while dup len < do
      let i in
        src i 8 * + @64
        dst i 8 * + !64
      i end
    8 + end drop
  end
end

proc memcpy8i
  // ptr: src ptr: dst int: len
  // Copies a part of memory to another location
  // Bytes are read one-by-one
  // The copying is done in reverse order, aka from last item to first item
  ptr ptr int --
in
  let src dst len in
    len while dup isn-zero do dec let i in
      src i + @8
      dst i + !8
    i end end drop
  end
end

proc memcpy64i
  // ptr: src ptr: dst int: len
  // Copies a part of memory to another location
  // Bytes are read 8-by-8
  // The copying is done in reverse order, aka from last item to first item
  ptr ptr int --
in
  let src dst len in
    len while dup isn-zero do dec let i in
      src i 8 * + @64
      dst i 8 * + !64
    i end end drop
  end
end

proc memswp8
  // ptr: a ptr: b int: len
  // Swaps two regions of memory
  // Swaps one byte per iteration
  ptr ptr int --
in
  let a b len in
    0 while dup len < do
      let i in
        a i + b i + @swp8
      i end
    inc end drop
  end
end

// memswp64 only works a bit faster, no other functionality is changed
// If the length is known to be divisible by 8, it is recommended to use memswp64
proc memswp64
  // ptr: a ptr: b int: len
  // Swaps two regions of memory
  // Swaps 8 bytes per iteration
  ptr ptr int --
in
  let a b len in
    0 while dup len < do
      let i in
        a i + b i + @swp64
      i end
    8 + end drop
  end
end
