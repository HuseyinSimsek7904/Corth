// io.corth

include libs/sys.corth
include libs/memory.corth


//    =======================
//    == Output procedures ==
//    =======================

// == Strings ==
proc fputs
    // file-dc str-ptr str-len
    int int int returns
in
    SYSWRITE syscall3 drop
end

proc puts
    // str-ptr str-len
    int int returns    
in
    STDOUT rot rot fputs
end

proc eputs
    // str-ptr str-len
    int int returns
in
    STDERR rot rot fputs
end


// == C-like strings ==
proc fputsc
     // file-dc str-ptr
     int int returns
in
     while
         dup load 0 !=
     do
         dup rot dup rot 1 fputs swp
         inc
     end
     
     drop drop
end

proc putsc
    // str-ptr
    int returns
in
    STDOUT swp fputsc
end

proc eputsc
    // str-ptr
    int returns
in
    STDERR swp fputsc
end

// == Unsigned decimals ==
memory putu.buffer 32

proc fputu
    // file-dc int
    int int returns
in
    putu.buffer 32 +

    while
        swp 10 /% '0' +
        rot
        dec dup
        rot
        store
        swp dup
        rot swp
        0 !=
    do end

    dup putu.buffer
    swp - 32 +
    fputs drop
end

proc putu
    int returns
in
    STDOUT swp fputu
end

proc eputu
    int returns
in
    STDERR swp fputu
end


// == Binary numbers ==
// There is a faster algorithm, but it requires bitwise-AND

proc fputb
    // file-dc int
    int int returns
in
    putu.buffer 32 +

    while
        swp 2 /% '0' +
        rot
        dec dup
        rot
        store
        swp dup
        rot swp
        0 !=
    do end

    dup putu.buffer
    swp - 32 +
    fputs drop
end

proc putb
    int returns
in
    STDOUT swp fputb
end

proc eputb
    int returns
in
    STDERR swp fputb
end


// == Octal numbers ==

proc fputo
    // file-dc int
    int int returns
in
    putu.buffer 32 +

    while
        swp 8 /% '0' +
        rot
        dec dup
        rot
        store
        swp dup
        rot swp
        0 !=
    do end

    dup putu.buffer
    swp - 32 +
    fputs drop
end

proc puto
    int returns
in
    STDOUT swp fputo
end

proc eputo
    int returns
in
    STDERR swp fputo
end


// == Hexadecimal numbers ==

proc fputx
    // file-dc int
    int int returns
in
    putu.buffer 32 +

    while
        swp 16 /% dup

        // If the number is less then 10, starts from '0'. Otherwise, starts from '7', which added 10 is 'A'.
        10 < if '0' else '7' end +
        
        rot dec dup rot store swp dup rot swp 0 !=
    do end

    dup putu.buffer
    swp - 32 +
    fputs drop
end

proc putx
    int returns
in
    STDOUT swp fputx
end

proc eputx
    int returns
in
    STDERR swp fputx
end

//    ==========================
//    ==== Input procedures ====
//    ==========================

// == Strings ==
proc fgets
    // file-dc str-ptr str-len
    int int int returns
in
    SYSREAD syscall3 drop
end

proc gets
    // str-ptr str-len
    int int returns
in
    STDIN rot rot fgets
end


// == Lines ==
// This algorithm is unsafe and should not be used
proc fgetl
    // file-dc str-ptr -- str-len
    int int returns int
in
    // fd st -> st fd st+0
    dup rot swp

    while
        // st fd (st+l) -> st fd (st+l) fd (st+l)
        swp dup rot dup rot swp

        1 fgets
        // st fd (st+l)

        dup load dup
        // st fd (st+l) ch ch
       
        '\n' !=
        // st fd (st+l) ch bool
    do
        dup 0 = if
	    break
	end

        drop
        
        // st fd (st+l)
        inc
        // st fd (st+l+1)
    end
    
    drop

    // st fd (st+n) -> st fd (st+n) (st+n) 0
    dup 0 store

    // st fd (st+n) -> n fd
    rot - swp

    drop
end

proc getl
    // str-ptr -- str-len
    int returns int
in
    STDIN swp fgetl
end
