// io.corth

include libs/sys.corth
include libs/memory.corth


//    =======================
//    ==== Output macros ====
//    =======================


// == Strings ==
macro fputs
    // file-dc str-ptr str-len
    
    SYSWRITE syscall3 drop
endmacro

macro puts
    // str-ptr str-len
    
    STDOUT rot rot fputs
endmacro

macro eputs
    // str-ptr str-len
    
    STDERR rot rot fputs
endmacro


// == C-like strings ==
macro fputsc
     // file-dc str-ptr
     
     while
         dup load 0 !=
     do
         dup rot dup rot 1 fputs swp
         inc
     end
     
     drop drop
endmacro

macro putsc
    // str-ptr
    
    STDOUT swp fputsc
endmacro

macro eputsc
    // str-ptr
    
    STDERR swp fputsc
endmacro

// == Unsigned decimals ==
memory putu.buffer 32 end

macro fputu
    // file-dc int
    
    putu.buffer 32 +

    while
        swp 10 /% '0' +
        rot
        dec dup
        rot
        store
        swp dup
        rot swp
        0 !=
    do end

    dup putu.buffer
    swp - 32 +
    fputs drop
endmacro

macro putu
    STDOUT swp fputu
endmacro

macro eputu
    STDERR swp fputu
endmacro


// == Binary numbers ==
// There is a faster algorithm, but it requires bitwise-AND

macro fputb
    // file-dc int
    putu.buffer 32 +

    while
        swp 2 /% '0' +
        rot
        dec dup
        rot
        store
        swp dup
        rot swp
        0 !=
    do end

    dup putu.buffer
    swp - 32 +
    fputs drop
endmacro

macro putb
    STDOUT swp fputb
endmacro

macro eputb
    STDERR swp fputb
endmacro


// == Octal numbers ==

macro fputo
    // file-dc int
    
    putu.buffer 32 +

    while
        swp 8 /% '0' +
        rot
        dec dup
        rot
        store
        swp dup
        rot swp
        0 !=
    do end

    dup putu.buffer
    swp - 32 +
    fputs drop
endmacro

macro puto
    STDOUT swp fputo
endmacro

macro eputo
    STDERR swp fputo
endmacro


// == Hexadecimal numbers ==

macro fputx
    // file-dc int
    
    putu.buffer 32 +

    while
        swp 16 /% dup

        // If the number is less then 10, starts from '0'. Otherwise, starts from '7', which added 10 is 'A'.
        10 < if '0' else '7' end +
        
        rot dec dup rot store swp dup rot swp 0 !=
    do end

    dup putu.buffer
    swp - 32 +
    fputs drop
endmacro

macro putx
    STDOUT swp fputx
endmacro

macro eputx
    STDERR swp fputx
endmacro

//    ======================
//    ==== Input macros ====
//    ======================

// == Strings ==
macro fgets
    // file-dc str-ptr str-len
    int int int returns
    
    SYSREAD syscall3 drop
endmacro

macro gets
    // str-ptr str-len
    
    STDIN rot rot fgets
endmacro


// == Lines ==
// This algorithm is unsafe and should not be used
macro fgetl
    // file-dc str-ptr -- str-len
    
    // fd st -> st fd st+0
    dup rot swp

    while
        // st fd (st+l) -> st fd (st+l) fd (st+l)
        swp dup rot dup rot swp

        1 fgets
        // st fd (st+l)

        dup load dup
        // st fd (st+l) ch ch
       
        '\n' !=
        // st fd (st+l) ch bool
    do
        dup 0 = if
	    break
	end

        drop
        
        // st fd (st+l)
        inc
        // st fd (st+l+1)
    end
    
    drop

    // st fd (st+n) -> st fd (st+n) (st+n) 0
    dup 0 store

    // st fd (st+n) -> n fd
    rot - swp

    drop
endmacro

macro getl
    // str-ptr -- str-len
    STDIN swp fgetl
endmacro
