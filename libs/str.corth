include libs/core.corth
include libs/memory.corth

macro str ptr int endmacro

macro str.get-len
  // ptr: ptr int: len -- int: len
  swp drop
endmacro

macro strc.get-len
  // ptr: ptr -- int: len

  0 while
    swp dup @8 0 !=
  do
    inc swp
  inc end drop
endmacro

macro str.to-strc
  // ptr: ptr int: len -- ptr: ptr
  drop
endmacro

macro strc.to-str
  // ptr: ptr -- ptr: ptr int: len
  dup strc.get-len
endmacro

macro str.copy
  // ptr: src int: len ptr: dst
  memcpy
endmacro

macro str.range
  // ptr: src int: len int: start int: end -- ptr: src' int: len'
  let _src_ _len_ _start_ _end_ in
    _src_ _start_ +
    _end_ _start_ -
  end
endmacro

proc str.hex-to-int
  // ptr: start int: length -- int: number bool: correct
  ptr int -- int bool
  // Converts a character array of hexadecimal number to an integer.
  // If the conversion can not be done, returns 0.
  // NOTE: If the number is too big, the result will be wrong.
in
  memory number sizeof(int) in
    0 number !64

    let start length in
      start while dup start length + < do let i in
        i @8 '0' '9' is-range if
          i @8 '0' - number @64 16 * + number !64
        else i @8 'a' 'f' is-range if
          i @8 'a' - number @64 16 * + number !64
        else i @8 'A' 'F' is-range if
          i @8 'A' - number @64 16 * + number !64
        else
          0 false return
        end end end
      i end inc end drop
    end

    number @64 true
  end
end

proc str.dec-to-int
  // ptr: start int: length -- int: number bool: correct
  ptr int -- int bool
  // Converts a character array of decimal number to an integer.
  // If the conversion can not be done, returns 0.
  // NOTE: If the number is too big, the result will be wrong.
in
  memory number sizeof(int) in
    0 number !64

    let start length in
      start while dup start length + < do let i in
        i @8 '0' '9' is-range if
          i @8 '0' - number @64 10 * + number !64
        else
          0 false return
        end
      i end inc end drop
    end

    number @64 true
  end
end

proc str.oct-to-int
  // ptr: start int: length -- int: number bool: correct
  ptr int -- int bool
  // Converts a character array of octal number to an integer.
  // If the conversion can not be done, returns 0.
  // NOTE: If the number is too big, the result will be wrong.
in
  memory number sizeof(int) in
    0 number !64

    let start length in
      start while dup start length + < do let i in
        i @8 '0' '7' is-range if
          i @8 '0' - number @64 8 * + number !64
        else
          0 false return
        end
      i end inc end drop
    end

    number @64 true
  end
end

proc str.bin-to-int
  // ptr: start int: length -- int: number bool: correct
  ptr int -- int bool
  // Converts a character array of binary number to an integer.
  // If the conversion can not be done, returns 0.
  // NOTE: If the number is too big, the result will be wrong.
in
  memory number sizeof(int) in
    0 number !64

    let start length in
      start while dup start length + < do let i in
        i @8 '0' '1' is-range if
          i @8 '0' - number @64 8 * + number !64
        else
          0 false return
        end
      i end inc end drop
    end

    number @64 true
  end
end

proc str.to-int
  // ptr: start int: length -- int: number bool: correct
  ptr int -- int bool
  // Converts a character array of any base (binary, octal, decimal, hexadecimal) to an integer..
  // If the conversion can not be done, returns 0.
  // NOTE: If the number is too big, the result will be wrong.
in let start length in
  start @8 '0' = if
    start inc @8 let base in
      base 'x' = if
        start 2 + length 2 - str.hex-to-int
      else base 'o' = if
        start 2 + length 2 - str.oct-to-int
      else base 'b' = if
        start 2 + length 2 - str.bin-to-int
      else
        start length str.dec-to-int
      end end end
    end
  else
    start length str.dec-to-int
  end
end end

/*
IT IS RECOMMENDED TO NOT USE THIS LIBRARY
THIS LIBRARY AND STRING TYPE REQUIRES A TON OF REWORK

There are two types of strings in Corth: char arrays and C-like strings.

char arrays:

  Stack:
    [cs] [cl]

  Memory:
    [c0] [c1] [c2] ... [c+cl]
     cs^

  cs points to the array pointer and right after it comes the length of the array.

C-like strings:

  Stack:
    [cs]

  Memory:
    [c0] [c1] [c2] ... [c+len] 00
     cs^

  cs points to the first char in the string and the last character is 0x00 (null-char).
*/
