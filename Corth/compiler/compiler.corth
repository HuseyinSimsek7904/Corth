include libs/linux_x86/sys.corth
include libs/linux_x86/io/output.corth
include libs/linux_x86/io/input.corth
include libs/core/stack.corth
include libs/core/arithmetic.corth
include libs/core/memory.corth

include libs/dynamic/malloc.corth
include libs/dynamic/utils.corth

macro string-builder.RESIZING 64 endmacro

include libs/linux_x86/path.corth

include libs/collections/list64.corth
include libs/collections/deque64.corth
include libs/collections/queue64.corth
include libs/collections/str_map64.corth
include libs/collections/str_set8.corth

include Corth/compiler/lexer.corth
include Corth/compiler/debug.corth
include Corth/compiler/enums.corth


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.show-here
  // ptr: token-address
  log-stream fput-here
  procedure-name procedure-address log-stream fput-inside-procedure
  ERROR-EXIT-CODE exit drop
endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.get-next-token let expect-address expect-length extend-macros in
  // str: expect-message bool: extend-macros -- int: token-type ptr: address [int|ptr]: arg
  // Calls get-next-token and checks if a token is available. If there are no tokens, prints an error message.
  source-name source-file
  line-no char-no
  extended-array extended-start extended-end
  macro-names macro-tokens macros-length
  log-stream extend-macros isn-zero get-next-token ! if
    LOG.ERR log-stream fputs "Reached EOF while expecting " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs
    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-type let _token_type_ expect-address expect-length expected-token-type in
  // ptr: token-arg ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-type _token_type_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-type log-stream fput-type  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_type_ log-stream fput-type "'.\n" log-stream fputs
    
    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-type-here let _token_type_ _token_addr_ expect-address expect-length expected-token-type in
  // ptr: token-arg ptr: token-addr ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-type _token_type_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-type log-stream fput-type  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_type_ log-stream fput-type "'.\n" log-stream fputs

    _token_addr_ compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-keyword let _token_arg_ expect-address expect-length expected-token-arg in
  // ptr: token-arg ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs

    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-keyword-here let _token_arg_ _token_addr_ expect-address expect-length expected-token-arg in
  // ptr: token-arg ptr: token-addr ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs

    _token_addr_ compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-level-here let _token_arg_ _old_token_addr_ _token_addr_ expect-address expect-length expected-token-arg in
  // ptr: token-arg ptr: old-token-addr ptr: new-token-addr ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs
    _old_token_addr_ compile-procedure.show-here
    _token_addr_ compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-null let expect-address expect-length in
  is-null if
    LOG.ERR log-stream fputs "'malloc' failed while " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs
    
    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-null-here let expect-address expect-length in
  is-null if
    LOG.ERR log-stream fputs "'malloc' failed while " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs

    token-address compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-branch let expect-address expect-length in
  branch-active @8 is-zero if
    LOG.SOFT log-stream fputs "Tried to " log-stream fputs expect-address expect-length log-stream fputs " but the branch was finished.\n" log-stream fputs

    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-branch-here let _token_addr_ expect-address expect-length in
  branch-active @8 is-zero if
    LOG.SOFT log-stream fputs "Tried to " log-stream fputs expect-address expect-length log-stream fputs " but the branch was finished.\n" log-stream fputs
    
    _token_addr_ compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.new-level-id
  level-id-counter @64 dup inc level-id-counter !64
endmacro


proc fput-alpha
  ptr file-desc --
in let name file in
  name mlength malloc let object in
    object is-null if
      "'malloc' failed while allocating space for fput-alpha.\n" STDERR fputs
      ERROR-EXIT-CODE exit drop
    end

    0 while dup name mlength < do let i in
      name i + @8 let char in
        char 'a' 'z' is-range char 'A' 'Z' is-range | char '1' '9' is-range | if
          char object i + !8
        else
          '_' object i + !8
        end
      end
    i end inc end drop

    object object mlength file fputs

    object mfree drop
  end
end end


/*

items:
  type (8)
  mode (8)

bool:
  real:
    type (8)
    mode (8)

int:
  real:
    type (8)
    mode (8)

  imm:
    type (8)
    mode (8)
    arg1 (8)

  global:
    type (8)
    mode (8)
    arg1 (8)

*/

macro get-type      @64 endmacro
macro set-type      !64 endmacro
macro get-mode 8  + @64 endmacro
macro set-mode 8  + !64 endmacro
macro get-arg1 16 + @64 endmacro
macro set-arg1 16 + !64 endmacro

macro MODE-REAL     0 endmacro
macro MODE-IMM      1 endmacro
macro MODE-GLOBAL   2 endmacro


proc is-signed-dword
  int -- bool
in let value in
  value 0x100000000 < value 0x100000000 neg > &
end end


proc push-int-immediate-to-real-stack
  // int: immediate file-desc: output-file
  ptr file-desc --
in let immediate output-file in
  immediate is-zero if
    "    xor     rax, rax\n" output-file fputs
    "    push    rax\n"      output-file fputs
  else immediate is-signed-dword if
    "    push    " output-file fputs immediate output-file fputi output-file fputnl
  else
    "    mov     rax, " output-file fputs immediate output-file fputi output-file fputnl
    "    push    rax\n" output-file fputs
  end end
end end


proc push-global-data-to-real-stack
  // ptr: global-name file-desc: output-file
  ptr file-desc --
in let global output-file in
  "    push    global_" output-file fputs global output-file fput-alpha output-file fputnl
end end


proc convert-int-to-real
  // ptr: item file-desc: output-file
  ptr file-desc --
in let item output-file in
  item get-mode MODE-IMM = if
    item get-arg1 output-file push-int-immediate-to-real-stack
    
  else item get-mode MODE-GLOBAL = if
    item get-arg1 output-file push-global-data-to-real-stack

  else item get-mode MODE-REAL != if
    LOG.ERR STDOUT fputs "Unknown integer mode.\n" STDERR fputs
    ERROR-EXIT-CODE exit drop
  end end end

  MODE-REAL item set-mode
end end


proc convert-bool-to-real
  // ptr: item file-desc: output-file
  ptr file-desc --
in let item output-file in
  item get-mode MODE-REAL != if
    LOG.ERR STDOUT fputs "Unknown bool mode.\n" STDERR fputs
    ERROR-EXIT-CODE exit drop
  end

  MODE-REAL item set-mode
end end


proc convert-to-real
  // ptr: item file-desc: output-file
  ptr file-desc --
in let item output-file in
  item output-file
  
       item get-type INT-TYPE-INT  = if convert-int-to-real
  else item get-type INT-TYPE-BOOL = if convert-bool-to-real
  else drop drop
    LOG.ERR STDOUT fputs item get-type STDERR fputu "Unknown intrinsic type to convert to real.\n" STDERR fputs
    ERROR-EXIT-CODE exit drop
  end end
end end


proc create-stack-item
  // int: int-type int: mode -- ptr: item
  int int -- ptr
in let int-type mode in
  24 malloc let object in
    object is-null if
      "'malloc' failed while creating a real stack item.\n" STDERR fputs
      ERROR-EXIT-CODE exit drop
    end

    int-type  object set-type
    mode      object set-mode

    object
  end
end end


// ptr: item --
macro push-item
  // Before we push a new item, make sure that the last item is a real stack item.
  convert-last-item-to-real

  local-stack local-stack-length queue64.append
endmacro

// -- ptr: item
macro pop-item
  local-stack local-stack-length queue64.pop-last
endmacro

macro convert-last-item-to-real
  local-stack-length @64 isn-zero if
    local-stack-length @64 dec local-stack array64.get output-file convert-to-real
  end
endmacro

// int: int-type --
macro push-real let _int-type_ in
  _int-type_ MODE-REAL create-stack-item push-item
end endmacro


// int: immediate-value
macro push-int-immediate let _immediate_ in
  INT-TYPE-INT MODE-IMM create-stack-item let _item_ in
    _immediate_ _item_ set-arg1

    _item_ push-item
  end
end endmacro


macro invalid-usage-of-intrinsic
  LOG.ERR log-stream fputs "Invalid argument types.\n" log-stream fputs
  token-address log-stream fput-here
  ERROR-EXIT-CODE exit drop
endmacro


proc compare-stack-types
  // ptr: old-stack ptr: local-stack ptr: local-stack-length -- bool: is-equal
  ptr ptr ptr -- bool
in let old-stack local-stack local-stack-length in
  local-stack-length @64 8 * old-stack mlength != if false return end

  0 while dup local-stack-length @64 < do let i in
    i old-stack array64.get get-type i local-stack array64.get get-type != if false return end
  i end inc end drop
end true end


proc compare-stack-types-types
  // ptr: types-array int: types-length ptr: local-stack ptr: local-stack-length -- bool: is-equal
  ptr int ptr ptr -- bool
in let
  types-array types-length
  local-stack local-stack-length
in
  types-length local-stack-length @64 != if false return end

  0 while dup types-length < do let i in
    i local-stack array64.get get-type i types-array array64.get != if false return end
  i end inc end drop
end true end


proc compare-sub-stack-types-types
  // ptr: types-array int: types-length ptr: local-stack ptr: local-stack-length -- bool: is-equal
  ptr int ptr ptr -- bool
in let
  types-array types-length
  local-stack local-stack-length
in
  types-length local-stack-length @64 > if false return end

  types-length while dup isn-zero do dec let i in
    pop-item let item in
      i types-array array64.get let expected in
        item get-type expected != if false return end
      end
    end
  i end end drop
end true end


proc fput-stack-contents
  // ptr: stack-ptr int: stack-length file-desc: log-stream --
  ptr int file-desc --
in let stack length log-stream in
  length is-zero if
    "<empty>\n" log-stream fputs
    return
  end

  0 while dup length dec < do let i in
    i stack array64.get get-type log-stream fput-int-type " " log-stream fputs
  i end inc end drop

  length dec stack array64.get get-type log-stream fput-int-type
end end


proc fput-types
  // ptr: types-array int: types-length file-desc: log-stream --
  ptr int file-desc --
in let types-array types-length log-stream in
  types-length is-zero if
    "<empty>\n" log-stream fputs
    return
  end

  0 while dup types-length dec < do let i in
    i types-array array64.get log-stream fput-int-type " " log-stream fputs
  i end inc end drop

  types-length dec types-array array64.get log-stream fput-int-type
end end


proc check-stack-types
  // ptr: old-stack ptr: old-address ptr: local-stack ptr: local-stack-length ptr: token-address file-desc: log-stream --
  ptr ptr ptr ptr ptr file-desc --
in let old-stack old-address local-stack local-stack-length token-address log-stream in
  old-stack local-stack local-stack-length compare-stack-types ! if
    LOG.ERR log-stream fputs "Stack contents do not match.\n" log-stream fputs
    old-address log-stream fput-here
    LOG.INFO log-stream fputs old-stack old-stack mlength 8 / log-stream fput-stack-contents log-stream fputnl
    token-address log-stream fput-here
    LOG.INFO log-stream fputs local-stack local-stack-length @64 log-stream fput-stack-contents log-stream fputnl

    ERROR-EXIT-CODE exit drop
  end
end end


proc check-stack-types-types
  // ptr: types-array int: types-length
  ptr int
  // ptr: token-address
  ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // file-desc: log-stream
  file-desc --
in let
  types-array types-length
  token-address
  local-stack local-stack-length
  log-stream
in
  types-array types-length local-stack local-stack-length compare-stack-types-types ! if
    LOG.ERR log-stream fputs "Stack contents do not match.\n" log-stream fputs
    token-address log-stream fput-here
    LOG.INFO log-stream fputs "Expected '" log-stream fputs types-array types-length log-stream fput-types "'.\n" log-stream fputs
    LOG.INFO log-stream fputs "Got '" log-stream fputs local-stack local-stack-length @64 log-stream fput-stack-contents "'.\n" log-stream fputs

    ERROR-EXIT-CODE exit drop
  end
end end


proc check-sub-stack-types-types
  // ptr: types-array int: types-length
  ptr int
  // ptr: token-address
  ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // file-desc: log-stream
  file-desc --
in let
  types-array types-length
  token-address
  local-stack local-stack-length
  log-stream
in
  types-array types-length local-stack local-stack-length compare-sub-stack-types-types ! if
    LOG.ERR log-stream fputs "Stack contents do not match.\n" log-stream fputs
    token-address log-stream fput-here
    LOG.INFO log-stream fputs "Expected '" log-stream fputs types-array types-length log-stream fput-types "'.\n" log-stream fputs
    LOG.INFO log-stream fputs "Got '" log-stream fputs local-stack local-stack-length @64 log-stream fput-stack-contents "'.\n" log-stream fputs

    ERROR-EXIT-CODE exit drop
  end
end end


proc stack-item.mfree
  // ptr: item --
  ptr --
in let item in
  // For now, this only mfrees the dynamic object.
  // This may change in the future.

  item mfree drop
end end


proc stack-item.copy
  // ptr: item -- ptr: copied
    ptr -- ptr
in let item in
  // For now, this only copies the dynamic object.
  // This may change in the future.

  item dcopy
end end


proc __local-stack.mfree-items
  // ptrL local-stack int: local-stack-length
  ptr int --
in let local-stack local-stack-length in
  // TODO: Something is wrong here.
  // Iterate through the items and mfree them.
  0 while dup local-stack-length < do let i in
    // i local-stack array64.get stack-item.mfree
  i end inc end drop
end end


proc _local-stack.mfree
  // ptr: local-stack
  ptr --
  // Can be used on copies of local-stack.
in let local-stack in
  local-stack local-stack mlength 8 / __local-stack.mfree-items
end end


proc local-stack.clean
  // ptr: local-stack ptr: local-stack-length --
  ptr ptr --
in let local-stack local-stack-length in
  local-stack local-stack-length @64 __local-stack.mfree-items

  // Set the local-stack-length to 0.
  0 local-stack-length !64
end end


proc local-stack.copy
  // ptr: local-stack ptr: local-stack-length -- ptr: copied
  ptr ptr -- ptr
in let local-stack local-stack-length in 
  local-stack-length @64 8 * malloc let copy-array in
    copy-array is-null if
      LOG.ERR STDERR fputs "'malloc' failed while copying the local stack.\n" STDERR fputs
      ERROR-EXIT-CODE exit drop
    end

    // Copy the items from the local-stack to the copy-array.
    0 while dup local-stack-length @64 < do let i in
      i local-stack array64.get stack-item.copy i copy-array array64.set
    i end inc end drop

    // Return copy array.
    copy-array
  end
end end


proc local-stack.overwrite
  // ptr: overwrite ptr: local-stack ptr: local-stack-length --
  ptr ptr ptr --
in let overwrite local-stack local-stack-length in
  // Deallocate all of the items in the local-stack.
  local-stack local-stack-length @64 __local-stack.mfree-items

  // Overwrite the local-stack.
  overwrite overwrite mlength 8 / local-stack local-stack-length queue64.overwrite
end end


proc add-immediate-to-real-integer
  // int: immediate file-desc: output-file --
  int file-desc --
in let immediate output-file in
  immediate 1 = if
    "    inc     qword [rsp]\n" output-file fputs
  else immediate 1 neg = if
    "    dec     qword [rsp]\n" output-file fputs
  else immediate is-signed-dword ! if
    "    mov     rax, " output-file fputs immediate output-file fputi output-file fputnl
    "    add     qword [rsp], rax\n" output-file fputs
  else immediate isn-zero if
    "    add     qword [rsp], qword " output-file fputs immediate output-file fputu output-file fputnl
  end end end end
end end


proc bor-immediate-to-real-integer
  // int: immediate ptr: local-stack ptr: local-stack-length file-desc: output-file --
  int ptr ptr file-desc --
in let immediate local-stack local-stack-length output-file in
  immediate is-zero if
    INT-TYPE-INT push-real
  else immediate 0xffffffffffffffff = if
    0 push-int-immediate
  else immediate is-signed-dword if
    INT-TYPE-INT push-real
    "    or      [rsp], " output-file fputs immediate output-file fputi output-file fputnl
  else
    INT-TYPE-INT push-real
    "    mov     rax, " output-file fputs immediate output-file fputi output-file fputnl
    "    or      [rsp], rax\n" output-file fputs
  end end end  
end end


proc load-intrinsic
  // ptr: token-address ptr: register-name int: register-name-length ptr: local-stack ptr: local-stack-length file-desc: output-file file-desc: log-stream --
  ptr ptr int ptr ptr file-desc file-desc --
in let token-address register-name register-name-length local-stack local-stack-length output-file log-stream in
  local-stack-length @64 1 < if invalid-usage-of-intrinsic end

  pop-item let item in
    item get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end

    item get-mode MODE-REAL = if
      INT-TYPE-INT push-real

      "    xor     rax, rax\n"      output-file fputs
      "    pop     rbx\n"           output-file fputs
      "    mov     " output-file fputs register-name register-name-length output-file fputs ", [rbx]\n" output-file fputs
      "    push    rax\n"           output-file fputs

    else item get-mode MODE-IMM = if
      LOG.ERR log-stream fputs "Load intrinsics do not accept immediate address argument.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop

    else item get-mode MODE-GLOBAL = if
      INT-TYPE-INT push-real
      "    push    qword [global_" output-file fputs item get-arg1 output-file fput-alpha "]\n" output-file fputs

    else
      LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
      log-stream report-bug
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end end end
  end
end end


proc store-intrinsic
  // ptr: token-address ptr: register-name int: register-name-length ptr: local-stack ptr: local-stack-length file-desc: output-file file-desc: log-stream --
  ptr ptr int ptr ptr file-desc file-desc --
in let token-address register-name register-name-length local-stack local-stack-length output-file log-stream in
  local-stack-length @64 2 < if invalid-usage-of-intrinsic end

  pop-item pop-item let item2 item1 in
    item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
    item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end

    item2 get-mode MODE-REAL = if
      item1 get-mode MODE-REAL = if
        "    pop     rax\n" output-file fputs
        "    pop     rbx\n" output-file fputs
        "    mov     [rax], " output-file fputs register-name register-name-length output-file fputs output-file fputnl
      else item1 get-mode MODE-IMM = if
        item1 get-arg1 is-signed-dword if
          "    pop     rax\n" output-file fputs
          "    mov     [rax], " output-file fputs item1 get-arg1 output-file fputi output-file fputnl
        else
          "    pop     rax\n" output-file fputs
          "    mov     " output-file fputs output-file fputnl register-name register-name-length output-file fputs ", " output-file fputs item1 get-arg1 output-file fputi output-file fputnl
          "    mov     [rax], " output-file fputs register-name register-name-length output-file fputs output-file fputnl
        end
      else item1 get-mode MODE-GLOBAL = if
        "    pop     rax\n" output-file fputs
        "    mov     [rax], " output-file fputs item1 get-arg1 output-file fput-alpha output-file fputnl
      else
        LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
        log-stream report-bug
        token-address log-stream fput-here
        ERROR-EXIT-CODE exit drop
      end end end
    else item2 get-mode MODE-GLOBAL = if
      item1 get-mode MODE-REAL = if
        "    pop     rbx\n" output-file fputs
        "    mov     [global_" output-file fputs item2 get-arg1 output-file fput-alpha
        "], " output-file fputs register-name register-name-length output-file fputs output-file fputnl
      else item1 get-mode MODE-IMM = if
        item1 get-arg1 is-signed-dword if
          "    mov     [global_" output-file fputs item2 get-arg1 output-file fput-alpha
          "], " output-file fputs item1 get-arg1 output-file fputi output-file fputnl
        else
          "    mov     " output-file fputs output-file fputnl register-name register-name-length output-file fputs ", " output-file fputs item1 get-arg1 output-file fputi output-file fputnl
          "    mov     [global_" output-file fputs item2 get-arg1 output-file fput-alpha
          "], " output-file fputs register-name register-name-length output-file fputs output-file fputnl
        end
      else item1 get-mode MODE-GLOBAL = if
        "    mov     [global_" output-file fputs item2 get-arg1 output-file fput-alpha
        "], global_" output-file fputs item1 get-arg1 output-file fput-alpha output-file fputnl
      else
        LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
        log-stream report-bug
        token-address log-stream fput-here
        ERROR-EXIT-CODE exit drop
      end end end
    else item2 get-mode MODE-IMM = if
      LOG.ERR log-stream fputs "Store intrinsics do not accept immediate address argument.\n" log-stream fputs
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    else
      LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
      log-stream report-bug
      token-address log-stream fput-here
      ERROR-EXIT-CODE exit drop
    end end end
  end
end end


proc compile-intrinsic
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // file-desc: log-stream
  file-desc --

  // Compiles an intrinsic in a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let 
  source-name source-file output-file
  line-no char-no
  procedure-name procedure-address
  local-stack local-stack-length
  token-type token-address token-arg
  log-stream
in
  token-arg INTRINSIC-ADD = if
    // -------- Intrinsic '+' --------

    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT != item2 get-type INT-TYPE-INT != | if invalid-usage-of-intrinsic end
      
      item1 get-mode MODE-REAL = if
        INT-TYPE-INT push-real
        item2 get-mode MODE-REAL = if
          "    pop     rax\n"        output-file fputs
          "    add     [rsp], rax\n" output-file fputs
        else item2 get-mode MODE-IMM = if
          item2 get-arg1 output-file add-immediate-to-real-integer
        else item2 get-mode MODE-GLOBAL = if
          "    add     [rsp], global_" output-file fputs item2 get-arg1 output-file fput-alpha output-file fputnl
        else
          LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
          log-stream report-bug
          ERROR-EXIT-CODE exit drop
        end end end
      else item1 get-mode MODE-IMM = if
        item2 get-mode MODE-REAL = if
          INT-TYPE-INT push-real
          item1 get-arg1 output-file add-immediate-to-real-integer
        else item2 get-mode MODE-IMM = if
          item1 get-arg1 item2 get-arg1 + push-int-immediate
        else item2 get-mode MODE-GLOBAL = if
          item2 get-arg1 output-file push-global-data-to-real-stack
          item1 get-arg1 output-file add-immediate-to-real-integer
        else
          LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
          log-stream report-bug
          ERROR-EXIT-CODE exit drop
        end end end
      else item1 get-mode MODE-GLOBAL = if
        item2 get-mode MODE-REAL = if
          "    add     [rsp], global_" output-file fputs item1 get-arg1 output-file fput-alpha output-file fputnl
        else item2 get-mode MODE-IMM = if
          item1 get-arg1 output-file push-global-data-to-real-stack
          item2 get-arg1 output-file add-immediate-to-real-integer
        else item2 get-mode MODE-GLOBAL = if
          item1 get-arg1 output-file push-global-data-to-real-stack
          "    add     [rsp], global_" output-file fputs item2 get-arg1 output-file fput-alpha output-file fputnl
        else
          LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
          log-stream report-bug
          ERROR-EXIT-CODE exit drop
        end end end
      else
        LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
        log-stream report-bug
        ERROR-EXIT-CODE exit drop
      end end end
    end

  else token-arg INTRINSIC-BOR = if
    // -------- Intrinsic '||' --------
    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT != item2 get-type INT-TYPE-INT != | if invalid-usage-of-intrinsic end
      
      item1 get-mode MODE-REAL = if
        INT-TYPE-INT push-real
        item2 get-mode MODE-REAL = if
          "    pop     rax\n"        output-file fputs
          "    or      [rsp], rax\n" output-file fputs
        else item2 get-mode MODE-IMM = if
          item2 get-arg1 local-stack local-stack-length output-file bor-immediate-to-real-integer
        else
          LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
          log-stream report-bug
          ERROR-EXIT-CODE exit drop
        end end
      else item1 get-mode MODE-IMM = if
        item2 get-mode MODE-REAL = if
          item1 get-arg1 local-stack local-stack-length output-file bor-immediate-to-real-integer
        else item2 get-mode MODE-IMM = if
          item1 get-arg1 item2 get-arg1 || push-int-immediate
        else
          LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
          log-stream report-bug
          ERROR-EXIT-CODE exit drop
        end end
      else
        LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
        log-stream report-bug
        ERROR-EXIT-CODE exit drop
      end end
    end
    
  else token-arg INTRINSIC-BNOT = if
    // -------- Intrinsic '!!' --------

    local-stack-length @64 1 < if invalid-usage-of-intrinsic end

    pop-item let item in
      item get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      
      item get-mode MODE-REAL = if
        INT-TYPE-INT push-real
        "    not     qword [rsp]\n" output-file fputs

      else item get-mode MODE-IMM = if
        item get-arg1 !! push-int-immediate

      else item get-mode MODE-GLOBAL = if
        INT-TYPE-INT push-real
        item get-arg1 output-file push-global-data-to-real-stack
        "    not     qword [rsp]\n" output-file fputs

      else
        LOG.ERR log-stream fputs "Unknown integer mode.\n" log-stream fputs
        log-stream report-bug
        ERROR-EXIT-CODE exit drop
      end end end
    end
    
  else token-arg INTRINSIC-FULLMUL = if
    // -------- Intrinsic '**' --------

    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT = if
        item2 get-type INT-TYPE-INT = if
          item1 output-file convert-int-to-real
          item2 output-file convert-int-to-real
          
          INT-TYPE-INT push-real
          INT-TYPE-INT push-real
          
          "    xor     rdx, rdx\n"        output-file fputs
          "    mov     rbx, [rsp]\n"      output-file fputs
          "    mov     rax, [rsp+8]\n"    output-file fputs
          "    imul    rbx\n"             output-file fputs
          "    mov     [rsp], rax\n"      output-file fputs
          "    mov     [rsp+8], rdx\n"    output-file fputs
        else invalid-usage-of-intrinsic end
      else invalid-usage-of-intrinsic end
    end
    
  else token-arg INTRINSIC-DIVMOD = if
    // -------- Intrinsic '/%' --------

    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT = if
        item2 get-type INT-TYPE-INT = if
          item1 output-file convert-int-to-real
          item2 output-file convert-int-to-real
          
          INT-TYPE-INT push-real
          INT-TYPE-INT push-real
          
          "    xor     rdx, rdx\n"        output-file fputs
          "    mov     rbx, [rsp]\n"      output-file fputs
          "    mov     rax, [rsp+8]\n"    output-file fputs
          "    idiv    rbx\n"             output-file fputs
          "    mov     [rsp+8], rax\n"    output-file fputs
          "    mov     [rsp], rdx\n"      output-file fputs
        else invalid-usage-of-intrinsic end
      else invalid-usage-of-intrinsic end
    end
    
  else token-arg INTRINSIC-UFULLMUL = if
    // -------- Intrinsic 'u**' --------

    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT = if
        item2 get-type INT-TYPE-INT = if
          item1 output-file convert-int-to-real
          item2 output-file convert-int-to-real
          
          INT-TYPE-INT push-real
          INT-TYPE-INT push-real
          
          "    xor     rdx, rdx\n"        output-file fputs
          "    mov     rbx, [rsp]\n"      output-file fputs
          "    mov     rax, [rsp+8]\n"    output-file fputs
          "    mul     rbx\n"             output-file fputs
          "    mov     [rsp], rax\n"      output-file fputs
          "    mov     [rsp+8], rdx\n"    output-file fputs
        else invalid-usage-of-intrinsic end
      else invalid-usage-of-intrinsic end
    end
        
  else token-arg INTRINSIC-UDIVMOD = if
    // -------- Intrinsic 'u/%' --------

    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT = if
        item2 get-type INT-TYPE-INT = if
          item1 output-file convert-int-to-real
          item2 output-file convert-int-to-real
          
          INT-TYPE-INT push-real
          INT-TYPE-INT push-real
          
          "    xor     rdx, rdx\n"        output-file fputs
          "    mov     rbx, [rsp]\n"      output-file fputs
          "    mov     rax, [rsp+8]\n"    output-file fputs
          "    div     rbx\n"             output-file fputs
          "    mov     [rsp+8], rax\n"    output-file fputs
          "    mov     [rsp], rdx\n"      output-file fputs
        else invalid-usage-of-intrinsic end
      else invalid-usage-of-intrinsic end
    end
    
  else token-arg INTRINSIC-NOTEQUAL = if
    // -------- Intrinsic '!=' --------

    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT = if
        item2 get-type INT-TYPE-INT = if
          item1 output-file convert-int-to-real
          item2 output-file convert-int-to-real
          
          INT-TYPE-BOOL push-real
          
          "    pop     rax\n"        output-file fputs
          "    sub     [rsp], rax\n" output-file fputs
        else invalid-usage-of-intrinsic end
      else invalid-usage-of-intrinsic end
    end

  else token-arg INTRINSIC-LESS = if
    // -------- Intrinsic '<' --------
    
    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT = if
        item2 get-type INT-TYPE-INT = if
          item1 output-file convert-int-to-real
          item2 output-file convert-int-to-real
          
          INT-TYPE-BOOL push-real
          
          "    pop     rax\n"               output-file fputs
          "    pop     rbx\n"               output-file fputs
          "    sub     rbx, rax\n"          output-file fputs
          "    pushf\n"                     output-file fputs
          "    and     qword [rsp], 0x80\n" output-file fputs
        else invalid-usage-of-intrinsic end
      else invalid-usage-of-intrinsic end
    end

  else token-arg INTRINSIC-LOAD8   = if token-address "al"  local-stack local-stack-length output-file log-stream load-intrinsic
  else token-arg INTRINSIC-LOAD16  = if token-address "ax"  local-stack local-stack-length output-file log-stream load-intrinsic
  else token-arg INTRINSIC-LOAD32  = if token-address "eax" local-stack local-stack-length output-file log-stream load-intrinsic
  else token-arg INTRINSIC-LOAD64  = if token-address "rax" local-stack local-stack-length output-file log-stream load-intrinsic
  else token-arg INTRINSIC-STORE8  = if token-address "bl"  local-stack local-stack-length output-file log-stream store-intrinsic
  else token-arg INTRINSIC-STORE16 = if token-address "bx"  local-stack local-stack-length output-file log-stream store-intrinsic
  else token-arg INTRINSIC-STORE32 = if token-address "ebx" local-stack local-stack-length output-file log-stream store-intrinsic
  else token-arg INTRINSIC-STORE64 = if token-address "rbx" local-stack local-stack-length output-file log-stream store-intrinsic
    
  else token-arg INTRINSIC-TRUE = if
    // -------- Intrinsic 'true' --------

    INT-TYPE-BOOL push-real
    
    "    mov     rax, 0xffffffffffffffff\n" output-file fputs
    "    push    rax\n"                     output-file fputs

  else token-arg INTRINSIC-FALSE = if
    // -------- Intrinsic 'false' -------

    INT-TYPE-BOOL push-real
    
    "    xor     rax, rax\n" output-file fputs
    "    push    rax\n"      output-file fputs
    
  else token-arg INTRINSIC-SYSCALL6 = if
    // -------- Intrinsic 'syscall6' --------

    local-stack-length @64 7 < if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item pop-item pop-item pop-item pop-item let item7 item6 item5 item4 item3 item2 item1 in
      item1 get-type INT-TYPE-INT = if
        item2 get-type INT-TYPE-INT = if
          item3 get-type INT-TYPE-INT = if
            item4 get-type INT-TYPE-INT = if
              item5 get-type INT-TYPE-INT = if
                item6 get-type INT-TYPE-INT = if
                  item7 get-type INT-TYPE-INT = if
                    item1 output-file convert-int-to-real
                    item2 output-file convert-int-to-real
                    item3 output-file convert-int-to-real
                    item4 output-file convert-int-to-real
                    item5 output-file convert-int-to-real
                    item6 output-file convert-int-to-real
                    item7 output-file convert-int-to-real

                    INT-TYPE-INT push-real
                    
                    "    pop     rax\n" output-file fputs
                    "    pop     r9\n"  output-file fputs
                    "    pop     r8\n"  output-file fputs
                    "    pop     r10\n" output-file fputs
                    "    pop     rdx\n" output-file fputs
                    "    pop     rsi\n" output-file fputs
                    "    pop     rdi\n" output-file fputs
                    "    syscall\n"     output-file fputs
                    "    push    rax\n" output-file fputs
                  else invalid-usage-of-intrinsic end
                else invalid-usage-of-intrinsic end
              else invalid-usage-of-intrinsic end
            else invalid-usage-of-intrinsic end
          else invalid-usage-of-intrinsic end
        else invalid-usage-of-intrinsic end
      else invalid-usage-of-intrinsic end
    end

  else
    LOG.TODO log-stream fputs "Intrinsic '" log-stream fputs token-arg log-stream fput-intrinsic "' is not implemented yet.\n" log-stream fputs
    token-address log-stream fput-here
    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end end end end end end end end end end end end end end end end end end end end
end end


proc compile-keyword
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr ptr file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // ptr: levels-list ptr: level-id-counter
  ptr ptr
  // ptr: local-names ptr: local-addresses ptr: locals-length
  ptr ptr ptr
  // ptr: local-memory-end
  ptr 
  // ptr: let-names ptr: let-addresses ptr: let-vars-length
  ptr ptr ptr
  // ptr: branch-active
  ptr
  // ptr: output-array int: output-length
  ptr int
  // file-desc: log-stream
  file-desc
  // ptr: local-memory-max
  ptr
  --
  // bool: end-of-procedure
  bool
in let
  source-name source-file output-file
  line-no char-no
  macro-names macro-tokens macros-length
  procedure-name procedure-address
  local-stack local-stack-length
  extended-array extended-start extended-end
  token-type token-address token-arg
  levels-list level-id-counter
  local-names local-addresses locals-length
  local-memory-end
  let-names let-addresses let-vars-length
  branch-active
  output-array output-length
  log-stream
  local-memory-max
in
  token-arg KEYWORD-END = if
    // -------- Keyword 'end' --------

    levels-list list64.length is-zero if
      // -------- End of 'proc' --------

      // Branch should not be cut before the main procedure return.
      token-address "finish a procedure" compile-procedure.check-branch-here

      convert-last-item-to-real

      // Check if the stack is correct.
      output-array output-length
      token-address
      local-stack local-stack-length
      log-stream
      check-stack-types-types
      
      true return
    end

    levels-list list64.pop-last let level in
      level @64 level 8 + @64 let start-keyword start-address in                
        start-keyword KEYWORD-IF = if
          // -------- End of 'if' --------
          level 16 + @64 level 24 + @64 let start-id start-stack in
            branch-active @8 is-zero if
              // Overwrite the contents of the local-stack with the old contents.
              start-stack local-stack local-stack-length local-stack.overwrite

              // Reset the branch.
              0xff branch-active !8
            end
            
            convert-last-item-to-real

            // Check for the stack changes.
            start-stack start-address local-stack local-stack-length token-address log-stream check-stack-types

            ".level_" output-file fputs start-id output-file fputu ":\n" output-file fputs

            // Deallocate 'start-stack'.
            start-stack _local-stack.mfree
          end

        else start-keyword KEYWORD-ELSE = if
          // -------- End of 'else' --------

          // Branch should not be cut before the end of else.
          token-address "finish an 'if-else'" compile-procedure.check-branch-here

          level 16 + @64 level 24 + @64 level 32 + @64 let else-address start-id start-stack in
            convert-last-item-to-real

            // Check for the stack changes.
            start-stack else-address local-stack local-stack-length token-address log-stream check-stack-types
            
            ".level_" output-file fputs start-id output-file fputu ":\n" output-file fputs

            // Deallocate 'else-address' and 'start-stack'.
            else-address mfree drop
            start-stack _local-stack.mfree
          end

        else start-keyword KEYWORD-WHILE = if
          // -------- End of 'while' --------

          LOG.ERR  log-stream fputs "You probably forgot a 'do' after 'while'.\n" log-stream fputs
          LOG.INFO log-stream fputs "A 'while-do' loop can be created as: 'while <condition> do <code> end'\n" log-stream fputs
          
          token-address log-stream fput-here
          start-address compile-procedure.show-here
          
          ERROR-EXIT-CODE exit drop

        else start-keyword KEYWORD-DO = if
          // -------- End of 'do' --------

          // Branch should not be cut before the end of do.
          token-address "finish a while-do loop" compile-procedure.check-branch-here

          level 16 + @64 level 24 + @64 level 32 + @64 level 40 + @64 level 48 + @64 level 56 + @64 let
            while-level-id do-address unbroken-end-id broken-end-id while-stack do-stack
          in
            // Check for the stack changes.
            while-stack start-address local-stack local-stack-length token-address log-stream check-stack-types

            // Overwrite the contents of the local-stack.
            do-stack local-stack local-stack-length local-stack.overwrite

            "    jmp     .level_" output-file fputs while-level-id output-file fputu output-file fputnl

            ".level_" output-file fputs unbroken-end-id output-file fputu ":\n" output-file fputs
            ".level_" output-file fputs broken-end-id   output-file fputu ":\n" output-file fputs

            // Deallocate 'do-address', 'while-stack' and 'do-stack'.
            do-address mfree drop
            while-stack _local-stack.mfree
            do-stack _local-stack.mfree
          end

        else start-keyword KEYWORD-LET = if
          // -------- End of 'let' --------

          level 16 + @64 level 24 + @64 let new-names old-local-memory-end in
            0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
              name mlength 1 = if name @8 '_' != else true end if
                name let-names let-addresses let-vars-length str-map64.remove ! if
                  LOG.ERR  log-stream fputs "Could not find the 'let' variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                  log-stream report-bug
                  start-address compile-procedure.show-here
                  ERROR-EXIT-CODE exit drop
                end
              end
            end i end inc end drop

            old-local-memory-end local-memory-end !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end

        else start-keyword KEYWORD-MEMORY = if
          // -------- End of 'memory' --------

          // -- debug --
          // token-address log-stream fput-here
          // 0 while dup locals-length @64 < do let j in
          //  j local-names array64.get dup mlength log-stream fputs log-stream fputnl
          // j end inc end drop

          level 16 + @64 level 24 + @64 let new-names old-local-memory-end in
            0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
              name local-names local-addresses locals-length str-map64.remove ! if
                LOG.ERR  log-stream fputs "Could not find the local variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs

                log-stream report-bug
                token-address log-stream fput-here
                start-address compile-procedure.show-here
                ERROR-EXIT-CODE exit drop
              end
            end i end inc end drop

            old-local-memory-end local-memory-end !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end

        else
          LOG.TODO log-stream fputs "'end' after keyword '" log-stream fputs start-keyword log-stream fput-keyword "' is not implemented yet.\n" log-stream fputs
          token-address log-stream fput-here
          start-address compile-procedure.show-here
          ERROR-EXIT-CODE exit drop
        end end end end end end

        // Deallocate 'start-address'.
        start-address mfree drop
      end

      // Deallocate level object.
      level mfree drop
    end

  else token-arg KEYWORD-IF = if
    // -------- Keyword 'if' --------
    // <condition> if <any> end
    // <condition> if <any> else <any> end

    // TODO: These are not implemented yet.
    // <condition> if <any> (elif <condition> if <any>)* end

    // Level structure:
    //  0- 7 -> KEYWORD-IF
    //  8-15 -> Starter address
    // 16-23 -> Level ID
    // 24-31 -> Old stack

    // Branch should not be cut before 'else'.
    token-address "before 'if'" compile-procedure.check-branch-here

    local-stack-length @64 is-zero if
      LOG.ERR log-stream fputs "'if' requires a bool, there was no items in the stack.\n" log-stream fputs
      token-address compile-procedure.show-here
      ERROR-EXIT-CODE exit drop
    end

    pop-item let item in
      item get-type INT-TYPE-BOOL != if
        LOG.ERR log-stream fputs "'if' requires a bool\n" log-stream fputs
        token-address compile-procedure.show-here
        ERROR-EXIT-CODE exit drop
      end

      item output-file convert-bool-to-real

      item mfree drop
    end

    local-stack local-stack-length local-stack.copy let copy-stack in
      32 malloc let obj in
        obj "creating a level object for 'if'" compile-procedure.check-null-here

        compile-procedure.new-level-id let level-id in
          KEYWORD-IF           obj      !64
          token-address dcopy  obj 8  + !64
          level-id             obj 16 + !64
          copy-stack           obj 24 + !64

          obj levels-list list64.append

          "    pop     rax\n"      output-file fputs
          "    test    rax, rax\n" output-file fputs
          "    jz      .level_"    output-file fputs level-id output-file fputu output-file fputnl
        end
      end
    end

  else token-arg KEYWORD-ELSE = if
    // -------- Keyword 'else' --------
    // <condition> if <any> else <any> end

    // Level structure:
    //  0- 7 -> KEYWORD-ELSE
    //  8-15 -> If address
    // 16-23 -> Else address
    // 24-31 -> Level ID
    // 32-39 -> Old stack

    // Branch should not be cut before 'else'.
    token-address "before 'else'" compile-procedure.check-branch-here

    levels-list list64.length is-zero if
      LOG.ERR log-stream fputs "'else' requires 'if'.\n" log-stream fputs
      token-address compile-procedure.show-here
      ERROR-EXIT-CODE exit drop
    end

    convert-last-item-to-real

    levels-list list64.pop-last let level in
      level @64 level 8 + @64 let old-keyword old-address in
        old-keyword old-address token-address "before 'else'" KEYWORD-IF compile-procedure.check-level-here

        level 16 + @64 level 24 + @64 let start-id start-stack in
          local-stack local-stack-length local-stack.copy let copy-stack in
            // Overwrite the contents of the local-stack.
            start-stack local-stack local-stack-length local-stack.overwrite

            compile-procedure.new-level-id let level-id in
              "    jmp     .level_" output-file fputs level-id output-file fputu output-file fputnl
              ".level_" output-file fputs start-id output-file fputu ":\n" output-file fputs

              40 malloc let new-level in
                new-level "creating a level object for 'else'" compile-procedure.check-null-here

                KEYWORD-ELSE         new-level      !64
                old-address          new-level 8  + !64
                token-address dcopy  new-level 16 + !64
                level-id             new-level 24 + !64
                copy-stack           new-level 32 + !64

                new-level levels-list list64.append
              end
            end
          end

          // Deallocate 'start-stack'.
          start-stack _local-stack.mfree
        end
      end

      // Deallocate level object.
      level mfree drop
    end

  else token-arg KEYWORD-WHILE = if
    // -------- Keyword 'while' --------
    // while <condition> do <any> end

    // Level structure:
    //  0- 7 -> KEYWORD-WHILE
    //  8-15 -> Starter address 
    // 16-23 -> Level ID
    // 24-31 -> Old stack

    // Branch should not be cut before 'while'.
    token-address "call 'while'" compile-procedure.check-branch-here

    local-stack local-stack-length @64 to-dynamic64 let copy-stack in
      copy-stack "creating a level object for 'while'" compile-procedure.check-null-here

      compile-procedure.new-level-id let level-id in
        convert-last-item-to-real

        ".level_" output-file fputs level-id output-file fputu ":\n" output-file fputs

        32 malloc let new-level in
          new-level "creating a level object for 'while'" compile-procedure.check-null-here

          KEYWORD-WHILE        new-level      !64
          token-address dcopy  new-level 8  + !64
          level-id             new-level 16 + !64
          copy-stack           new-level 24 + !64

          new-level levels-list list64.append
        end
      end
    end

  else token-arg KEYWORD-DO = if
    // -------- Keyword 'do' --------
    // while <condition> do <any> end

    // TODO: These are not implemented yet.
    // while <condition> do <any> [else <any>] end

    // Level structure:
    //  0- 7 -> KEYWORD-DO
    //  8-15 -> While address
    // 16-23 -> While label level ID
    // 24-31 -> Do address
    // 32-39 -> Unbroken loop end level ID
    // 40-47 -> Broken loop end level ID
    // 48-55 -> While stack
    // 56-63 -> Do stack

    // Branch should not be cut between 'while' and 'do'.
    token-address "call 'do'" compile-procedure.check-branch-here

    // Check if the local stack contains any item.
    local-stack-length @64 is-zero if
      LOG.ERR log-stream fputs "'do' requires a bool, there was no items in the stack.\n" log-stream fputs
      token-address compile-procedure.show-here
      ERROR-EXIT-CODE exit drop
    end

    // Remove the bool value from the local-stack.
    pop-item let item in
      item get-type INT-TYPE-BOOL != if        
        LOG.ERR log-stream fputs "'do' requires a bool.\n" log-stream fputs
        token-address compile-procedure.show-here
        ERROR-EXIT-CODE exit drop
      end

      item output-file convert-bool-to-real
      
      item mfree drop
    end

    // Get the 'while' level.
    levels-list list64.pop-last let old-level in
      old-level @64 old-level 8 + @64 let old-keyword old-address in
        // Check if the level type is 'while'.
        old-keyword old-address token-address "before 'do'" KEYWORD-WHILE compile-procedure.check-level-here

        old-level 16 + @64 old-level 24 + @64 let old-level-id old-stack in
          compile-procedure.new-level-id compile-procedure.new-level-id let unbroken-end-level-id broken-end-level-id in
            compile-procedure.new-level-id compile-procedure.new-level-id let unbroken-end-id broken-end-id in
              "    pop     rax\n"      output-file fputs
              "    test    rax, rax\n" output-file fputs
              "    jz      .level_"    output-file fputs unbroken-end-id output-file fputu output-file fputnl

              local-stack local-stack-length @64 to-dynamic64 let copy-stack in
                copy-stack "copying the stack for 'do'" compile-procedure.check-null-here

                64 malloc let new-level in
                  new-level "creating a level object for 'do' after 'while'" compile-procedure.check-null-here

                  KEYWORD-DO               new-level      !64
                  old-address              new-level 8  + !64
                  old-level-id             new-level 16 + !64
                  token-address dcopy      new-level 24 + !64
                  unbroken-end-id          new-level 32 + !64
                  broken-end-id            new-level 40 + !64
                  old-stack                new-level 48 + !64
                  copy-stack               new-level 56 + !64
                  new-level levels-list list64.append
                end
              end
            end
          end
        end
      end
    end        

  else token-arg KEYWORD-BREAK = if 
    // -------- Keyword 'break' -------
    // break

    // Branch should not be cut before 'break'.
    token-address "call 'break'" compile-procedure.check-branch-here

    levels-list list64.end-addr while dup levels-list list64.array-addr > do 8 - let level-addr in
      level-addr @64 @64 level-addr @64 8 + @64 let old-keyword old-address in
        old-keyword KEYWORD-DO = if
          level-addr @64 32 + @64 level-addr @64 24 + @64 level-addr @64 56 + @64 let broken-end-id do-address do-stack in
            // Check for the stack contents.
            do-stack do-address local-stack local-stack-length token-address log-stream check-stack-types

            convert-last-item-to-real
          
            "    jmp     .level_" output-file fputs broken-end-id output-file fputu output-file fputnl
          end

          0 branch-active !8
          0 break
        end
      end
    level-addr end end drop

    branch-active @8 isn-zero if
      LOG.ERR log-stream fputs "Expected a 'while-do' structure before 'break'.\n" log-stream fputs
      token-address compile-procedure.show-here
      ERROR-EXIT-CODE exit drop
    end

  else token-arg KEYWORD-MEMORY = if
    // -------- Keyword 'memory' -------
    // memory <name> <size> in <any> end

    // TODO: These are not implemented yet.
    // memory <name> <size> (and <name> <size>)* in <any> end

    // Level structure:
    //  0- 7 -> KEYWORD-MEMORY
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-31 -> Old local-memory-end

    // Branch should not be cut before 'memory'.
    token-address "call 'memory'" compile-procedure.check-branch-here

    // New names are stored in new-names and new-names-length queue. When the 'end' of 'memory' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) in
      16 list64.init let dynamic in
        dynamic "creating list dynamic object for 'memory'" compile-procedure.check-null-here

        dynamic new-names-list !64
      end

      // TODO: Add 'and' keyword.
      // TODO: Add proper pre-compilation for memory size.

      // Get the variable name.
      "a local variable name after 'memory'" false compile-procedure.get-next-token

      let memory-name-type memory-name-address memory-name-arg in
        // The token after 'memory' should be a 'name'.
        memory-name-type memory-name-address "after 'memory' for local variable name" TYPE-NAME compile-procedure.check-type-here

        // Get the variable size.
        "a local variable size after 'memory'" true compile-procedure.get-next-token

        let memory-size-type memory-size-address memory-size-arg in
          // The token after variable name should be an 'integer'.
          memory-size-type memory-size-address "after 'memory' for local variable size" TYPE-INTEGER compile-procedure.check-type-here

          "an 'end' after 'memory'" true compile-procedure.get-next-token

          let memory-end-type memory-end-address memory-end-arg in
            // The token after variable size should be a 'keyword'.
            memory-end-type memory-end-address "after 'memory'" TYPE-KEYWORD compile-procedure.check-type-here

            memory-end-arg KEYWORD-AND = if
              LOG.TODO log-stream fputs "'and' after 'memory' for local variable allocation is not implemented yet.\n" log-stream fputs
              memory-end-address compile-procedure.show-here
              ERROR-EXIT-CODE exit drop
            end

            // Check if the keyword is 'in'.
            memory-end-arg memory-end-address "after 'memory'" KEYWORD-IN compile-procedure.check-keyword-here

            memory-name-arg new-names-list list64.append
            memory-name-arg local-memory-end @64 local-names local-addresses locals-length str-map64.set if
              LOG.ERR log-stream fputs "Local variable '" log-stream fputs memory-name-arg memory-name-arg mlength log-stream fputs "' was already defined before.\n" log-stream fputs
              memory-name-address compile-procedure.show-here
              ERROR-EXIT-CODE exit drop
            end

            local-memory-end @64 memory-size-arg + local-memory-end !64

            // Deallocate 'memory-end-address'.
            memory-end-address mfree drop
          end

          // Deallocate 'memory-size-address'.
          memory-size-address mfree drop
        end

        // Deallocate 'memory-name-address'.
        memory-name-address mfree drop
      end

      local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

      32 malloc let new-level in
        new-level "creating a level object for 'memory'" compile-procedure.check-null-here

        KEYWORD-MEMORY                   new-level      !64
        token-address dcopy              new-level  8 + !64
        new-names-list list64.copy-array new-level 16 + !64
        local-memory-end @64             new-level 24 + !64

        new-level levels-list list64.append
      end

      // Deallocate 'new-names-list' but keep the 'memory' variable names.
      new-names-list list64.mfree drop
    end

  else token-arg KEYWORD-LET = if
    // -------- Keyword 'let' --------
    // let <name>* in <any> end

    // Level structure:
    //  0- 7 -> KEYWORD-LET
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-32 -> Old local-memory-end

    // Branch should not be cut before 'let'.
    token-address "call 'let'" compile-procedure.check-branch-here

    // New names are stored in new-names and new-names-length queue. When the 'end' of 'let' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) in
      16 list64.init let dynamic in
        dynamic "creating list dynamic object for 'let'" compile-procedure.check-null-here

        dynamic new-names-list !64
      end

      // Get the names of the 'let' variables.
      while true do
        // Get the name of the variable.
        "a 'name' for 'let' variable" false compile-procedure.get-next-token

        let new-token-type new-token-address new-token-arg in
          new-token-type TYPE-KEYWORD = if
            // If token is a keyword, it must be a 'in' keyword.
            new-token-arg new-token-address "after 'let'" KEYWORD-IN compile-procedure.check-keyword-here

            // Deallocate 'new-token-address'.
            new-token-address mfree drop

            // If the token is a 'in' keyword, break the loop.
            break
          end

          // Check the type of the token.
          new-token-type new-token-address "after 'let'" TYPE-NAME compile-procedure.check-type-here

          // TODO: Change the way that the variables are stored, so that we can also store their addresses.
          new-token-arg new-names-list list64.append

          // Deallocate 'new-token-address'.
          new-token-address mfree drop
        end
      end

      // This loop is separated from the one above, since this loop must run in the reverse order.
      new-names-list list64.length while dup isn-zero do dec let i in
        local-stack-length @64 is-zero if
          LOG.ERR log-stream fputs "Expected a data before 'let' variable, but the stack was empty.\n" log-stream fputs
          token-address compile-procedure.show-here
          ERROR-EXIT-CODE exit drop
        end

        convert-last-item-to-real

        // TODO: Save the type of the 'let' variable.

        // TODO: Change this part to something like this.
        // local-stack local-stack-length queue64.pop-last mfree drop
        local-stack local-stack-length queue64.pop-last drop

        i new-names-list list64.get let variable-name in
          // If the length of the variable name is 1 and its first letter is _.
          variable-name mlength 1 = if variable-name @8 '_' = else false end if
            "    pop     rax\n" output-file fputs
          else
            "    mov     rax, qword [local_ptr]\n" output-file fputs
            "    pop     qword [rax" output-file fputs local-memory-end @64 isn-zero if " + " output-file fputs local-memory-end @64 output-file fputu end "]\n" output-file fputs

            variable-name local-memory-end @64 let-names let-addresses let-vars-length str-map64.set if
              LOG.ERR log-stream fputs "'let' variable '" log-stream fputs variable-name dup mlength log-stream fputs "' was already defined before.\n" log-stream fputs

              // TODO: This does not show the address of the 'let' variable. This should be changed.
              token-address compile-procedure.show-here
              ERROR-EXIT-CODE exit drop
            end

            local-memory-end @64 8 + local-memory-end !64
          end
        end
      i end end drop

      local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

      32 malloc let new-level in
        new-level "creating a level object for 'let'" compile-procedure.check-null-here

        KEYWORD-LET                      new-level      !64
        token-address dcopy              new-level  8 + !64
        new-names-list list64.copy-array new-level 16 + !64
        local-memory-end @64             new-level 24 + !64

        new-level levels-list list64.append
      end

      // Deallocate 'new-names-list' but keep the 'let' variable names.
      new-names-list list64.mfree drop
    end

  else token-arg KEYWORD-RETURN = if
    // -------- Keyword 'return' --------

    // Branch should not be cut before 'return'.
    token-address "call 'return'" compile-procedure.check-branch-here

    output-array output-length
    token-address
    local-stack local-stack-length
    log-stream
    check-stack-types-types

    "    jmp     .return\n" output-file fputs

    0 branch-active !8

  else
    LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
    token-address compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end end end end end end end end end
end false end


proc compile-procedure
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // ptr: output-array int: output-length
  ptr int
  // file-desc: log-stream -- 
  file-desc --
  // local-memory-max: int
  int
  
  // Compiles a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let 
  source-name source-file output-file
  line-no char-no
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names macro-tokens macros-length
  procedure-name procedure-address
  local-stack local-stack-length
  extended-array extended-start extended-end
  output-types-array output-types-length
  log-stream
in
    
  "proc_" output-file fputs procedure-name output-file fput-alpha ":\n" output-file fputs

  memory levels-list      sizeof(ptr)      in

  // level-id-counter allows to create unique IDs for level labels.
  memory level-id-counter sizeof(int)      in

  // let-names, let-addresses and let-vars-length create a str_map64.
  memory let-names        LET-MAX-COUNT    in
  memory let-addresses    LET-MAX-COUNT    in
  memory let-vars-length  sizeof(int)      in
         
  // local-names, local-addresses and locals-length create a str_map64.
  memory local-names      LOCALS-MAX-COUNT in
  memory local-addresses  LOCALS-MAX-COUNT in
  memory locals-length    sizeof(int)      in

  // local-memory-end keeps track of the first available position on the local memory.
  memory local-memory-end sizeof(int)      in

  // local-memory-max keeps track of the maximum length of the local memory, to later allocate enough space.
  memory local-memory-max sizeof(int)      in

  // branch-active keeps track of if the branch of the code ended.
  memory branch-active    1                in

    16 list64.init let dynamic in
      dynamic "creating a list dynamic object" compile-procedure.check-null

      dynamic levels-list !64
    end

    0 level-id-counter !64
    0 let-vars-length  !64
    0 locals-length    !64
    0 local-memory-end !64
    0 local-memory-max !64
    
    0xff branch-active !8

    while true do
      "end of procedure or procedure definition" true compile-procedure.get-next-token

      let token-type token-address token-arg in
        // -- debug --
        // LOG.INFO log-stream fputs token-type token-arg log-stream fput-token log-stream fputnl
        // token-address log-stream fput-here

        token-type TYPE-INTEGER = if
          // -------- Constant integer --------

          // Branch should not be cut before integer immediate.
          token-address "push an integer" compile-procedure.check-branch-here

          token-arg push-int-immediate

        else token-type TYPE-STRING = if
          // -------- Strings --------

          // Branch should not be cut before string immediate.
          token-address "push a string" compile-procedure.check-branch-here
          
          INT-TYPE-INT push-real

          // TODO: Change this to GLOBAL ADDRESS DATA
          "    mov     rax, data_" output-file fputs data-definitions-list list64.length output-file fputu output-file fputnl
          "    push    rax\n" output-file fputs
          
          token-arg mlength dec push-int-immediate

          token-arg data-definitions-list list64.append

        else token-type TYPE-NAME = if
          // -------- Names --------

          // Branch should not be cut before name.
          token-address "calling a name" compile-procedure.check-branch-here
            
          token-arg let-names let-addresses let-vars-length str-map64.get if
            // -------- 'let' variables --------
                        
            let address in
              INT-TYPE-INT push-real
              
              "    mov     rax, qword [local_ptr]\n" output-file fputs
              
              "    push    qword [rax" output-file fputs address isn-zero if " + " output-file fputs address output-file fputu end "]\n" output-file fputs
            end
            
          else drop token-arg local-names local-addresses locals-length str-map64.get if
            // -------- local 'memory' variables --------
            
            let address in
              INT-TYPE-INT push-real
              
              "    push    qword [local_ptr]\n" output-file fputs
              
              address isn-zero if
                "    add     qword [rsp], " output-file fputs address output-file fputu output-file fputnl
              end
            end

          else drop token-arg global-names-array global-sizes-array globals-length str-map64.get if
            // -------- global 'memory' variables --------

            let address in
              INT-TYPE-INT MODE-GLOBAL create-stack-item let item in
                token-arg item set-arg1

                item push-item
              end
            end

          else drop token-arg proc-names-array proc-names-array procs-length @64 8 * + str-sorted8.available if
            // -------- 'proc' calls --------
            
            let name-address in name-address proc-names-array - let delta in
              delta proc-inputs-array + delta proc-outputs-array + let input-address output-address in
                convert-last-item-to-real

                input-address @64 input-address @64 mlength 8 /
                token-address
                local-stack local-stack-length
                log-stream
                check-sub-stack-types-types

                0 while dup output-address @64 mlength 8 / < do let i in                    
                  i output-address @64 array64.get let output in
                    output push-real
                  end
                i end inc end drop

                compile-procedure.new-level-id let level-id in
                  "    xchg    rsp, [call_ptr]\n"              output-file fputs         
                  "    push    .level_"                        output-file fputs level-id output-file fputu output-file fputnl
                  "    push    qword [local_ptr]\n"            output-file fputs         
                  "    add     qword [local_ptr], "            output-file fputs local-memory-end @64 output-file fputu output-file fputnl
                  "    xchg    rsp, [call_ptr]\n"              output-file fputs         
                  "    jmp     proc_"                          output-file fputs token-arg output-file fput-alpha output-file fputnl
                  ".level_"                                    output-file fputs level-id output-file fputu ":\n" output-file fputs
                end
              end
            end end
            
          else drop
            // TODO: Add Levenshtein distance algoritm to show the nearest matchs; which can be definitions, macros, procedures, keywords and intrinsics.
            
            LOG.ERR log-stream fputs "Name '" log-stream fputs token-arg token-arg mlength log-stream fputs "' is not defined as a local variable or a macro.\n" log-stream fputs
            token-address compile-procedure.show-here
            ERROR-EXIT-CODE exit drop
          end end end end

        else token-type TYPE-INTRINSIC = if
          // -------- Intrinsics --------

          // Branch should not be cut before calling an intrinsic.
          token-address "calling an intrinsic" compile-procedure.check-branch-here
          
          source-name source-file output-file
          line-no char-no
          procedure-name procedure-address
          local-stack local-stack-length
          token-type token-address token-arg
          log-stream
          compile-intrinsic

        else token-type TYPE-KEYWORD = if          
          // -------- Keywords --------

          source-name source-file output-file
          line-no char-no
          macro-names macro-tokens macros-length
          procedure-name procedure-address
          local-stack local-stack-length
          extended-array extended-start extended-end
          token-type token-address token-arg
          levels-list level-id-counter
          local-names local-addresses locals-length
          local-memory-end
          let-names let-addresses let-vars-length
          branch-active
          output-types-array output-types-length
          log-stream
          local-memory-max
          compile-keyword if local-memory-max @64 return end

        else
          LOG.ERR log-stream fputs "Unexpected type while expecting a keyword, an intrinsic, a string or an integer, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
          token-address compile-procedure.show-here
          ERROR-EXIT-CODE exit drop
        end end end end end

        // Deallocate the space allocated for token-address.
        token-address mfree drop
      end
    end

    // Deallocate 'levels-list'.
    levels-list list64.mfree-deep drop
  end end end end end end end end end end end
end 0 end // dummy return


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.get-next-token let
  expect-address expect-length extend-macros
in
  // str: expect-message bool: extend-macros --
  // int: token-type ptr: address [int|ptr]: arg

  source-name source-file
  line-no char-no
  extended-array extended-start extended-end
  macro-names macro-tokens macros-length
  log-stream extend-macros isn-zero get-next-token ! if
    LOG.ERR log-stream fputs "Reached EOF while expecting " log-stream fputs expect-address expect-length log-stream fputs log-stream fputnl
    ERROR-EXIT-CODE exit drop
  end
end endmacro
 

// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-type let _token_type_ expect-address expect-length expected-token-type in
  expected-token-type _token_type_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-type log-stream fput-type  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_type_ log-stream fput-type "'.\n" log-stream fputs
    
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-type-here let _token_type_ _token_addr_ expect-address expect-length expected-token-type in
  expected-token-type _token_type_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-type log-stream fput-type  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_type_ log-stream fput-type "'.\n" log-stream fputs

    _token_addr_ log-stream fput-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-keyword let _token_arg_ expect-address expect-length expected-token-arg in
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs
    
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-keyword-here let _token_arg_ _token_addr_ expect-address expect-length expected-token-arg in
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs

    _token_addr_ log-stream fput-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-null let expect-address expect-length in
  is-null if
    LOG.ERR log-stream fputs "malloc failed while " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs
    
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-null-here let expect-address expect-length in
  is-null if
    LOG.ERR log-stream fputs "malloc failed while " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs

    token-address log-stream fput-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


proc compile-file
  // ptr: source-name file-desc: output-file
  ptr file-desc
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // include-paths-set
  ptr
  // libraries-set
  ptr 
  // file-desc: log-stream
  file-desc --
  
  // Compiles a Corth source file.
  // Compilation warning and errors are dumped to log-stream.

  // TODO: Add called-from to improve debugging.
in let
  source-name output-file
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names macro-tokens macros-length
  include-paths-set
  libraries-set
  log-stream
in
  // Check if the library was included already.
  source-name libraries-set str-set8.add ! if return end
  
  // Open the source file.
  source-name fopen-r let source-file in
    // Check if the source is opened.
    source-file isn-pos if
      LOG.ERR log-stream fputs "Could not open source file '" log-stream fputs source-name source-name mlength dec log-stream fputs "'\n" log-stream fputs
      ERROR-EXIT-CODE exit drop
    end
    
    // -- debug --
    // NOTE: This appears to make the program faster?
    // source-name dup mlength log-stream fputs log-stream fputnl

    memory extended-array  EXTENDED-MAX-LENGTH in
    memory extended-start  sizeof(int)         in
    memory extended-end    sizeof(int)         in
           
    memory line-no         sizeof(int)         in
    memory char-no         sizeof(int)         in

      // Reset extended-tokens.
      0 extended-start !64
      0 extended-end   !64

      // Reset line-no and char-no variables.
      1 line-no !64
      0 char-no !64

      // Get next token and check if there is one available.
      while source-name source-file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream true get-next-token do
        let token-type token-address token-arg in
          token-type token-address "" TYPE-KEYWORD compile-file.check-type-here
                
          // -------- Global keywords --------
          token-arg KEYWORD-INCLUDE = if
            // -------- Keyword 'include' -------- 
            // TODO: Create a function to include.
            // TODO: Allow including packages.

            // Get the next token, which should be the include path.
            "a 'name' for include path" false compile-file.get-next-token

            let path-token-type path-token-address path-token-arg in
              path-token-type path-token-address "as path after 'include'" TYPE-NAME compile-file.check-type-here
              memory found 1 in
                0 found !8
                
                0 while dup include-paths-set list64.length < do let i in
                  i include-paths-set list64.get let directory in
                    directory cstr.str path-token-arg path-token-arg mlength path.merge2-cstr let include-path in    
                      // Check if the user has the required permissions.
                      memory stats sizeof(stat) in
                        include-path stats stat drop

                        // Check if user has access to the path.
                        include-path R_OK access is-zero if
                          // Mark as found.
                          0xff found !8

                          stats 24 + @64 S_IFMT && let masked in
                            masked S_IFREG = if
                              // File including, call compile-file on the file.
                              include-path output-file
                              data-definitions-list
                              global-names-array global-sizes-array globals-length
                              proc-names-array proc-inputs-array proc-outputs-array procs-length
                              macro-names macro-tokens macros-length
                              include-paths-set
                              libraries-set
                              log-stream compile-file

                            else masked S_IFDIR = if
                              // Directory including, should include all sub paths.
                              LOG.TODO log-stream fputs "Including directories is not implemented yet.\n" log-stream fputs
                              path-token-address log-stream fput-here
                              ERROR-EXIT-CODE exit drop

                            else
                              LOG.ERR log-stream fputs "Invalid file type, got " log-stream fputs masked log-stream fputo ".\n" log-stream fputs
                              path-token-address log-stream fput-here
                              ERROR-EXIT-CODE exit drop
                            end end
                          end
                          
                          i break
                        end
                      end

                      // Deallocate 'include-path'.
                      include-path mfree drop
                    end
                  end
                i end inc end drop

                // Check if any library is found.
                found @64 is-zero if
                  LOG.ERR log-stream fputs "Could not find library '" log-stream fputs path-token-arg dup mlength log-stream fputs "'.\n" log-stream fputs
                  path-token-address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                end
              end
            end

          else token-arg KEYWORD-MEMORY = if
            // -------- Keyword 'memory' --------

            // Get the next token, which sould be the include path.
            "a 'name' after 'memory' while defining a global varible" false compile-file.get-next-token

            let memory-name-type memory-name-address memory-name-arg in
              memory-name-type memory-name-address "as global variable name after 'memory'" TYPE-NAME compile-file.check-type-here

              // TODO: Implement size calculation.
              "size after 'memory' while defining a global varible" true compile-file.get-next-token

              let memory-size-type memory-size-address memory-size-arg in
                memory-size-type memory-size-address "as global variable size after 'memory'" TYPE-INTEGER compile-file.check-type-here

                // Get the next keyword, which should be an 'end' keyword.
                "an 'end' after 'memory' while defining a global varible" true compile-file.get-next-token

                // Check the token type and keyword.
                // Add 'and' keyword.
                let end-token-type end-token-address end-token-arg in
                  end-token-type end-token-address "after 'memory' while defining a global variable" TYPE-KEYWORD compile-file.check-type-here
                  
                  end-token-arg KEYWORD-AND = if
                    LOG.TODO log-stream fputs "'and' after 'memory' for global variable allocation is not implemented yet.\n" log-stream fputs
                    end-token-address log-stream fput-here
                    ERROR-EXIT-CODE exit drop
                  end
                  
                  end-token-arg end-token-address "after 'memory' while defining a global variable" KEYWORD-END compile-file.check-keyword-here

                  // Deallocate 'end-token-address'.
                  end-token-address mfree drop
                end

                // TODO: Check if the global variable queue was filled.
                memory-name-arg memory-size-arg global-names-array global-sizes-array globals-length str-map64.set drop

                // Deallocate 'memory-size-address'.
                memory-size-address mfree drop
              end

              // Deallocate 'memory-name-address'.
              memory-name-address mfree drop
            end

          else token-arg KEYWORD-MACRO = if
            // -------- Keyword 'macro' --------

            // Get the next token, which should be the name of the macro.
            "a 'name' after 'macro'" false compile-file.get-next-token

            let macro-name-token-type macro-name-token-address macro-name-token-arg in
              macro-name-token-type macro-name-token-address "as macro name after 'macro'" TYPE-NAME compile-file.check-type-here

              // macro-tokens and macro-tokens-length are used to create a QUEUE for macro tokens.
              memory macro-tokens-list sizeof(ptr) in
                16 list64.init let dynamic in
                  dynamic "creating list dynamic object for 'macro'" compile-file.check-null-here

                  dynamic macro-tokens-list !64
                end

                while true do
                  // Get next tokens, until an 'endmacro' is found.
                  "an 'endmacro' after 'macro'" false compile-file.get-next-token

                  let macro-new-token-type macro-new-token-address macro-new-token-arg in
                    // If the token is an 'endmacro' keyword, break the loop.
                    macro-new-token-type TYPE-KEYWORD = if
                      macro-new-token-arg KEYWORD-ENDMACRO = if
                        break
                      end
                    end

                    // Add the token attributes to the macro-tokens-list.
                    macro-new-token-type    macro-tokens-list list64.append
                    macro-new-token-address macro-tokens-list list64.append
                    macro-new-token-arg     macro-tokens-list list64.append
                  end
                end

                // TODO: Check if the macros queue was filled.
                macro-name-token-arg macro-tokens-list list64.copy-array macro-names macro-tokens macros-length str-map64.set drop

                // Deallocate 'macro-tokens-list'.
                macro-tokens-list list64.mfree drop
              end

              // Deallocate 'macro-name-token-address'.
              macro-name-token-address mfree drop
            end

          else token-arg KEYWORD-PROC = if
            // -------- 'proc' keyword --------

            // Get the next token, which should be the name of the procedure.
            "a 'name' after 'proc'" false compile-file.get-next-token
            
            let proc-name-token-type proc-name-token-address proc-name-token-arg in
              proc-name-token-type proc-name-token-address "as procedure name after 'procedure'" TYPE-NAME compile-file.check-type-here

              memory input-list sizeof(ptr) in
              memory output-list sizeof(ptr) in

                // TODO: Check if the dynamic object is NULLPTR or not.
                16 list64.init input-list !64
                16 list64.init output-list !64

                // Get the input types.
                while true do
                  // Get the token.
                  "a 'type' after 'proc' for input" true compile-file.get-next-token

                  let input-token-type input-token-address input-token-arg in
                    input-token-type TYPE-KEYWORD = if
                      // If the token was a keyword, it must be a 'KEYWORD-RETURN'.
                      input-token-arg input-token-address "after 'proc' inputs" KEYWORD-RETURNS compile-file.check-keyword-here

                      // Deallocate 'input-token-address'.
                      input-token-address mfree drop

                      // If the token was a 'KEYWORD-RETURNS', break the loop.
                      break
                    end

                    // Check if the token is of type-type.
                    input-token-type input-token-address "after 'proc'" TYPE-INT-TYPE compile-file.check-type-here

                    input-token-arg input-list list64.append

                    // Deallocate 'input-token-address'.
                    input-token-address mfree drop
                  end
                end

                // Get the output types.
                while true do
                  // Get the token.
                  "a 'type' after 'proc' for output" true compile-file.get-next-token

                  let output-token-type output-token-address output-token-arg in
                    output-token-type TYPE-KEYWORD = if
                      // If the token is a keyword, it must be a 'KEYWORD-IN'.
                      output-token-arg output-token-address "after 'proc' outputs" KEYWORD-IN compile-file.check-keyword-here

                      // Deallocate 'output-token-address'.
                      output-token-address mfree drop

                      // If the token was a 'KEYWORD-IN', break the loop.
                      break
                    end

                    // Check if the token is of type-type.
                    output-token-type output-token-address "after '--'" TYPE-INT-TYPE compile-file.check-type-here

                    output-token-arg output-list list64.append

                    // Deallocate 'output-token-address'.
                    output-token-address mfree drop
                  end
                end

                // Store the procedure name, input and outputs.
                // Check if the procedure was defined already.
                proc-name-token-arg proc-names-array proc-names-array procs-length @64 8 * + str-sorted8.available if
                  drop
                  LOG.ERR log-stream fputs "Procedure '" log-stream fputs proc-name-token-arg proc-name-token-arg mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                  proc-name-token-address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                  return
                end

                let name-address in
                  name-address proc-names-array - let delta in
                    proc-inputs-array delta + proc-outputs-array delta + let input-address output-address in
                      // Shift the array to insert the name, input and output.
                      name-address   name-address   8 + procs-length @64 name-address   proc-names-array   - 8 / - memcpy64i
                      input-address  input-address  8 + procs-length @64 input-address  proc-inputs-array  - 8 / - memcpy64i
                      output-address output-address 8 + procs-length @64 output-address proc-outputs-array - 8 / - memcpy64i

                      // Save the name, inputs and outputs of the procedure.
                      proc-name-token-arg             dcopy name-address   !64
                      input-list          list64.copy-array input-address  !64 
                      output-list         list64.copy-array output-address !64

                      procs-length @inc64
                    end
                  end
                end

                // Create the stack for the procedure.
                memory local-stack        STACK-MAX-ITEMS in
                memory local-stack-length sizeof(int)     in

                  0 local-stack-length !64

                  0 while dup input-list list64.length < do let i in
                    i input-list list64.get let type in
                      type push-real
                    end
                  i end inc end drop

                  source-name source-file output-file
                  line-no char-no
                  data-definitions-list
                  global-names-array global-sizes-array globals-length
                  proc-names-array proc-inputs-array proc-outputs-array procs-length
                  macro-names macro-tokens macros-length
                  proc-name-token-arg proc-name-token-address
                  local-stack local-stack-length
                  extended-array extended-start extended-end
                  output-list list64.to-array
                  log-stream
                  compile-procedure drop

                  ".return:\n"                        output-file fputs
                  "    xchg    rsp, [call_ptr]\n"     output-file fputs
                  "    pop     qword [local_ptr]\n"   output-file fputs
                  "    pop     rax\n"                 output-file fputs
                  "    xchg    rsp, [call_ptr]\n"     output-file fputs
                  "    jmp     rax\n"                 output-file fputs
                end end

                // Deallocate input-list and output-list.
                input-list  list64.mfree drop
                output-list list64.mfree drop
              end end 
            end
          else
            LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
            token-address log-stream fput-here
            ERROR-EXIT-CODE exit drop
          end end end end
        end
      end drop drop drop
    end end end end end
    
    source-file fclose drop
  end
end end


proc compile-nasm
  // ptr: source-name ptr: output-name ptr: include-paths-set file-desc: log-stream --
  ptr ptr ptr file-desc --
in let source-name output-name include-paths-set log-stream in
  // Remove the output file.
  output-name unlink drop

  // Create the output file.
  output-name 0o777 creat dup isn-pos if
    LOG.ERR log-stream fputs "Could not create output file '" log-stream fputs output-name output-name mlength log-stream fputs "'.\n" log-stream fputs
    ERROR-EXIT-CODE exit drop
  end

  let output-file in
    // Check if the file is opened successfully.
    output-file isn-pos if
      LOG.ERR log-stream fputs "Could not open output file '" log-stream fputs output-name output-name mlength log-stream fputs "'.\n" log-stream fputs
      ERROR-EXIT-CODE exit drop
    end

    "segment .text\n"                                   output-file fputs
    "global _start\n"                                   output-file fputs

    "_start:\n"                                         output-file fputs
    "    mov     qword [call_ptr], call_stack\n"        output-file fputs
    "    add     qword [call_ptr], 0x4000\n"            output-file fputs
    "    mov     qword [local_ptr], local_memory\n"     output-file fputs

    "    xchg    rsp, [call_ptr]\n"                     output-file fputs
    "    push    corth_endofprogram\n"                  output-file fputs
    "    push    qword [local_ptr]\n"                   output-file fputs
    "    xchg    rsp, [call_ptr]\n"                     output-file fputs

    "    mov     rax, [rsp]\n"                          output-file fputs
    "    mov     rbx, rsp\n"                            output-file fputs
    "    add     rbx, 8\n"                              output-file fputs
    "    mov     rdx, rax\n"                            output-file fputs
    "    shl     rdx, 3\n"                              output-file fputs
    "    sub     rsp, rdx\n"                            output-file fputs
    "    push    rax\n"                                 output-file fputs
    "    push    rbx\n"                                 output-file fputs

    "    jmp     proc_main\n"                           output-file fputs

    "corth_endofprogram:\n"                             output-file fputs
    "    mov     rax, 60\n"                             output-file fputs
    "    pop     rdi\n"                                 output-file fputs
    "    syscall\n"                                     output-file fputs

    memory global-names-array     GLOBALS-MAX-COUNT in
    memory global-sizes-array     GLOBALS-MAX-COUNT in
    memory globals-length         sizeof(int)       in

    memory proc-names-array       PROCS-MAX-COUNT   in
    memory proc-inputs-array      PROCS-MAX-COUNT   in
    memory proc-outputs-array     PROCS-MAX-COUNT   in
    memory procs-length           sizeof(int)       in

    memory macro-names            MACROS-MAX-COUNT  in
    memory macro-tokens           MACROS-MAX-COUNT  in
    memory macros-length          sizeof(int)       in

    memory data-definitions-list  sizeof(ptr)       in

    memory libraries-set          sizeof(ptr)       in

      0 globals-length   !64
      0 procs-length     !64
      0 macros-length    !64

      16 list64.init let dynamic in
        dynamic "creating a list dynamic object for data-definitions-list" compile-file.check-null
        
        dynamic data-definitions-list !64
      end

      16 list64.init let dynamic in
        dynamic "creating a list dynamic object for libraries-set.\n" compile-file.check-null
        
        dynamic libraries-set !64
      end

      source-name output-file
      data-definitions-list
      global-names-array global-sizes-array globals-length
      proc-names-array proc-inputs-array proc-outputs-array procs-length
      macro-names macro-tokens macros-length
      include-paths-set
      libraries-set
      log-stream
      compile-file

      // Deallocate space allocated for procedures.
      0 while dup procs-length @64 < do let i in
        i proc-names-array   array64.get mfree drop
        i proc-inputs-array  array64.get mfree drop
        i proc-outputs-array array64.get mfree drop
      i end inc end drop

      // Deallocate space allocated for macros.
      0 while dup macros-length @64 < do let i in
        i macro-names array64.get mfree drop

        i macro-tokens array64.get let tokens in
          0 while dup tokens mlength 24 / < do let j in
            j tokens array64.get j inc tokens array64.get j 2 + tokens array64.get let token-type token-address token-arg in
              // Deallocate 'token-address'.
              token-address mfree drop

              // Deallocate 'token-arg' if the token is either a 'name' or a 'string'.
              token-type TYPE-NAME = token-type TYPE-STRING = | if
                token-arg mfree drop
              end
            end
          j end 3 + end drop

          // Deallocate 'tokens'.
          tokens mfree drop
        end
      i end inc end drop

      // Deallocate the space allocated for libraries-set.
      libraries-set list64.mfree-deep drop

      "segment .data\n" output-file fputs
      0 while dup data-definitions-list list64.length < do let i in
        "    data_" output-file fputs i output-file fputu ": db " output-file fputs
        i data-definitions-list list64.get let data in
          0 while dup data mlength < do let j in
            j data + @8 output-file fputu ", " output-file fputs
          j end inc end drop
        end
        output-file fputnl
      i end inc end drop

      // Deallocate the space allocated for data-definitions-list
      data-definitions-list list64.mfree-deep drop
      
      "segment .bss\n"                                    output-file fputs
      "    local_memory:   resb 67108864\n"               output-file fputs
      "    local_ptr:      resq 1\n"                      output-file fputs
      "    call_stack:     resb 67108864\n"               output-file fputs
      "    call_ptr:       resq 1\n"                      output-file fputs

      0 while dup globals-length @64 < do let i in
        i global-names-array array64.get i global-sizes-array array64.get let variable-name variable-size in
          "    global_"  output-file fputs
          i global-names-array array64.get output-file fput-alpha
          ": resb " output-file fputs
          variable-size output-file fputu
          output-file fputnl

          // Deallocate the name of the variable.
          variable-name mfree drop
        end
      i end inc end drop
    end end end end end end end end end end end end

    output-file fclose drop
  end
end end




/*

Name definitions:
  Public:
    Global variables
    Macros
    Procedures

  Private:
    Local variables
    Let variables

Syscall register arguments:
  %rdi %rsi %rdx %r10 %r8 %r9
*/
