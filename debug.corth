include libs/linux_x86/io.corth

include libs/dynamic/utils.corth

include enums.corth

macro sizeof(address) 56 endmacro

macro ADDR.FILE  0  endmacro
macro ADDR.START 8  endmacro
macro ADDR.END   32 endmacro

macro POS.LINE   0  endmacro
macro POS.CHAR   8  endmacro
macro POS.AT     16 endmacro

macro LOG.RESET "\x1b[0;97m"                     endmacro
macro LOG.ERR   "\x1b[1;31m[ERROR] "             endmacro
macro LOG.INFO  "\x1b[1;97m[INFO]\x1b[0;97m "    endmacro
macro LOG.CMD   "\x1b[1;32m[CMD]\x1b[0;32m "     endmacro
macro LOG.TODO  "\x1b[1;35m[TODO] "              endmacro
macro LOG.WARN  "\x1b[1;33m[WARNING]\x1b[0;33m " endmacro
macro LOG.HERE  "\x1b[1;32m[HERE] "              endmacro
macro LOG.LINE  "\x1b[0;37m"                     endmacro


// TODO: Create procedures that can check the type and argument of the tokens.

proc generate-address
  // ptr: file-name int: start-line int: start-char int: start-at int: end-line int: end-char int: end-at file-desc: log-stream -- ptr: address
  ptr int int int int int int file-desc -- ptr
  // Returns a dynamicly-placed object to store the address of token.
in let log-stream in
  sizeof(address) malloc let address in
    address is-null if
      LOG.ERR log-stream fputs "'malloc' failed while generating address.\n" log-stream fputs LOG.RESET log-stream fputs
      1 call-sys-exit
    end

    // Store the arguments.
    address ADDR.END   + POS.AT   + !64
    address ADDR.END   + POS.CHAR + !64
    address ADDR.END   + POS.LINE + !64
    address ADDR.START + POS.AT   + !64
    address ADDR.START + POS.CHAR + !64
    address ADDR.START + POS.LINE + !64
    address ADDR.FILE  + !64

    // Return the address.
    address
  end
end end


proc fput-position
  // ptr: position file-desc: file-desc
  ptr file-desc --
  // Prints a position.
in let position file in
  position POS.LINE + @64 file fputu ":" file fputs position POS.CHAR + @64 file fputu " (" file fputs position POS.AT + @64 file fputu ")" file fputs
end end


proc seek-line
  // int: line file-desc: file-desc
  int file-desc --
  // Shifts the file pointer by a specified amount of lines.
in let file in
  memory char 1 in
    while dup isn-zero do
      // If EOF is reached, returns immediately.
      char 1 file fgets is-zero if drop return end

      // If a newline is reached, decrease the counter.
      char @8 CHAR-NEWLINE = if dec end
    end drop
  end
end end


proc fput-line
  // file-desc: source file-desc: file-desc -- int: line-length
  file-desc file-desc -- int
  // Keeps printing until a newline is found.
  // Returns the length of line read.
in let source file in
  memory char 1 in
    0 while true do
      // If EOF is reached, returns immediately.
      char 1 source fgets is-zero if return end

      char @8 CHAR-NEWLINE = if
        return
      else
        // Print the byte to the file stream.
        char 1 file fputs
        
        // Increase the length counter.
        inc
      end
    end
  end
end end


proc fputu-full
  // int: int file-desc: file-desc 
  int file-desc --
  // Prints an unsigned integer to a file stream.
  // The length of string is guaranteed to be 20. Missing length is filled with spaces from the left.
in let file in
  memory buffer     20          and
         value      sizeof(int) and
         buffer-end sizeof(ptr) in

    // TODO: This can be improved by only setting the unused space.
    buffer 20 CHAR-SPACE memset8

    value !64
    buffer 19 + buffer-end !64

    while
      value @64 10 /%
      int-to-dec-digit buffer-end @64 !8
      buffer-end @dec64
    dup value !64 isn-zero do end

    buffer 20 file fputs
  end
end end


proc fputs-multiple
  // int: times ptr: start int: length file-desc: file-desc
  int ptr int file-desc --
  // Prints a byte collection to a file stream multiple times.
in let start length file in
  while dup isn-zero do
    start length file fputs
  dec end drop
end end


proc fput-address
  // ptr: address file-desc: log-stream
  ptr file-desc --
  // Prints the formatted address of a token.
in let address log-stream in
  address @64 address ADDR.START + address ADDR.END + let file-name start-pos end-pos in
    "from file '" log-stream fputs file-name dup mlength log-stream fputs "' between [" log-stream fputs start-pos log-stream fput-position "] to [" log-stream fputs end-pos log-stream fput-position "]" log-stream fputs
  end
end end


proc fput-lines
  // ptr: address file-desc: log-stream
  ptr file-desc --
  // Prints the formatted lines of a token.
in let address log-stream in
  address @64 address ADDR.START + address ADDR.END + let file-name start-pos end-pos in
    // Add a null character for fopen
    file-name add-null let c-file-name in
      c-file-name fopen-read c-file-name mfree
    end

    // Open the source file.
    let file in
      // Check if file could be opened.
      file isn-pos if
        "<file-unavailable>\n" log-stream fputs
      end

      start-pos POS.LINE + @64 start-pos POS.CHAR + @64 end-pos POS.LINE + @64 end-pos POS.CHAR + @64 let start-line start-char end-line end-char in

        // Move the file pointer to the start.
        file 0 SEEK-SET fseek drop start-line dec file seek-line

        start-line end-line = if
          start-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line "\n" log-stream fputs let length in
            "                      " log-stream fputs start-char " " log-stream fputs-multiple end-char start-char - "~" log-stream fputs-multiple "\n" log-stream fputs
          end
        else
          start-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line "\n" log-stream fputs let length in
            "                      " log-stream fputs start-char " " log-stream fputs-multiple length start-char - "~" log-stream fputs-multiple "\n" log-stream fputs
          end

          start-line inc while dup end-line < do let line-no in
            line-no log-stream fputu-full ": " log-stream fputs file log-stream fput-line "\n" log-stream fputs let length in
              "                      " log-stream fputs length "~" log-stream fputs-multiple "\n" log-stream fputs
            end
          line-no end inc end drop

          end-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line "\n" log-stream fputs let length in
            "                      " log-stream fputs end-char "~" log-stream fputs-multiple "\n" log-stream fputs
          end
        end

        // Close the file.
        file fclose drop
      end
    end
  end
end end


proc fput-here
  // ptr: address file-desc: log-stream --
  ptr file-desc --
in let address log-stream in
  LOG.HERE log-stream fputs address log-stream fput-address ":\n" log-stream fputs
  LOG.LINE log-stream fputs address log-stream fput-lines LOG.RESET log-stream fputs
end end


proc fput-inside-procedure
  // ptr: procedure-name ptr: procedure-address file-desc: log-stream
  ptr ptr file-desc --
in let name address log-stream in
  LOG.INFO log-stream fputs "Inside procedure '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
  address log-stream fput-here
end end
