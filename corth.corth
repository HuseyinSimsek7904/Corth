include libs/linux_x86/io.corth
include libs/linux_x86/sys.corth

macro malloc.ARRAY-SIZE           0x40000 endmacro
macro malloc.AVAIL-QUEUE-SIZE     0x1000  endmacro
include libs/dynamic/malloc.corth
include libs/dynamic/utils.corth

include libs/memory.corth

include libs/collections/queue64.corth
include libs/collections/str_map64.corth

macro CHAR-NULL      0  endmacro
macro CHAR-NEWLINE   10 endmacro
macro CHAR-ESCAPE    27 endmacro
macro CHAR-SPACE     32 endmacro
macro CHAR-DQUOTE    34 endmacro
macro CHAR-ASTERISK  42 endmacro
macro CHAR-SLASH     47 endmacro
macro CHAR-BACKSLASH 92 endmacro
macro CHAR-SQUOTE    96 endmacro

include debug.corth
include enums.corth


// TODO: Make not hard-coded
macro SOURCE-NAME "./example.corth" endmacro
macro OUTPUT-NAME "./o.asm" endmacro

macro GLOBALS-MAX-COUNT   0x4000 endmacro
macro MACROS-MAX-COUNT    0x4000 endmacro
macro LIBRARIES-MAX-COUNT 0x4000 endmacro
macro LEVELS-MAX-COUNT    0x100  endmacro
macro LET-MAX-COUNT       0x400  endmacro
macro LOCALS-MAX-COUNT    0x400  endmacro
macro VARS-MAX-ONCE       0x10   endmacro

macro TOKEN-MAX-LENGTH    0x4000 endmacro
macro MACRO-MAX-TOKENS    0x4000 endmacro
macro PROC-MAX-IO         0x100  endmacro
macro STACK-MAX-ITEMS     0x100  endmacro

macro LOCAL-MEMORY-SIZE   0X4000 endmacro
macro CALL-STACK-SIZE     0x4000 endmacro


proc fread
  // ptr: start int: length file-desc: file-desc
  ptr int file-desc -- int
  // Reads a region of a file stream and returns file pointer to its original position.
in let start length file in
  // Get original position.
  file ftell let original in
  
    // Read bytes and return the total bytes read.
    start length file fgets

    // Return the file pointer to its original pointer.
    file original SEEK-SET fseek drop
  end
end end


proc strip-file
  // file-desc: file ptr: line-no ptr: char-no -- bool: reached-eof
  file-desc ptr ptr -- bool
  // Removes the newline and spaces from the start of a file stream
  // Keeps track the line and char number as the bytes are read.
  // Also, checks if EOF is reached.
in let file line-no char-no in
  memory char 1 in
    while true do
      char 1 file fgets is-zero if
        true return
      else char @8 CHAR-NEWLINE = if
        0 char-no !64
        line-no @inc64
      else char @8 CHAR-SPACE = if
        char-no @inc64
      else
        file 1 neg SEEK-CUR fseek drop
        false return
      end end end
    end
  end
end false end  // dummy return


proc parse-next-token
  // file-desc: file-desc ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream --
  file-desc ptr ptr ptr ptr file-desc --
  // Gets the next token string before any newline or space and fills a buffer.
  // Keeps track of the line and char number as the bytes are read.
  // NOTE: If buffer-end exceeds buffer + TOKEN-MAX-LENGTH, exits program.
in let file line-no char-no buffer buffer-end log-stream in
    while true do
      buffer-end @64 1 file fread is-zero if                // Reached end of file.
        char-no @inc64
        return
      else buffer-end @64 @8 CHAR-NEWLINE = if              // Reached newline.
        char-no @inc64
        return
      else buffer-end @64 @8 CHAR-SPACE = if                // Reached space.
        char-no @inc64
        return
      else buffer-end @64 buffer - TOKEN-MAX-LENGTH >= if   // Reached the end of the buffer.
        LOG.ERR log-stream fputs "Found a token longer than TOKEN-MAX-LENGTH, stopping execution.\n" log-stream fputs
        1 call-sys-exit
      else                                                  // There is still space in the buffer.
        file 1 SEEK-CUR fseek drop
        buffer-end @inc64
        char-no    @inc64
      end end end end
    end
end end


proc parse-next-string
  // file-desc: file-desc ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream --
  file-desc ptr ptr ptr ptr file-desc --
  // Gets the next string before a double quote.
  // Keeps track of the line and char number as the bytes are read.
  // NOTE: If buffer-end exceeds buffer + TOKEN-MAX-LENGTH, exits program.
  // NOTE: If EOF is reached before a double quote is found, exits program.
  // TODO: Add escapes.
in let file line-no char-no buffer buffer-end log-stream in
  while true do
    buffer-end @64 1 file fgets is-zero if                  // Reached end of file.
      LOG.ERR log-stream fputs "Reached EOF before finding any '\"'.\n" log-stream fputs
      1 call-sys-exit
    else buffer-end @64 @8 CHAR-DQUOTE = if                 // Reached double quote.
      char-no    @inc64
      return
    else buffer-end @64 buffer - TOKEN-MAX-LENGTH >= if     // Reached the end of the buffer.
      LOG.ERR log-stream fputs "Found a string longer than TOKEN-MAX-LENGTH, stopping execution.\n" log-stream fputs
      1 call-sys-exit
    else buffer-end @64 @8 CHAR-NEWLINE = if                // Reached new line.
      buffer-end @inc64
      line-no    @inc64
      0 char-no !64
    else                                                   
      buffer-end @inc64
      char-no    @inc64
    end end end end
  end
end end


proc skip-line
  // file-desc: file-desc ptr: line-no ptr: char-no file-desc: log-stream --
  file-desc ptr ptr file-desc --
  // Moves the file pointer until it passes a newline, or EOF is reached.
  // Keeps track of the line and char number as the bytes are read.
in let file line-no char-no log-stream in
  line-no @inc64
  0 char-no !64
  
  memory char 1 in
    while true do
      char 1 file fgets is-zero if
        return
      else char @8 CHAR-NEWLINE = if
        return
      end end
    end
  end
end end


proc skip-block-comment
  // file-desc: file-desc ptr: line-no ptr: char-np file-desc: log-stream --
  file-desc ptr ptr file-desc --
  // Moves the file pointer until it passes a block comment end, or EOF is reached.
  // Keeps track of the line and char number as the bytes are read.
in let file line-no char-no log-stream in
  memory char 1 in
    while true do
      char 1 file fgets is-zero if                          // Reached EOF while expecting a block comment end.
        LOG.WARN log-stream fputs "Reached EOF while expecting a block comment end.\n" log-stream fputs
        return
        
      else char @8 CHAR-ASTERISK = if                       // Reached asterisk.
        char 1 file fgets is-zero if                        // Reached EOF while expecting a block comment end.
          LOG.WARN log-stream fputs "Reached EOF while expecting a block comment end.\n" log-stream fputs
          return
        end

        char @8 CHAR-SLASH = if                             // Reached block comment end.
          return
        end
        
      else char @8 CHAR-NEWLINE = if                        // Reached a newline.
        line-no @inc64
        0 char-no !64
        
      else                                                  // Reached any other character
        char-no @inc64
      end end end
    end
  end
end end


proc create-name-token
  // ptr: file-name file-desc: file-desc int: start-line int: start-char int: start-at ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream -- int: token-type ptr: address [int|ptr]: arg bool: is-available
  ptr file-desc int int int ptr ptr ptr ptr file-desc -- int ptr int bool
  // Checks if the name is a keyword or an intrinsic, and creates a new token.
  // TODO: Implement keywords.
  // TODO: Implement intrinsic keywords.
in let file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream in
  // Get full token.
  file line-no char-no buffer buffer-end log-stream parse-next-token

  buffer-end @64 buffer - let buffer-size in
    // Check if the token is a keyword.
    // I hate my life.
         buffer buffer-size KEYWORD-INCLUDE-STR    memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-INCLUDE    true
    else buffer buffer-size KEYWORD-MACRO-STR      memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-MACRO      true
    else buffer buffer-size KEYWORD-ENDMACRO-STR   memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-ENDMACRO   true
    else buffer buffer-size KEYWORD-PROC-STR       memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-PROC       true
    else buffer buffer-size KEYWORD-END-STR        memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-END        true
    else buffer buffer-size KEYWORD-RETURN-STR     memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-RETURN     true
    else buffer buffer-size KEYWORD-RETURNS-STR    memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-RETURNS    true
    else buffer buffer-size KEYWORD-MEMORY-STR     memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-MEMORY     true
    else buffer buffer-size KEYWORD-AND-STR        memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-AND        true
    else buffer buffer-size KEYWORD-IN-STR         memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-IN         true
    else buffer buffer-size KEYWORD-LET-STR        memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-LET        true
    else buffer buffer-size KEYWORD-IF-STR         memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-IF         true
    else buffer buffer-size KEYWORD-ELSE-STR       memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-ELSE       true
    else buffer buffer-size KEYWORD-WHILE-STR      memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-WHILE      true
    else buffer buffer-size KEYWORD-DO-STR         memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-DO         true
    else buffer buffer-size KEYWORD-BREAK-STR      memeq8 if TYPE-KEYWORD   file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-BREAK      true
    
    // I still hate my life.
    else buffer buffer-size INTRINSIC-ADD-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-ADD      true
    else buffer buffer-size INTRINSIC-SUB-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SUB      true
    else buffer buffer-size INTRINSIC-MUL-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-MUL      true
    else buffer buffer-size INTRINSIC-MUL2-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-MUL2     true
    else buffer buffer-size INTRINSIC-FULLMUL-STR  memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-FULLMUL  true
    else buffer buffer-size INTRINSIC-DIV-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-DIV      true
    else buffer buffer-size INTRINSIC-MOD-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-MOD      true
    else buffer buffer-size INTRINSIC-DIVMOD-STR   memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-DIVMOD   true
    else buffer buffer-size INTRINSIC-UMUL-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UMUL     true
    else buffer buffer-size INTRINSIC-UMUL2-STR    memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UMUL2    true
    else buffer buffer-size INTRINSIC-UFULLMUL-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UFULLMUL true
    else buffer buffer-size INTRINSIC-UDIV-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UDIV     true
    else buffer buffer-size INTRINSIC-UMOD-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UMOD     true
    else buffer buffer-size INTRINSIC-UDIVMOD-STR  memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UDIVMOD  true
    else buffer buffer-size INTRINSIC-BAND-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BAND     true
    else buffer buffer-size INTRINSIC-BOR-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BOR      true
    else buffer buffer-size INTRINSIC-BXOR-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BXOR     true
    else buffer buffer-size INTRINSIC-BNOT-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BNOT     true
    else buffer buffer-size INTRINSIC-NOTEQUAL-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-NOTEQUAL true
    else buffer buffer-size INTRINSIC-LESS-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-LESS     true
    else buffer buffer-size INTRINSIC-TRUE-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-TRUE     true
    else buffer buffer-size INTRINSIC-FALSE-STR    memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-FALSE    true
    else buffer buffer-size INTRINSIC-LOAD8-STR    memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-LOAD8    true
    else buffer buffer-size INTRINSIC-STORE8-STR   memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-STORE8   true
    else buffer buffer-size INTRINSIC-LOAD64-STR   memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-LOAD64   true
    else buffer buffer-size INTRINSIC-STORE64-STR  memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-STORE64  true
    else buffer buffer-size INTRINSIC-SYSCALL0-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL0 true
    else buffer buffer-size INTRINSIC-SYSCALL1-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL1 true
    else buffer buffer-size INTRINSIC-SYSCALL2-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL2 true
    else buffer buffer-size INTRINSIC-SYSCALL3-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL3 true
    else buffer buffer-size INTRINSIC-SYSCALL4-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL4 true
    else buffer buffer-size INTRINSIC-SYSCALL5-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL5 true
    else buffer buffer-size INTRINSIC-SYSCALL6-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL6 true
    
    else buffer buffer-size TYPE-INT-STR           memeq8 if TYPE-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address TYPE-INT           true
    else buffer buffer-size TYPE-BOOL-STR          memeq8 if TYPE-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address TYPE-BOOL          true
    else
      // Return token type, address and argument.
      TYPE-NAME file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address buffer buffer-size to-dynamic true

    // This is nightmare fuel.
    end end end end end end end end end end end end end end end end end
    end end end end end end end end end end end end end end end end end 
    end end end end end end end end end end end end end end end end end
  end
end end


proc get-next-token
  // ptr: file-name file-desc: file-desc ptr: line-no ptr: char-no file-desc: log-stream -- int: token-type ptr: address [int|ptr]: arg bool: is-available 
  ptr file-desc ptr ptr file-desc -- int ptr int bool
  // Generates a token and returns.
  // NOTE: If there is no token available, every other parameter is either NULLPTR or invalid.
  // TODO: Create a new queue for the saved tokens when a macro is called.
  // TODO: Change this procedure so that it returns the next saved token, if there is one.
in let file-name file line-no char-no log-stream in
  memory buffer     TOKEN-MAX-LENGTH and
         buffer-end sizeof(int)      in

    file line-no char-no strip-file if
      TYPE-UNKNOWN NULLPTR 0 false return
    end
    
    buffer buffer-end !64

    line-no @64 char-no @64 file ftell let start-line start-char start-at in
      buffer 1 file fgets drop
      buffer-end @inc64
    
      buffer @8 '0' '9' is-range if
        // -------- Integer type --------

        // Get full token.
        file line-no char-no buffer buffer-end log-stream parse-next-token

        TYPE-INTEGER file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address
        
        buffer buffer-end @64 buffer - str.to-int ! if
          drop
          LOG.ERR log-stream fputs "Could not convert integer.\n" log-stream fputs LOG.RESET log-stream fputs
          log-stream fput-here
          1 call-sys-exit
          drop
          TYPE-UNKNOWN NULLPTR 0 false return // dummy return
        end
 
        true
        
      else buffer @8 CHAR-SQUOTE = if
        // -------- Characters --------
        
        buffer inc 1 file fgets is-zero if                  // Reached EOF while expecting a character.
          LOG.ERR log-stream fputs "Reached EOF before finding a character after single quote.\n" log-stream fputs LOG.RESET log-stream fputs
          1 call-sys-exit
        end

        // Get the character
        buffer inc @8 let character in
          character CHAR-BACKSLASH = if
            // -------- Escapes --------
            // TODO: Add escapes.
            LOG.TODO log-stream fputs "Escapes are not implemented yet.\n" log-stream fputs
            1 call-sys-exit
          end
          
          buffer 2 + 1 file fgets is-zero if              // Reached EOF while expecting a single quote.
            LOG.ERR log-stream fputs "Reached EOF before finding a single quote after single quote and character.\n" log-stream fputs
            1 call-sys-exit
          end

          buffer 2 + @8 CHAR-SQUOTE != if                 // Was expecting a single quote, but found another character.
            LOG.ERR log-stream fputs "Expected a single quote, found '" log-stream fputs buffer 2 + 1 log-stream fputs "'.\n" log-stream fputs
            1 call-sys-exit
          end

          // Return token type, address and argument.
          TYPE-INTEGER file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address character true
        end
        
      else buffer @8 CHAR-DQUOTE = if
        // -------- String type --------

        // Move the buffer-end left once, so the quote is removed.
        buffer-end @dec64

        char-no @inc64

        // Get full string.
        file line-no char-no buffer buffer-end log-stream parse-next-string

        // Return token type, address and argument.
        TYPE-STRING file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address buffer buffer-end @64 buffer - to-dynamic true
        
      else buffer @8 CHAR-SLASH = if
        // -------- Slash (Name and comments) --------
        
        buffer inc 1 file fgets is-zero if
          LOG.ERR log-stream fputs "Reached EOF while expecting character after slash (/).\n" log-stream fputs
          1 call-sys-exit
        end
          
        buffer inc @8 CHAR-SLASH = if
          // -------- Single line comment --------

          // Skip this line.
          file line-no char-no log-stream skip-line

          // Get next token and return it.
          file-name file line-no char-no log-stream get-next-token

        else buffer inc @8 CHAR-ASTERISK = if
          // -------- Block comment --------

          // Skip the block comment.
          file line-no char-no log-stream skip-block-comment

          // Get next token and return it.
          file-name file line-no char-no log-stream get-next-token

        else
          // -------- Name and keyword types --------
          file 1 neg SEEK-CUR fseek drop

          file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream create-name-token
        end end

      else
        // -------- Name and keyword types --------
        file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream create-name-token
      end end end end
    end
  end
end end


proc fput-inside-procedure
  // ptr: procedure-name ptr: procedure-address file-desc: log-stream
  ptr ptr file-desc --
in let name address log-stream in
  LOG.INFO log-stream fputs "Inside procedure '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
  address log-stream fput-here
end end


proc create-int
  // -- ptr: stack-data
  -- ptr
in
  8 malloc let x in
    x is-null if
      "'malloc' failed while creating an integer stack value.\n" eputs
      1 call-sys-exit
    end

    TYPE-INT x !64
  x end
end


proc create-bool
  // -- ptr: stack-data
  -- ptr
in
  8 malloc let x in
    x is-null if
      "'malloc' failed while creating a boolean stack value.\n" eputs
      1 call-sys-exit
    end

    TYPE-BOOL x !64
  x end
end


proc compile-keyword-inside-procedure
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: levels-array ptr: levels-length ptr: level-id-counter
  ptr ptr ptr
  // ptr: let-names ptr: let-addresses ptr: let-vars-length
  ptr ptr ptr
  // ptr: local-names ptr: local-addresses ptr: locals-length
  ptr ptr ptr
  // ptr: local-memory-end
  ptr 
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // file-desc: log-stream
  file-desc --

  // Compiles a keyword in a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let 
    source-name source-file output-file
    line-no char-no
    procedure-name procedure-address
    local-stack local-stack-length
    levels-array levels-length level-id-counter
    let-names let-addresses let-vars-length
    local-names local-addresses locals-length
    local-memory-end
    token-type token-address token-arg
    log-stream in
        
end end


proc compile-intrinsic-inside-procedure
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // file-desc: log-stream
  file-desc --

  // Compiles an intrinsic in a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let 
    source-name source-file output-file
    line-no char-no
    procedure-name procedure-address
    local-stack local-stack-length
    token-type token-address token-arg
    log-stream in
  
  token-arg INTRINSIC-ADD = if
    // -------- Intrinsic '+' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '+' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      1 call-sys-exit
    end

    "    pop     rax\n"        output-file fputs
    "    add     [rsp], rax\n" output-file fputs

    local-stack local-stack-length queue64.pop-last mfree
    local-stack local-stack-length queue64.pop-last mfree
    create-int local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-SUB = if
    // -------- Intrinsic '-' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '-' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      1 call-sys-exit
    end

    "    pop     rax\n"        output-file fputs
    "    sub     [rsp], rax\n" output-file fputs

    local-stack local-stack-length queue64.pop-last mfree
    local-stack local-stack-length queue64.pop-last mfree
    create-int local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-DIVMOD = if
    // -------- Intrinsic '/%' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '/%' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      1 call-sys-exit
    end

    "    xor     rdx, rdx\n"        output-file fputs
    "    mov     rbx, [rsp]\n"      output-file fputs
    "    mov     rax, [rsp+8]\n"    output-file fputs
    "    idiv    rbx\n"             output-file fputs
    "    mov     [rsp+8], rax\n"    output-file fputs
    "    mov     [rsp], rdx\n\n"    output-file fputs
    
    local-stack local-stack-length queue64.pop-last mfree
    local-stack local-stack-length queue64.pop-last mfree
    create-int local-stack local-stack-length queue64.append
    create-int local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-NOTEQUAL = if
    // -------- Intrinsic '!=' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '!=' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      1 call-sys-exit
    end

    "    pop     rax\n"         output-file fputs
    "    sub     [rsp], rax\n"  output-file fputs

    local-stack local-stack-length queue64.pop-last mfree
    local-stack local-stack-length queue64.pop-last mfree
    create-bool local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-LESS = if
    // -------- Intrinsic '<' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '<' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      1 call-sys-exit
    end

    "    pop     rax\n"               output-file fputs
    "    pop     rbx\n"               output-file fputs
    "    sub     rax, rbx\n"          output-file fputs
    "    pushf\n"                     output-file fputs
    "    and     qword [rsp], 0x80\n" output-file fputs

    local-stack local-stack-length queue64.pop-last mfree
    local-stack local-stack-length queue64.pop-last mfree
    create-bool local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-LOAD64 = if
    // -------- Intrinsic '@64' --------
    
    // TODO: Check the type of arguments.
    local-stack-length @64 is-zero if
      LOG.ERR log-stream fputs "Intrinsic '@64' requires an integer, there was no item in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      1 call-sys-exit
    end

    "    pop     rax\n"   output-file fputs
    "    push    [rax]\n" output-file fputs

    local-stack local-stack-length queue64.pop-last mfree
    create-int local-stack local-stack-length queue64.append

  else token-arg INTRINSIC-STORE64 = if
    // -------- Intrinsic '!64' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 2 < if
      LOG.ERR log-stream fputs "Intrinsic '!64' requires 2 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      1 call-sys-exit
    end

    "    pop     rax\n"         output-file fputs
    "    pop     qword [rax]\n" output-file fputs

    local-stack local-stack-length queue64.pop-last mfree
    local-stack local-stack-length queue64.pop-last mfree
    
  else token-arg INTRINSIC-SYSCALL3 = if
    // -------- Intrinsic 'syscall3' --------

    // TODO: Check the type of arguments.
    local-stack-length @64 4 < if
      LOG.ERR log-stream fputs "'syscall3' requires 4 integers, there was " log-stream fputs local-stack-length @64 log-stream fputu " items in the stack.\n" log-stream fputs
      token-address log-stream fput-here
      1 call-sys-exit
    end

    "    pop     rax\n" output-file fputs
    "    pop     rdx\n" output-file fputs
    "    pop     rsi\n" output-file fputs
    "    pop     rdi\n" output-file fputs
    "    syscall\n"     output-file fputs
    "    push    rax\n" output-file fputs

    local-stack local-stack-length queue64.pop-last mfree
    local-stack local-stack-length queue64.pop-last mfree
    local-stack local-stack-length queue64.pop-last mfree
    local-stack local-stack-length queue64.pop-last mfree
    create-int local-stack local-stack-length queue64.append

  else
    LOG.TODO log-stream fputs "Intrinsic '" log-stream fputs token-arg log-stream fput-intrinsic "' is not implemented yet.\n" log-stream fputs
    token-address log-stream fput-here
    procedure-name procedure-address log-stream fput-inside-procedure
    1 call-sys-exit
  end end end end end end end end
end end


proc compile-procedure
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: data-definitions-array ptr: datas-length 
  ptr ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // file-desc: log-stream
  file-desc --
  
  // Compiles a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let 
    source-name source-file output-file
    line-no char-no
    data-definitions-array datas-length
    global-names-array global-sizes-array globals-length
    macro-names-array macro-tokens-array macros-length
    procedure-name procedure-address
    local-stack local-stack-length
    log-stream in
    
  "proc_" output-file fputs procedure-name procedure-name mlength output-file fputs ":\n" output-file fputs

  memory levels-array     sizeof(ptr) LEVELS-MAX-COUNT * and
         levels-length    sizeof(int)                    and

         // level-id-counter allows to create unique IDs for level labels.
         level-id-counter sizeof(int)                    and

         // let-names, let-addresses and let-vars-length create a str_map64.
         let-names        sizeof(ptr) LET-MAX-COUNT *    and
         let-addresses    sizeof(ptr) LET-MAX-COUNT *    and
         let-vars-length  sizeof(int)                    and
         
         // local-names, local-addresses and locals-length create a str_map64.
         local-names      sizeof(ptr) LOCALS-MAX-COUNT * and
         local-addresses  sizeof(ptr) LOCALS-MAX-COUNT * and
         locals-length    sizeof(int)                    and

         // local-memory-end keeps track of the first available position on the local memory.
         local-memory-end sizeof(int)                    in

    0 levels-length    !64
    0 level-id-counter !64
    0 let-vars-length  !64
    0 locals-length    !64
    0 local-memory-end !64

    while true do
      source-name source-file line-no char-no log-stream get-next-token ! if
        LOG.ERR log-stream fputs "Reached EOF while expecting procedure definition or 'end'.\n" log-stream fputs
        procedure-name procedure-address log-stream fput-inside-procedure
        1 call-sys-exit
      end

      let token-type token-address token-arg in
        token-type TYPE-INTEGER = if
          // -------- Constant integer --------
          token-arg is-zero if
              "    xor     rax, rax\n" output-file fputs
          else
              "    mov     rax, " output-file fputs token-arg output-file fputu "\n" output-file fputs
          end

          "    push    rax\n" output-file fputs

          create-int local-stack local-stack-length queue64.append
          
        else token-type TYPE-STRING = if
          // -------- Strings --------

          // TODO: Change this to GLOBAL ADDRESS DATA
          "    mov     rax, data_" output-file fputs datas-length @64 output-file fputu "\n" output-file fputs
          "    push    rax\n" output-file fputs
          
          token-arg mlength is-zero if
              "    xor     rax, rax\n" output-file fputs
          else
              "    mov     rax, " output-file fputs token-arg mlength output-file fputu "\n" output-file fputs
          end

          "    push    rax\n" output-file fputs

          create-int local-stack local-stack-length queue64.append
          create-int local-stack local-stack-length queue64.append

          token-arg data-definitions-array datas-length queue64.append

        else token-type TYPE-NAME = if
          // -------- Names --------

          token-arg let-names let-addresses let-vars-length str-map64.get if
            let address in
              "    push    qword [local_ptr" output-file fputs address isn-zero if " + " output-file fputs address output-file fputu end "]\n" output-file fputs

              create-int local-stack local-stack-length queue64.append
            end
            
          else drop token-arg local-names local-addresses locals-length str-map64.get if
            let address in
              "    push    local_ptr\n" output-file fputs
              
              address isn-zero if
                "    add     qword [rsp], " output-file fputs address output-file fputu "\n" output-file fputs
              end
              
              create-int local-stack local-stack-length queue64.append
            end
            
          else drop
            0 while dup locals-length @64 < do let i in
              i 8 * local-names + @64 let str in
                str str mlength puts "\n" puts
              end
            i end inc end drop
            
            LOG.ERR log-stream fputs "Name '" log-stream fputs token-arg token-arg mlength log-stream fputs "' is not defined as a local variable.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            1 call-sys-exit
          end end

        else token-type TYPE-INTRINSIC = if
          // -------- Intrinsics --------
          
          source-name source-file output-file
          line-no char-no
          procedure-name procedure-address
          local-stack local-stack-length
          token-type token-address token-arg
          log-stream
          compile-intrinsic-inside-procedure

        else token-type TYPE-KEYWORD = if          
          // -------- Keywords --------

          token-arg KEYWORD-END = if
            // -------- Keyword 'end' --------

            levels-length @64 is-zero if
              // -------- End of 'proc' --------

              return
            end

            levels-array levels-length queue64.pop-last let level in
              level @64 level 8 + @64 let start-keyword start-address in                
                start-keyword KEYWORD-IF = if
                  // -------- End of 'if' --------
                  // TODO: Check the stack.

                  level 16 + @64 level 24 + @64 let start-id start-stack in
                    "    .level_" output-file fputs start-id output-file fputu ":\n" output-file fputs

                    start-stack   mfree
                  end
                else start-keyword KEYWORD-LET = if
                  // -------- End of 'let' --------

                  level 16 + @64 level 24 + @64 let new-names old-local-memory-end in
                    0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
                      name let-names let-addresses let-vars-length str-map64.remove ! if
                        LOG.ERR  log-stream fputs "Could not find the 'let' variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                        LOG.INFO log-stream fputs "This is probably caused by a bug in the compiler.\n" log-stream fputs
                        token-address log-stream fput-here
                        start-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                      end

                      // Free the space allocated for the name of each variable.
                      name mfree
                    end i end inc end drop

                    old-local-memory-end local-memory-end !64

                    new-names     mfree
                  end

                else start-keyword KEYWORD-MEMORY = if
                  // -------- End of 'memory' --------

                  level 16 + @64 level 24 + @64 let new-names old-local-memory-end in
                    0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
                      name local-names local-addresses locals-length str-map64.remove ! if
                        LOG.ERR  log-stream fputs "Could not find the local variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                        LOG.INFO log-stream fputs "This is probably caused by a bug in the compiler.\n" log-stream fputs
                        token-address log-stream fput-here
                        start-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                      end

                      // Free the space allocated for the name of each variable.
                      name mfree
                    end i end inc end drop

                    old-local-memory-end local-memory-end !64

                    new-names     mfree
                  end

                else
                  LOG.TODO log-stream fputs "'end' after keyword '" log-stream fputs start-keyword log-stream fput-keyword "' is not implemented yet.\n" log-stream fputs
                  token-address log-stream fput-here
                  start-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  1 call-sys-exit
                end end end

                start-address mfree
              end

              level mfree
            end

          else token-arg KEYWORD-IF = if
            // -------- Keyword 'if' --------

            "    pop     rax\n"      output-file fputs
            "    test    rax, rax\n" output-file fputs
            "    jz      .level_"    output-file fputs level-id-counter @64 output-file fputu "\n" output-file fputs

            local-stack-length @64 is-zero if
              LOG.ERR log-stream fputs "'if' requires a bool, there was no items in the stack.\n" log-stream fputs
              token-address log-stream fput-here
              procedure-name procedure-address log-stream fput-inside-procedure
              1 call-sys-exit
            end

            local-stack local-stack-length queue64.pop-last mfree

            local-stack local-stack-length @64 8 * to-dynamic let copy-stack in
              copy-stack is-null if
                "'malloc' failed while copying the stack for 'if'.\n" eputs
                1 call-sys-exit
              end

              32 malloc let obj in
                obj is-null if
                  "'malloc' failed while creating a level object for 'if'.\n" eputs
                  1 call-sys-exit
                end

                KEYWORD-IF           obj      !64
                token-address        obj 8  + !64
                level-id-counter @64 obj 16 + !64
                copy-stack           obj 24 + !64

                level-id-counter @inc64

                obj levels-array levels-length queue64.append
              end
            end

          else token-arg KEYWORD-MEMORY = if
            // -------- Keyword 'memory' --------

            // New names are stored in new-names and new-names-length queue. When the 'end' of 'memory' is reached, new names are deleted from the namespace.
            memory new-names        sizeof(ptr) VARS-MAX-ONCE * and
                   new-names-length sizeof(int)                 in

              0 new-names-length !64

              32 malloc let obj in
                //  0- 7 -> KEYWORD-MEMORY
                //  8-15 -> Starter address
                // 16-23 -> New names
                // 24-31 -> Old local-memory-end

                obj is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while creating a level object for 'memory'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  1 call-sys-exit
                end

                KEYWORD-MEMORY       obj      !64
                token-address        obj  8 + !64
                local-memory-end @64 obj 24 + !64

                // TODO: Add 'and'.
                // TODO: Add proper pre-compilation for memory size.
                source-name source-file line-no char-no log-stream get-next-token ! if
                  LOG.ERR log-stream fputs "Reached EOF while expecting a local variable name after 'memory'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  1 call-sys-exit
                end

                let memory-name-type memory-name-address memory-name-arg in
                  memory-name-type TYPE-NAME != if
                    LOG.ERR log-stream fputs "Expected 'name' for local variable name after 'memory', got '" log-stream fputs memory-name-type log-stream fput-type "'.\n" log-stream fputs
                    memory-name-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    1 call-sys-exit
                  end

                  source-name source-file line-no char-no log-stream get-next-token ! if
                    LOG.ERR log-stream fputs "Reached EOF while expecting a local variable size after 'memory'.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    1 call-sys-exit
                  end

                  let memory-size-type memory-size-address memory-size-arg in
                    memory-size-type TYPE-INTEGER != if
                      LOG.ERR log-stream fputs "Expected 'integer' for local variable size after 'memory', got '" log-stream fputs memory-size-type log-stream fput-type "'.\n" log-stream fputs
                      memory-size-address log-stream fput-here
                      procedure-name procedure-address log-stream fput-inside-procedure
                      1 call-sys-exit
                    end

                    source-name source-file line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting a local variable size after 'memory'.\n" log-stream fputs
                      token-address log-stream fput-here
                      procedure-name procedure-address log-stream fput-inside-procedure
                      1 call-sys-exit
                    end

                    let memory-end-type memory-end-address memory-end-arg in
                      memory-end-type TYPE-KEYWORD != if
                        LOG.ERR log-stream fputs "Expected 'keyword' after 'memory', got '" log-stream fputs memory-end-type log-stream fput-type "'.\n" log-stream fputs
                        memory-end-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        1 call-sys-exit
                      end

                      memory-end-arg KEYWORD-AND = if
                        LOG.TODO log-stream fputs "'and' after 'memory' for local variable allocation is not implemented yet.\n" log-stream fputs
                        memory-end-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        1 call-sys-exit
                        
                      else memory-end-arg KEYWORD-IN = if
                        // TODO: Check if the new-names queue is full.
                        memory-name-arg new-names new-names-length queue64.append
                        memory-name-arg local-memory-end @64 local-names local-addresses locals-length str-map64.set if
                          LOG.ERR log-stream fputs "Local variable '" log-stream fputs memory-name-arg memory-name-arg mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                          memory-name-address log-stream fput-here
                          procedure-name procedure-address log-stream fput-inside-procedure
                          1 call-sys-exit
                        end

                        local-memory-end @64 memory-size-arg + local-memory-end !64
                      else
                        LOG.ERR log-stream fputs "Expected 'and' or 'in' after local variable, got '" log-stream fputs memory-end-arg log-stream fput-keyword "'.\n" log-stream fputs
                        memory-end-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        1 call-sys-exit
                      end end

                      memory-end-address mfree
                    end

                    memory-size-address mfree
                  end
                end

                new-names new-names-length @64 8 * to-dynamic let new in
                  new is-null if
                    LOG.ERR log-stream fputs "'malloc' failed while allocating space for new-names after 'memory'.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    1 call-sys-exit
                  end

                  new obj 16 + !64
                end

                obj levels-array levels-length queue64.append
              end
            end

          else token-arg KEYWORD-LET = if
            // -------- Keyword 'let' --------

            // New names are stored in new-names and new-names-length queue. When the 'end' of 'let' is reached, new names are deleted from the namespace.
            memory new-names        sizeof(ptr) VARS-MAX-ONCE * and
                   new-names-length sizeof(int)                 in

              0 new-names-length !64

              32 malloc let obj in
                //  0- 7 -> KEYWORD-LET
                //  8-15 -> Starter address
                // 16-23 -> New names
                // 24-31 -> Old local-memory-end

                obj is-null if
                  LOG.ERR log-stream fputs "'malloc' failed while creating a level object for 'let'.\n" log-stream fputs
                  token-address log-stream fput-here
                  procedure-name procedure-address log-stream fput-inside-procedure
                  1 call-sys-exit
                end

                KEYWORD-LET          obj      !64
                token-address        obj  8 + !64
                local-memory-end @64 obj 24 + !64

                while true do
                  source-name source-file line-no char-no log-stream get-next-token ! if
                    LOG.ERR log-stream fputs "Reached EOF while expecting a name for let variable.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    1 call-sys-exit
                  end

                  let new-token-type new-token-address new-token-arg in
                    new-token-type TYPE-KEYWORD = if
                      new-token-arg KEYWORD-IN != if
                        LOG.ERR log-stream fputs "Unexpected keyword while expecting a name for 'let' variable or 'in', got '" log-stream fputs new-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                        new-token-address log-stream fput-here
                        token-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        1 call-sys-exit
                      end

                      break

                    else new-token-type TYPE-NAME = if
                      local-stack local-stack-length queue64.pop-last drop

                      "    pop     qword [local_ptr" output-file fputs local-memory-end @64 isn-zero if " + " output-file fputs local-memory-end @64 output-file fputu end "]\n" output-file fputs

                      new-names-length VARS-MAX-ONCE = if
                        LOG.ERR log-stream fputs "new-names-length was equal to VARS-MAX-ONCE.\n" log-stream fputs
                        new-token-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        1 call-sys-exit
                      end

                      // TODO: Change the way that the variables are stored, so that we can also store their addresses.
                      new-token-arg new-names new-names-length queue64.append
                      new-token-arg local-memory-end @64 let-names let-addresses let-vars-length str-map64.set if
                        LOG.ERR log-stream fputs "'let' variable '" log-stream fputs new-token-arg new-token-arg mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                        new-token-address log-stream fput-here
                        procedure-name procedure-address log-stream fput-inside-procedure
                        1 call-sys-exit
                      end

                      local-memory-end @64 8 + local-memory-end !64

                    else
                      LOG.ERR log-stream fputs "Unexpected type while expecting a name for 'let' variable or 'in', got '" log-stream fputs new-token-type log-stream fput-type "'.\n" log-stream fputs
                      new-token-address log-stream fput-here
                      token-address log-stream fput-here
                      procedure-name procedure-address log-stream fput-inside-procedure
                      1 call-sys-exit
                    end end

                    new-token-address mfree
                  end
                end

                new-names new-names-length @64 8 * to-dynamic let new in
                  new is-null if
                    LOG.ERR log-stream fputs "'malloc' failed while allocating space for new-names after 'memory'.\n" log-stream fputs
                    token-address log-stream fput-here
                    procedure-name procedure-address log-stream fput-inside-procedure
                    1 call-sys-exit
                  end

                  new obj 16 + !64
                end

                obj levels-array levels-length queue64.append
              end
            end

          else
            LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            1 call-sys-exit
          end end end end

        else
          LOG.ERR log-stream fputs "Unexpected type while expecting a keyword, an intrinsic, a string or an integer, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
          token-address log-stream fput-here
          procedure-name procedure-address log-stream fput-inside-procedure
          1 call-sys-exit
        end end end end end
      end
    end
  end
end end


proc compile-file
  // ptr: source-name file-desc: output-file
  ptr file-desc
  // ptr: data-definitions-array ptr: datas-length 
  ptr ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // libraries-array ptr: libraries-length
  ptr ptr 
  // file-desc: log-stream
  file-desc --
  
  // Compiles a Corth source file.
  // Compilation warning and errors are dumped to log-stream.
in let
  source-name output-file
  data-definitions-array datas-length
  global-names-array global-sizes-array globals-length
  macro-names-array macro-tokens-array macros-length
  libraries-array libraries-length
  log-stream in

  source-name add-null let c-source-name in
    c-source-name fopen-read
    c-source-name mfree
  end
  
  let source-file in
    // Check if the source is opened.
    source-file isn-pos if
      LOG.ERR log-stream fputs "Could not open source file '" log-stream fputs source-name source-name mlength dec log-stream fputs "'\n" log-stream fputs LOG.RESET log-stream fputs
      1 call-sys-exit
    end

    "segment .text\n"                                   output-file fputs
    "global _start\n"                                   output-file fputs

    "_start:\n"                                         output-file fputs
    "    mov     qword [call_ptr], call_stack\n"        output-file fputs
    "    add     qword [call_ptr], 0x4000\n"            output-file fputs
    "    mov     qword [local_ptr], local_memory\n"     output-file fputs

    "    xchg    rsp, [call_ptr]\n"                     output-file fputs
    "    push    corth_endofprogram\n"                  output-file fputs
    "    push    qword [local_ptr]\n"                   output-file fputs
    "    xchg    rsp, [call_ptr]\n"                     output-file fputs
    "    jmp     proc_main\n"                           output-file fputs

    "corth_endofprogram:\n"                             output-file fputs
    "    mov     rax, 60\n"                             output-file fputs
    "    pop     rdi\n"                                 output-file fputs
    "    syscall\n"                                     output-file fputs

    memory line-no sizeof(int) and
           char-no sizeof(int) in

      // Reset line-no and char-no variables.
      1 line-no !64
      0 char-no !64

      // Get next token and check if there is one available.
      while source-name source-file line-no char-no log-stream get-next-token do
        let token-type token-address token-arg in
          token-type TYPE-KEYWORD = if
            // -------- Global keywords --------            
            token-arg KEYWORD-INCLUDE = if
              // -------- 'include' keyword --------
              // TODO: Create a function to include.
              // TODO: Allow including packages.
              // TODO: Add library search locations.
              // TODO: Add pragma once.

              // Get the next token, which should be the include path.
              source-name source-file line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting an include path.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let path-token-type path-token-address path-token-arg in
                path-token-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for path after 'include', got '" log-stream fputs path-token-type log-stream fput-type "'.\n" log-stream fputs
                  path-token-address log-stream fput-here
                  1 call-sys-exit
                end
                
                path-token-arg output-file
                data-definitions-array datas-length
                global-names-array global-sizes-array globals-length
                macro-names-array macro-tokens-array macros-length
                libraries-array libraries-length
                log-stream compile-file

                // Deallocate the space for the token addresses.
                path-token-address mfree
              end

              token-address mfree
              
            else token-arg KEYWORD-MEMORY = if
              // -------- 'memory' keyword --------
              
              // Get the next token, which sould be the include path.
              source-name source-file line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a global variable name after 'memory'.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let memory-name-type memory-name-address memory-name-arg in
                memory-name-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for global variable name after 'memory', got '" log-stream fputs memory-name-type log-stream fput-type "'.\n" log-stream fputs
                  memory-name-address log-stream fput-here
                  1 call-sys-exit
                end

                // TODO: Implement size calculation.
                source-name source-file line-no char-no log-stream get-next-token ! if
                  LOG.ERR log-stream fputs "Reached EOF while expecting a global variable name after 'memory'.\n" log-stream fputs
                  token-address log-stream fput-here
                  1 call-sys-exit
                end

                let memory-size-type memory-size-address memory-size-arg in
                  memory-size-type TYPE-INTEGER != if
                    LOG.ERR log-stream fputs "Expected an 'int' for global variable size after 'memory', got '" log-stream fputs memory-size-type log-stream fput-type ".\n" log-stream fputs
                    memory-size-type log-stream fput-here
                    1 call-sys-exit
                  end

                  source-name source-file line-no char-no log-stream get-next-token ! if
                    LOG.ERR log-stream fputs "Reached EOF while expecting global variable size after 'memory'.\n" log-stream fputs
                    token-address log-stream fput-here
                    1 call-sys-exit
                  end

                  let end-token-type end-token-address end-token-arg in
                    end-token-type TYPE-KEYWORD != if
                      LOG.ERR log-stream fputs "Expected an 'int' for global variable size after 'memory', got '" log-stream fputs end-token-type log-stream fput-type "'.\n" log-stream fputs
                      end-token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    end-token-arg KEYWORD-END != if
                      LOG.ERR log-stream fputs "Unexpected keyword while expecting global variable size, got '" log-stream fputs end-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                      end-token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    end-token-address mfree
                  end

                  // TODO: Check if the global variable queue was filled.
                  memory-name-arg memory-size-arg global-names-array global-sizes-array globals-length str-map64.set drop

                  memory-size-address mfree
                end

                memory-name-address mfree
              end

              token-address mfree
              
            else token-arg KEYWORD-MACRO = if
              // -------- 'macro' keyword --------

              // Get the next token, which should be the name of the macro.
              source-name source-file line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a macro name.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let macro-name-token-type macro-name-token-address macro-name-token-arg in
                macro-name-token-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for macro name after 'macro', got '" log-stream fputs macro-name-token-arg log-stream fput-type "'.\n" log-stream fputs
                  macro-name-token-address log-stream fput-here
                  1 call-sys-exit
                end

                // macro-tokens-array and macro-tokens-length are used to create a QUEUE for macro tokens.
                memory new-macro-tokens-array  MACRO-MAX-TOKENS sizeof(int) * and
                       new-macro-tokens-length sizeof(int)                    in
                       
                  while true do
                   // Get next tokens, until an 'endmacro' is found.
                    source-name source-file line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting an 'endmacro' in macro '" log-stream fputs macro-name-token-arg macro-name-token-arg mlength log-stream fputs "'.\n" log-stream fputs
                      token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    let macro-new-token-type macro-new-token-address macro-new-token-arg in
                      macro-new-token-type TYPE-KEYWORD = if
                        macro-new-token-arg KEYWORD-ENDMACRO = if
                          break
                        end
                      end
                      
                      new-macro-tokens-length MACRO-MAX-TOKENS - 3 < if
                        LOG.ERR log-stream fputs "Macro '" log-stream fputs macro-name-token-arg macro-name-token-arg mlength log-stream fputs "' is longer than MACRO-MAX-TOKENS, stopping execution.\n" log-stream fputs
                        token-address log-stream fput-here
                        1 call-sys-exit
                      end
                      
                      macro-new-token-type    new-macro-tokens-array new-macro-tokens-length queue64.append
                      macro-new-token-address new-macro-tokens-array new-macro-tokens-length queue64.append
                      macro-new-token-arg     new-macro-tokens-array new-macro-tokens-length queue64.append
                    end
                  end

                  new-macro-tokens-array new-macro-tokens-length @64 8 * to-dynamic
                end 

                let macro-tokens in
                  // TODO: Check if the macros queue was filled.
                  macro-name-token-arg macro-tokens macro-names-array macro-tokens-array macros-length str-map64.set drop
                end


                macro-name-token-address mfree
                macro-name-token-arg     mfree
              end

              token-address mfree
              
            else token-arg KEYWORD-PROC = if
              // -------- 'proc' keyword --------

              // Get the next token, which should be the name of the procedure.
              source-name source-file line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a procedure name.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let proc-name-token-type proc-name-token-address proc-name-token-arg in
                proc-name-token-type TYPE-NAME != if
                  "Expected a 'name' for procedure name after 'proc', got " log-stream fputs proc-name-token-type log-stream fput-type "'.\n" log-stream fputs
                  proc-name-token-type log-stream fput-here
                  1 call-sys-exit
                end

                // macro-tokens-array and macro-tokens-length are used to create a QUEUE for macro tokens.
                memory inputs-array   sizeof(int) PROC-MAX-IO * and
                       inputs-length  sizeof(int)               and
                       outputs-array  sizeof(int) PROC-MAX-IO * and
                       outputs-length sizeof(int)               in

                  while true do
                    source-name source-file line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting procedure input type.\n" log-stream fputs
                      token-address log-stream fput-here
                      proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                      1 call-sys-exit
                    end

                    let input-token-type input-token-address input-token-arg in
                      input-token-type TYPE-KEYWORD = if
                        input-token-arg KEYWORD-RETURNS != if
                          LOG.ERR log-stream fputs "Unexpected keyword while expecting input type, got '" log-stream fputs input-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                          token-address log-stream fput-here
                          proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                          1 call-sys-exit
                        end

                        break
                      else input-token-type TYPE-TYPE = if
                        // TODO: Check if the input queue was filled.
                        input-token-arg inputs-array inputs-length queue64.append
                      else
                        "Expected a 'type' for input type, got '" log-stream fputs input-token-type log-stream fput-type "'.\n" log-stream fputs
                        input-token-address log-stream fput-here
                        proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                        1 call-sys-exit
                      end end
                    end
                  end

                  while true do
                    source-name source-file line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting procedure output type.\n" log-stream fputs
                      token-address log-stream fput-here
                      proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                      1 call-sys-exit
                    end

                    let output-token-type output-token-address output-token-arg in
                      output-token-type TYPE-KEYWORD = if
                        output-token-arg KEYWORD-IN != if
                          LOG.ERR log-stream fputs "Unexpected keyword while expecting output type, got '" log-stream fputs output-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                          token-address log-stream fput-here
                          proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                          1 call-sys-exit
                        end

                        break
                      else output-token-type TYPE-TYPE = if
                        // TODO: Check if the output queue was filled.
                        output-token-arg outputs-array outputs-length queue64.append
                      else
                        LOG.ERR log-stream fputs "Expected a 'type' for output type, got '" log-stream fputs output-token-type log-stream fput-type "'.\n" log-stream fputs
                        output-token-address log-stream fput-here
                        proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                        1 call-sys-exit
                      end end
                    end
                  end

                  memory local-stack        sizeof(int) STACK-MAX-ITEMS * and
                         local-stack-length sizeof(int)                   in

                    0 local-stack-length !64

                    // TODO: This system must be changed.
                    0 while dup inputs-length @64 < do let i in
                      inputs-array i 8 * + @64 let type in
                        type TYPE-INT = if
                          create-int local-stack local-stack-length queue64.append
                        else type TYPE-BOOL = if
                          create-bool local-stack local-stack-length queue64.append
                        else
                          LOG.ERR log-stream fputs "Input types for procedure '" log-stream fputs proc-name-token-arg proc-name-token-arg mlength log-stream fputs "' had an unknown type, got '" log-stream fputs type log-stream fputu "'.\n" log-stream fputs
                          LOG.INFO log-stream fputs "This error is probably caused by a bug in the compiler.\n" log-stream fputs
                          proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                          1 call-sys-exit
                        end end
                      end
                    i end inc end drop

                    source-name source-file output-file
                    line-no char-no
                    data-definitions-array datas-length
                    global-names-array global-sizes-array globals-length
                    macro-names-array macro-tokens-array macros-length
                    proc-name-token-arg proc-name-token-address
                    local-stack local-stack-length
                    log-stream
                    compile-procedure
                    
                    ".return:\n"                        output-file fputs
                    "    xchg    rsp, [call_ptr]\n"     output-file fputs
                    "    pop     qword [local_ptr]\n"   output-file fputs
                    "    pop     rax\n"                 output-file fputs
                    "    xchg    rsp, [call_ptr]\n"     output-file fputs
                    "    jmp     rax\n"                 output-file fputs

                    // TODO: This system must be changed.
                    memory temp-outputs-length sizeof(ptr) in
                      outputs-length @64 temp-outputs-length !64
                      while local-stack-length @64 isn-zero do
                        local-stack local-stack-length queue64.pop-last let type in
                          temp-outputs-length @64 is-zero if
                            LOG.ERR log-stream fputs "Procedure's stack is too large for its returns.\n" log-stream fputs LOG.RESET log-stream fputs
                            proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                            1 call-sys-exit
                          end
                          
                          outputs-array temp-outputs-length queue64.pop-last let check in
                            type @64 check != if
                              LOG.ERR log-stream fputs "Procedure's stack is not matching with its return types.\n" log-stream fputs LOG.RESET log-stream fputs
                              proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                              1 call-sys-exit
                            end
                          end
                        end
                      end

                      temp-outputs-length @64 isn-zero if
                        LOG.ERR log-stream fputs "Procedure's stack is missing some of its returns.\n" log-stream fputs LOG.RESET log-stream fputs
                        proc-name-token-arg proc-name-token-address log-stream fput-inside-procedure
                        1 call-sys-exit
                      end
                    end
                  end
                end

                proc-name-token-address mfree
              end
              
              token-address mfree
            else
              LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
              token-address log-stream fput-here
              1 call-sys-exit
            end end end end
            
          else
            LOG.ERR log-stream fputs "Expected a keyword type, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
            token-address log-stream fput-here
            1 call-sys-exit
          end
        end
      end drop drop drop
    end

    "segment .data\n" output-file fputs
    0 while dup datas-length @64 < do let i in
      "    data_" output-file fputs i output-file fputu ": db " output-file fputs
      data-definitions-array i 8 * + @64 let data in
        0 while dup data mlength < do let j in
          j data + @8 output-file fputu ", " output-file fputs
        j end inc end drop
      end
      "\n" output-file fputs
    i end inc end drop

    // TODO: Print the global variables to file.
    
    "
segment .bss
    local_memory:   resb 67108864
    local_ptr:      resq 1
    call_stack:     resq 67108864
    call_ptr:       resq 1
" output-file fputs
    
    source-file fclose drop
  end
end end


proc main
  int int -- int
in let argc argv in
  // Initialize malloc.
  malloc.init

  // Make file name dynamic.
  SOURCE-NAME to-dynamic let source-name in
    source-name is-null if
      "'malloc' failed while making the source name dynamic.\n" eputs
      1 call-sys-exit
    end
    
    OUTPUT-NAME drop unlink drop
    OUTPUT-NAME drop 0o777 creat dup isn-pos if
      "Could not create output file.\n" eputs
      1 call-sys-exit
    end

    let output in
      // Check if the file is opened successfully.
      output isn-pos if
        "Could not open output file.\n" eputs
        1 call-sys-exit
      end
 
      memory global-names-array     sizeof(ptr) GLOBALS-MAX-COUNT    * and
             global-sizes-array     sizeof(ptr) GLOBALS-MAX-COUNT    * and
             globals-length         sizeof(int)                        and
             
             macro-names-array      sizeof(ptr) MACROS-MAX-COUNT     * and
             macro-tokens-array     sizeof(ptr) MACROS-MAX-COUNT     * and
             macros-length          sizeof(int)                        and
             
             data-definitions-array sizeof(ptr) MACROS-MAX-COUNT     * and
             datas-length           sizeof(int)                        and
             
             libraries-array        sizeof(int) LIBRARIES-MAX-COUNT  * and
             libraries-length       sizeof(int)                        in

        0 globals-length   !64
        0 macros-length    !64
        0 libraries-length !64

        source-name output
        data-definitions-array datas-length
        global-names-array global-sizes-array globals-length
        macro-names-array macro-tokens-array macros-length
        libraries-array libraries-length
        STDERR
        compile-file
      end
      
      output fclose drop
    end
  end
end 0 end


/*

Name definitions:
  Public:
    Global variables
    Macros
    Procedures
  Private:
    Local variables
    Let variables

Stack data:  
  0  - 7  -> type
  8  - n  -> args

1: Integer constant args:
  8  - 15 -> constant

2: Real stack data args:

3: Read address args:
  8  - 15 -> address

4: Global address args:
  8  - 15 -> global address name

n: Operator args (addition, subtraction, multiplication, division, bit shifting, bitwise operators):
  8  - 15 -> constant
  16 - n  -> other operands

Differences with the Python compiler:
  - In this compiler, if a name is redefined; it is overwritten. In the Python compiler, that would cause an error.
  - Precompilation.

Syscall register arguments:
%rdi %rsi %rdx %r10 %r8 %r9.
    
TODO: There are many tokens, whose address and/or argument should have been 'mfree'd.
*/
