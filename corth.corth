include libs/linux_x86/io.corth
include libs/linux_x86/sys.corth

macro malloc.ARRAY-SIZE           0x10000 endmacro
macro malloc.AVAIL-QUEUE-SIZE     0x1000  endmacro
include libs/dynamic/malloc.corth
include libs/dynamic/utils.corth

include libs/memory.corth

include libs/collections/queue64.corth
include libs/collections/str_map64.corth

macro CHAR-NULL      0  endmacro
macro CHAR-NEWLINE   10 endmacro
macro CHAR-ESCAPE    27 endmacro
macro CHAR-SPACE     32 endmacro
macro CHAR-DQUOTE    34 endmacro
macro CHAR-ASTERISK  42 endmacro
macro CHAR-SLASH     47 endmacro
macro CHAR-BACKSLASH 92 endmacro
macro CHAR-SQUOTE    96 endmacro

include debug.corth
include enums.corth


// TODO: Make not hard-coded
macro SOURCE-NAME "./example.corth" endmacro
macro OUTPUT-NAME "./o.asm" endmacro

macro GLOBALS-MAX-COUNT   0x4000 endmacro
macro MACROS-MAX-COUNT    0x4000 endmacro
macro TOKEN-MAX-LENGTH    0x4000 endmacro
macro MACRO-MAX-TOKENS    0x4000 endmacro
macro LIBRARIES-MAX-COUNT 0x4000 endmacro
macro PROC-MAX-IO         0x1000 endmacro
macro STACK-MAX-ITEMS     0x100  endmacro
macro LOCAL-MEMORY-SIZE   0X4000 endmacro
macro CALL-STACK-SIZE     0x4000 endmacro

macro STACK-TYPE-REAL-INT           0 endmacro
macro STACK-TYPE-INT-CONSTANT   1 endmacro
macro STACK-TYPE-BOOL-CONSTANT  2 endmacro


proc fread
  // ptr: start int: length file-desc: file-desc
  ptr int file-desc -- int
  // Reads a region of a file stream and returns file pointer to its original position.
in let start length file in
  // Get original position.
  file ftell let original in
  
    // Read bytes and return the total bytes read.
    start length file fgets

    // Return the file pointer to its original pointer.
    file original SEEK-SET fseek drop
  end
end end


proc strip-file
  // file-desc: file ptr: line-no ptr: char-no -- bool: reached-eof
  file-desc ptr ptr -- bool
  // Removes the newline and spaces from the start of a file stream
  // Keeps track the line and char number as the bytes are read.
  // Also, checks if EOF is reached.
in let file line-no char-no in
  memory char 1 in
    while true do
      char 1 file fgets is-zero if
        true return
      else char @8 CHAR-NEWLINE = if
        0 char-no !64
        line-no @inc64
      else char @8 CHAR-SPACE = if
        char-no @inc64
      else
        file 1 neg SEEK-CUR fseek drop
        false return
      end end end
    end
  end
end false end  // dummy return


proc parse-next-token
  // file-desc: file-desc ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream --
  file-desc ptr ptr ptr ptr file-desc --
  // Gets the next token string before any newline or space and fills a buffer.
  // Keeps track of the line and char number as the bytes are read.
  // NOTE: If buffer-end exceeds buffer + TOKEN-MAX-LENGTH, exits program.
in let file line-no char-no buffer buffer-end log-stream in
    while true do
      buffer-end @64 1 file fread is-zero if                // Reached end of file.
        char-no @inc64
        return
      else buffer-end @64 @8 CHAR-NEWLINE = if              // Reached newline.
        char-no @inc64
        return
      else buffer-end @64 @8 CHAR-SPACE = if                // Reached space.
        char-no @inc64
        return
      else buffer-end @64 buffer - TOKEN-MAX-LENGTH >= if   // Reached the end of the buffer.
        LOG.ERR log-stream fputs "Found a token longer than TOKEN-MAX-LENGTH, stopping execution.\n" log-stream fputs
        1 call-sys-exit
      else                                                  // There is still space in the buffer.
        file 1 SEEK-CUR fseek drop
        buffer-end @inc64
        char-no    @inc64
      end end end end
    end
end end


proc parse-next-string
  // file-desc: file-desc ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream --
  file-desc ptr ptr ptr ptr file-desc --
  // Gets the next string before a double quote.
  // Keeps track of the line and char number as the bytes are read.
  // NOTE: If buffer-end exceeds buffer + TOKEN-MAX-LENGTH, exits program.
  // NOTE: If EOF is reached before a double quote is found, exits program.
  // TODO: Add escapes.
in let file line-no char-no buffer buffer-end log-stream in
  while true do
    buffer-end @64 1 file fgets is-zero if                  // Reached end of file.
      LOG.ERR log-stream fputs "Reached EOF before finding any '\"'.\n" log-stream fputs
      1 call-sys-exit
    else buffer-end @64 @8 CHAR-DQUOTE = if                 // Reached double quote.
      char-no    @inc64
      return
    else buffer-end @64 buffer - TOKEN-MAX-LENGTH >= if     // Reached the end of the buffer.
      LOG.ERR log-stream fputs "Found a string longer than TOKEN-MAX-LENGTH, stopping execution.\n" log-stream fputs
      1 call-sys-exit
    else buffer-end @64 @8 CHAR-NEWLINE = if                // Reached new line.
      buffer-end @inc64
      line-no    @inc64
      0 char-no !64
    else                                                   
      buffer-end @inc64
      char-no    @inc64
    end end end end
  end
end end


proc skip-line
  // file-desc: file-desc ptr: line-no ptr: char-no file-desc: log-stream --
  file-desc ptr ptr file-desc --
  // Moves the file pointer until it passes a newline, or EOF is reached.
  // Keeps track of the line and char number as the bytes are read.
in let file line-no char-no log-stream in
  line-no @inc64
  0 char-no !64
  
  memory char 1 in
    while true do
      char 1 file fgets is-zero if
        return
      else char @8 CHAR-NEWLINE = if
        return
      end end
    end
  end
end end


proc skip-block-comment
  // file-desc: file-desc ptr: line-no ptr: char-np file-desc: log-stream --
  file-desc ptr ptr file-desc --
  // Moves the file pointer until it passes a block comment end, or EOF is reached.
  // Keeps track of the line and char number as the bytes are read.
in let file line-no char-no log-stream in
  memory char 1 in
    while true do
      char 1 file fgets is-zero if                          // Reached EOF while expecting a block comment end.
        LOG.WARN log-stream fputs "Reached EOF while expecting a block comment end.\n" log-stream fputs
        return
        
      else char @8 CHAR-ASTERISK = if                       // Reached asterisk.
        char 1 file fgets is-zero if                        // Reached EOF while expecting a block comment end.
          LOG.WARN log-stream fputs "Reached EOF while expecting a block comment end.\n" log-stream fputs
          return
        end

        char @8 CHAR-SLASH = if                             // Reached block comment end.
          return
        end
        
      else char @8 CHAR-NEWLINE = if                        // Reached a newline.
        line-no @inc64
        0 char-no !64
        
      else                                                  // Reached any other character
        char-no @inc64
      end end end
    end
  end
end end


proc create-name-token
  // ptr: file-name file-desc: file-desc int: start-line int: start-char int: start-at ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream -- int: token-type ptr: address [int|ptr]: arg bool: is-available
  ptr file-desc int int int ptr ptr ptr ptr file-desc -- int ptr int bool
  // Checks if the name is a keyword or an intrinsic, and creates a new token.
  // TODO: Implement keywords.
  // TODO: Implement intrinsic keywords.
in let file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream in
  // Get full token.
  file line-no char-no buffer buffer-end log-stream parse-next-token

  buffer-end @64 buffer - let buffer-size in
    // Check if the token is a keyword.
    // I hate my life.
         buffer buffer-size KEYWORD-INCLUDE-STR    memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-INCLUDE    true
    else buffer buffer-size KEYWORD-MACRO-STR      memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-MACRO      true
    else buffer buffer-size KEYWORD-ENDMACRO-STR   memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-ENDMACRO   true
    else buffer buffer-size KEYWORD-PROC-STR       memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-PROC       true
    else buffer buffer-size KEYWORD-END-STR        memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-END        true
    else buffer buffer-size KEYWORD-RETURN-STR     memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-RETURN     true
    else buffer buffer-size KEYWORD-RETURNS-STR    memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-RETURNS    true
    else buffer buffer-size KEYWORD-MEMORY-STR     memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-MEMORY     true
    else buffer buffer-size KEYWORD-AND-STR        memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-AND        true
    else buffer buffer-size KEYWORD-IN-STR         memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-IN         true
    else buffer buffer-size KEYWORD-LET-STR        memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-LET        true
    else buffer buffer-size KEYWORD-IF-STR         memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-IF         true
    else buffer buffer-size KEYWORD-ELSE-STR       memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-ELSE       true
    else buffer buffer-size KEYWORD-WHILE-STR      memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-WHILE      true
    else buffer buffer-size KEYWORD-DO-STR         memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-DO         true
    else buffer buffer-size KEYWORD-BREAK-STR      memeq8 if TYPE-KEYWORD file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address KEYWORD-BREAK      true
    
    // I still hate my life.
    else buffer buffer-size INTRINSIC-ADD-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-ADD      true
    else buffer buffer-size INTRINSIC-SUB-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SUB      true
    else buffer buffer-size INTRINSIC-MUL-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-MUL      true
    else buffer buffer-size INTRINSIC-MUL2-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-MUL2     true
    else buffer buffer-size INTRINSIC-FULLMUL-STR  memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-FULLMUL  true
    else buffer buffer-size INTRINSIC-DIV-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-DIV      true
    else buffer buffer-size INTRINSIC-MOD-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-MOD      true
    else buffer buffer-size INTRINSIC-DIVMOD-STR   memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-DIVMOD   true
    else buffer buffer-size INTRINSIC-UMUL-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UMUL     true
    else buffer buffer-size INTRINSIC-UMUL2-STR    memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UMUL2    true
    else buffer buffer-size INTRINSIC-UFULLMUL-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UFULLMUL true
    else buffer buffer-size INTRINSIC-UDIV-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UDIV     true
    else buffer buffer-size INTRINSIC-UMOD-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UMOD     true
    else buffer buffer-size INTRINSIC-UDIVMOD-STR  memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-UDIVMOD  true
    else buffer buffer-size INTRINSIC-BAND-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BAND     true
    else buffer buffer-size INTRINSIC-BOR-STR      memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BOR      true
    else buffer buffer-size INTRINSIC-BXOR-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BXOR     true
    else buffer buffer-size INTRINSIC-BNOT-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-BNOT     true
    else buffer buffer-size INTRINSIC-EQUAL-STR    memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-EQUAL    true
    else buffer buffer-size INTRINSIC-LESS-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-LESS     true
    else buffer buffer-size INTRINSIC-TRUE-STR     memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-TRUE     true
    else buffer buffer-size INTRINSIC-FALSE-STR    memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-FALSE    true
    else buffer buffer-size INTRINSIC-LOAD8-STR    memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-LOAD8    true
    else buffer buffer-size INTRINSIC-STORE8-STR   memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-STORE8   true
    else buffer buffer-size INTRINSIC-LOAD64-STR   memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-LOAD64   true
    else buffer buffer-size INTRINSIC-STORE64-STR  memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-STORE64  true
    else buffer buffer-size INTRINSIC-SYSCALL0-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL0 true
    else buffer buffer-size INTRINSIC-SYSCALL1-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL1 true
    else buffer buffer-size INTRINSIC-SYSCALL2-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL2 true
    else buffer buffer-size INTRINSIC-SYSCALL3-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL3 true
    else buffer buffer-size INTRINSIC-SYSCALL4-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL4 true
    else buffer buffer-size INTRINSIC-SYSCALL5-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL5 true
    else buffer buffer-size INTRINSIC-SYSCALL6-STR memeq8 if TYPE-INTRINSIC file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address INTRINSIC-SYSCALL6 true
    
    else buffer buffer-size TYPE-INT-STR           memeq8 if TYPE-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address TYPE-INT           true
    else buffer buffer-size TYPE-BOOL-STR          memeq8 if TYPE-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address TYPE-BOOL          true
    else
      // Return token type, address and argument.
      TYPE-NAME file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address buffer buffer-size to-dynamic true

    // This is nightmare fuel.
    end end end end end end end end end end end end end end end end end
    end end end end end end end end end end end end end end end end end 
    end end end end end end end end end end end end end end end end end
  end
end end


proc get-next-token
  // ptr: file-name file-desc: file-desc ptr: line-no ptr: char-no file-desc: log-stream -- int: token-type ptr: address [int|ptr]: arg bool: is-available 
  ptr file-desc ptr ptr file-desc -- int ptr int bool
  // Generates a token and returns.
  // NOTE: If there is no token available, every other parameter is either NULLPTR or invalid.
  // TODO: Create a new queue for the saved tokens when a macro is called.
  // TODO: Change this procedure so that it returns the next saved token, if there is one.
in let file-name file line-no char-no log-stream in
  memory buffer     TOKEN-MAX-LENGTH and
         buffer-end sizeof(int)      in

    file line-no char-no strip-file if
      TYPE-UNKNOWN NULLPTR 0 false return
    end
    
    buffer buffer-end !64

    line-no @64 char-no @64 file ftell let start-line start-char start-at in
      buffer 1 file fgets drop
      buffer-end @inc64
    
      buffer @8 '0' '9' is-range if
        // -------- Integer type --------

        // Get full token.
        file line-no char-no buffer buffer-end log-stream parse-next-token

        TYPE-INTEGER file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address
        
        buffer buffer-end @64 buffer - str.to-int ! if
          drop
          LOG.ERR log-stream fputs "Could not convert integer.\n" log-stream fputs LOG.RESET log-stream fputs
          log-stream fput-here
          1 call-sys-exit
          drop
          TYPE-UNKNOWN NULLPTR 0 false return // dummy return
        end

        true
        
      else buffer @8 CHAR-SQUOTE = if
        // -------- Characters --------
        
        buffer inc 1 file fgets is-zero if                  // Reached EOF while expecting a character.
          LOG.ERR log-stream fputs "Reached EOF before finding a character after single quote.\n" log-stream fputs LOG.RESET log-stream fputs
          1 call-sys-exit
        end

        // Get the character
        buffer inc @8 let character in
          character CHAR-BACKSLASH = if
            // -------- Escapes --------
            // TODO: Add escapes.
            LOG.TODO log-stream fputs "Escapes are not implemented yet.\n" log-stream fputs
            1 call-sys-exit
          end
          
          buffer 2 + 1 file fgets is-zero if              // Reached EOF while expecting a single quote.
            LOG.ERR log-stream fputs "Reached EOF before finding a single quote after single quote and character.\n" log-stream fputs
            1 call-sys-exit
          end

          buffer 2 + @8 CHAR-SQUOTE != if                 // Was expecting a single quote, but found another character.
            LOG.ERR log-stream fputs "Expected a single quote, found '" log-stream fputs buffer 2 + 1 log-stream fputs "'.\n" log-stream fputs
            1 call-sys-exit
          end

          // Return token type, address and argument.
          TYPE-INTEGER file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address character true
        end
        
      else buffer @8 CHAR-DQUOTE = if
        // -------- String type --------

        // Move the buffer-end left once, so the quote is removed.
        buffer-end @dec64

        char-no @inc64

        // Get full string.
        file line-no char-no buffer buffer-end log-stream parse-next-string

        // Return token type, address and argument.
        TYPE-STRING file-name start-line start-char start-at line-no @64 char-no @64 file ftell log-stream generate-address buffer buffer-end @64 buffer - to-dynamic true
        
      else buffer @8 CHAR-SLASH = if
        // -------- Slash (Name and comments) --------
        
        buffer inc 1 file fgets is-zero if
          LOG.ERR log-stream fputs "Reached EOF while expecting character after slash (/).\n" log-stream fputs
          1 call-sys-exit
        end
          
        buffer inc @8 CHAR-SLASH = if
          // -------- Single line comment --------

          // Skip this line.
          file line-no char-no log-stream skip-line

          // Get next token and return it.
          file-name file line-no char-no log-stream get-next-token

        else buffer inc @8 CHAR-ASTERISK = if
          // -------- Block comment --------

          // Skip the block comment.
          file line-no char-no log-stream skip-block-comment

          // Get next token and return it.
          file-name file line-no char-no log-stream get-next-token

        else
          // -------- Name and keyword types --------
          file 1 neg SEEK-CUR fseek drop

          file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream create-name-token
        end end

      else
        // -------- Name and keyword types --------
        file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream create-name-token
      end end end end
    end
  end
end end


proc fput-inside-procedure
  // ptr: procedure-name ptr: procedure-address file-desc: log-stream
  ptr ptr file-desc --
in let name address log-stream in
  LOG.INFO log-stream fputs "Inside procedure '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
  address log-stream fput-here
end end


proc create-constant-int
  // int: constant-value -- ptr: stack-data
  int -- ptr
in let constant in
  16 malloc let x in
    x is-null if
      "'malloc' failed while creating an integer constant.\n" eputs
      1 call-sys-exit
    end

    STACK-TYPE-INT-CONSTANT x     !64
    constant                x 8 + !64
  x end
end end


proc create-real-int
  // -- ptr: stack-data
  -- ptr
in
  8 malloc let x in
    x is-null if
      "'malloc' failed while creating a real stack value.\n" eputs
      1 call-sys-exit
    end

    STACK-TYPE-REAL-INT x !64
  x end
end


proc move-value-to-register
  // ptr: data ptr: register-name-start int: register-name-length
  ptr ptr int
  // file-desc: output-file  ptr: blame-address ptr: blame-procedure-name ptr: blame-procedure-token
  file-desc ptr ptr ptr
  // file-desc: log-stream
  file-desc
  --
in let
    data start length
    output-file blame-address blame-procedure-name blame-procedure-address
    log-stream
  in
  
  data @64 let type in
    type STACK-TYPE-REAL-INT = if
      // Value was on the stack, pop it from the stack.
      "    pop     " output-file fputs start length output-file fputs "\n" output-file fputs
    else type STACK-TYPE-INT-CONSTANT = if
      // Value was a constant.
      data 8 + @64 let arg in
        arg is-zero if
          // Value was zero. Best way to set a register to 0 is by 'xor reg, reg'.
          "    xor     " output-file fputs start length output-file fputs ", " output-file fputs start length output-file fputs "\n" output-file fputs
        else
          // Value was not zero, move the value to the register.
          "    mov     " output-file fputs start length output-file fputs ", " output-file fputs arg output-file fputu "\n" output-file fputs
        end
      end
    else
      LOG.TODO log-stream fputs "Stack data type " output-file fputs type log-stream fputu " can not be moved to a register yet.\n" log-stream fputs
      blame-address log-stream fput-here
      blame-procedure-name blame-procedure-address log-stream fput-inside-procedure
      1 call-sys-exit
    end end
  end
end end


proc compile-procedure
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: data-definitions-array ptr: datas-length 
  ptr ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: inputs-array ptr: inputs-length
  ptr ptr
  // file-desc: log-stream
  file-desc --
  
  // Compiles a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let log-stream in

  // TODO: Move this to compile-file.
  memory local-stack        sizeof(ptr) STACK-MAX-ITEMS *  and
         local-stack-length sizeof(ptr)                    in

  0 local-stack-length !64
  
  let inputs-array inputs-length in
    0 while dup inputs-length @64 < do
      dup 8 * inputs-array + @64 let input in
        input TYPE-INT = if
          create-real-int local-stack local-stack-length queue64.append
        else
          drop let
            source-name source-file output-file
            line-no char-no
            data-definitions-array datas-length
            global-names-array global-sizes-array globals-length
            macro-names-array macro-tokens-array macros-length
            procedure-name procedure-address
          in
            LOG.TODO log-stream fputs "Type '" log-stream fputs input log-stream fputu "' can not be an input for procedures yet.\n" log-stream fputs
            procedure-name procedure-address log-stream fput-inside-procedure
            1 call-sys-exit
            return
          end
        end
      end
    inc end drop
  end

  let
    source-name source-file output-file
    line-no char-no
    data-definitions-array datas-length
    global-names-array global-sizes-array globals-length
    macro-names-array macro-tokens-array macros-length
    procedure-name procedure-address
  in
    "proc_" output-file fputs procedure-name procedure-name mlength output-file fputs ":\n" output-file fputs

    while true do
      source-name source-file line-no char-no log-stream get-next-token ! if
        LOG.ERR log-stream fputs "Reached EOF while expecting procedure definition.\n" log-stream fputs
        procedure-name procedure-address log-stream fput-inside-procedure
        1 call-sys-exit
      end

      let token-type token-address token-arg in
        token-type TYPE-INTEGER = if
          // -------- Constant integer --------
          
          token-arg create-constant-int local-stack local-stack-length queue64.append
        else token-type TYPE-STRING = if
          // -------- Strings --------

          // TODO: Change this to GLOBAL ADDRESS DATA
          "    mov     rax, data_" output-file fputs datas-length @64 output-file fputu "\n" output-file fputs
          "    push    rax\n" output-file fputs

          create-real-int                       local-stack local-stack-length queue64.append
          token-arg mlength create-constant-int local-stack local-stack-length queue64.append

          token-arg data-definitions-array datas-length queue64.append
          
        else token-type TYPE-INTRINSIC = if
          token-arg INTRINSIC-ADD = if
            // -------- Intrinsic 'add' --------

            // TODO: Add checks for the stack length.
            local-stack local-stack-length queue64.pop-last
            local-stack local-stack-length queue64.pop-last

            let x y in
              x @64 STACK-TYPE-INT-CONSTANT = y @64 STACK-TYPE-INT-CONSTANT = & if
                // Just add the constants and push back.
                x 8 + @64 y 8 + @64 + x 8 + !64
                x local-stack local-stack-length queue64.append
                y mfree
              else
                LOG.TODO log-stream fputs "The compiler can not calculate this yet.\n" log-stream fputs
                token-address log-stream fput-here
                procedure-name procedure-address log-stream fput-inside-procedure
                1 call-sys-exit
              end
            end
          else token-arg INTRINSIC-SYSCALL3  = if
            // -------- Intrinsic 'syscall3' --------
            
            // TODO: Add checks for the stack length.
            local-stack local-stack-length queue64.pop-last dup "rax" output-file token-address procedure-name procedure-address log-stream move-value-to-register mfree
            local-stack local-stack-length queue64.pop-last dup "rdx" output-file token-address procedure-name procedure-address log-stream move-value-to-register mfree
            local-stack local-stack-length queue64.pop-last dup "rsi" output-file token-address procedure-name procedure-address log-stream move-value-to-register mfree
            local-stack local-stack-length queue64.pop-last dup "rdi" output-file token-address procedure-name procedure-address log-stream move-value-to-register mfree
            
            "    syscall\n"     output-file fputs
            "    push    rax\n" output-file fputs

            create-real-int local-stack local-stack-length queue64.append
            
          else
            LOG.TODO log-stream fputs "Intrinsic '" log-stream fputs token-arg log-stream fput-intrinsic "' is not implemented yet.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            1 call-sys-exit
          end end
        else token-type TYPE-KEYWORD = if
          token-arg KEYWORD-END = if
            break
          else
            LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
            token-address log-stream fput-here
            procedure-name procedure-address log-stream fput-inside-procedure
            1 call-sys-exit
          end
        else
          LOG.ERR log-stream fputs "Unexpected type, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
          token-address log-stream fput-here
          procedure-name procedure-address log-stream fput-inside-procedure
          1 call-sys-exit
        end end end end
      end
    end

    "
.return:
    xchg    rsp, [call_ptr]
    pop     QWORD [local_ptr]
    pop     rax
    xchg    rsp, [call_ptr]
    jmp     rax
" output-file fputs
  end
end end end


proc compile-file
  // ptr: source-name file-desc: output-file
  ptr file-desc
  // ptr: data-definitions-array ptr: datas-length 
  ptr ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // libraries-array ptr: libraries-length
  ptr ptr 
  // file-desc: log-stream
  file-desc --
  
  // Compiles a Corth source file.
  // Compilation warning and errors are dumped to log-stream.
in let
  source-name output-file
  data-definitions-array datas-length
  global-names-array global-sizes-array globals-length
  macro-names-array macro-tokens-array macros-length
  libraries-array libraries-length
  log-stream in

  source-name add-null let c-source-name in
    c-source-name fopen-read
    c-source-name mfree
  end
  
  let source-file in
    // Check if the source is opened.
    source-file isn-pos if
      LOG.ERR log-stream fputs "Could not open source file '" log-stream fputs source-name source-name mlength dec log-stream fputs "'\n" log-stream fputs LOG.RESET log-stream fputs
      1 call-sys-exit
    end

"
segment .text
global _start

_start:
    mov     QWORD [call_ptr], call_stack
    add     QWORD [call_ptr], 0x4000
    mov     QWORD [local_ptr], local_memory

    xchg    rsp, [call_ptr]
    push    corth_endofprogram
    push    QWORD [local_ptr]
    xchg    rsp, [call_ptr]
    jmp     proc_main

corth_endofprogram:
    mov     rax, 60
    pop     rdi
    syscall

" output-file fputs
    
    memory line-no sizeof(int) and
           char-no sizeof(int) in

      // Reset line-no and char-no variables.
      1 line-no !64
      0 char-no !64

      // Get next token and check if there is one available.
      while source-name source-file line-no char-no log-stream get-next-token do
        let token-type token-address token-arg in
          token-type TYPE-KEYWORD = if
            // -------- Global keywords --------            
            token-arg KEYWORD-INCLUDE = if
              // -------- 'include' keyword --------
              // TODO: Create a function to include.
              // TODO: Allow including packages.
              // TODO: Add library search locations.
              // TODO: Add pragma once.

              // Get the next token, which should be the include path.
              source-name source-file line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting an include path.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let path-token-type path-token-address path-token-arg in
                path-token-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for path after 'include', got '" log-stream fputs path-token-type log-stream fput-type "'.\n" log-stream fputs
                  path-token-address log-stream fput-here
                  1 call-sys-exit
                end
                
                path-token-arg output-file
                data-definitions-array datas-length
                global-names-array global-sizes-array globals-length
                macro-names-array macro-tokens-array macros-length
                libraries-array libraries-length
                log-stream compile-file

                // Deallocate the space for the token addresses.
                path-token-address mfree
              end

              token-address mfree
              
            else token-arg KEYWORD-MEMORY = if
              // -------- 'memory' keyword --------
              
              // Get the next token, which sould be the include path.
              source-name source-file line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a global variable name.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let variable-name-token-type variable-name-token-address variable-name-token-arg in
                variable-name-token-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for global variable name after 'memory', got '" log-stream fputs variable-name-token-type log-stream fput-type "'.\n" log-stream fputs
                  variable-name-token-address log-stream fput-here
                  1 call-sys-exit
                end

                // TODO: Implement size calculation.
                source-name source-file line-no char-no log-stream get-next-token ! if
                  LOG.ERR log-stream fputs "Reached EOF while expecting a global variable size.\n" log-stream fputs
                  token-address log-stream fput-here
                  1 call-sys-exit
                end

                let variable-size-token-type variable-size-token-address variable-size-token-arg in
                  variable-size-token-type TYPE-INTEGER != if
                    LOG.ERR log-stream fputs "Expected an 'int' for global variable size after 'memory', got '" log-stream fputs variable-size-token-type log-stream fput-type ".\n" log-stream fputs
                    variable-size-token-type log-stream fput-here
                    1 call-sys-exit
                  end

                  source-name source-file line-no char-no log-stream get-next-token ! if
                    LOG.ERR log-stream fputs "Reached EOF while expecting global variable size.\n" log-stream fputs
                    token-address log-stream fput-here
                    1 call-sys-exit
                  end

                  let end-token-type end-token-address end-token-arg in
                    end-token-type TYPE-KEYWORD != if
                      LOG.ERR log-stream fputs "Expected an 'int' for global variable size after 'memory', got '" log-stream fputs end-token-type log-stream fput-type "'.\n" log-stream fputs
                      end-token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    end-token-arg KEYWORD-END != if
                      LOG.ERR log-stream fputs "Unexpected keyword while expecting global variable size, got '" log-stream fputs end-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                      end-token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    end-token-address mfree
                  end

                  // TODO: Check if the global variable queue was filled.
                  variable-name-token-arg variable-size-token-arg global-names-array global-sizes-array globals-length str-map64.set drop

                  variable-size-token-address mfree
                end

                variable-name-token-address mfree
              end

              token-address mfree
              
            else token-arg KEYWORD-MACRO = if
              // -------- 'macro' keyword --------

              // Get the next token, which should be the name of the macro.
              source-name source-file line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a macro name.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let macro-name-token-type macro-name-token-address macro-name-token-arg in
                macro-name-token-type TYPE-NAME != if
                  LOG.ERR log-stream fputs "Expected a 'name' for macro name after 'macro', got '" log-stream fputs macro-name-token-arg log-stream fput-type "'.\n" log-stream fputs
                  macro-name-token-address log-stream fput-here
                  1 call-sys-exit
                end

                // macro-tokens-array and macro-tokens-length are used to create a QUEUE for macro tokens.
                memory new-macro-tokens-array  MACRO-MAX-TOKENS sizeof(int) * and
                       new-macro-tokens-length sizeof(int)                    in
                       
                  while true do
                   // Get next tokens, until an 'endmacro' is found.
                    source-name source-file line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting an 'endmacro' in macro '" log-stream fputs macro-name-token-arg macro-name-token-arg mlength log-stream fputs "'.\n" log-stream fputs
                      token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    let macro-new-token-type macro-new-token-address macro-new-token-arg in
                      macro-new-token-type TYPE-KEYWORD = if
                        macro-new-token-arg KEYWORD-ENDMACRO = if
                          break
                        end
                      end
                      
                      new-macro-tokens-length MACRO-MAX-TOKENS - 3 < if
                        LOG.ERR log-stream fputs "Macro '" log-stream fputs macro-name-token-arg macro-name-token-arg mlength log-stream fputs "' is longer than MACRO-MAX-TOKENS, stopping execution.\n" log-stream fputs
                        token-address log-stream fput-here
                        1 call-sys-exit
                      end
                      
                      macro-new-token-type    new-macro-tokens-array new-macro-tokens-length queue64.append
                      macro-new-token-address new-macro-tokens-array new-macro-tokens-length queue64.append
                      macro-new-token-arg     new-macro-tokens-array new-macro-tokens-length queue64.append
                    end
                  end

                  new-macro-tokens-array new-macro-tokens-length @64 to-dynamic
                end 

                let macro-tokens in
                  // TODO: Check if the macros queue was filled.
                  macro-name-token-arg macro-tokens macro-names-array macro-tokens-array macros-length str-map64.set drop
                end


                macro-name-token-address mfree
                macro-name-token-arg     mfree
              end

              token-address mfree
              
            else token-arg KEYWORD-PROC = if
              // -------- 'proc' keyword --------

              // Get the next token, which should be the name of the procedure.
              source-name source-file line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a procedure name.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let proc-name-token-type proc-name-token-address proc-name-token-arg in
                proc-name-token-type TYPE-NAME != if
                  "Expected a 'name' for procedure name after 'proc', got " log-stream fputs proc-name-token-type log-stream fput-type "'.\n" log-stream fputs
                  proc-name-token-type log-stream fput-here
                  1 call-sys-exit
                end

                // macro-tokens-array and macro-tokens-length are used to create a QUEUE for macro tokens.
                memory inputs-array   sizeof(int) PROC-MAX-IO * and
                       inputs-length  sizeof(int)               and
                       outputs-array  sizeof(int) PROC-MAX-IO * and
                       outputs-length sizeof(int)               in

                  while true do
                    source-name source-file line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting procedure input type.\n" log-stream fputs
                      token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    let input-token-type input-token-address input-token-arg in
                      input-token-type TYPE-KEYWORD = if
                        input-token-arg KEYWORD-RETURNS != if
                          LOG.ERR log-stream fputs "Unexpected keyword while expecting input type, got '" log-stream fputs input-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                          token-address log-stream fput-here
                          1 call-sys-exit
                        end

                        break
                      else input-token-type TYPE-TYPE = if
                        // TODO: Check if the input queue was filled.
                        input-token-arg inputs-array inputs-length queue64.append
                      else
                        "Expected a 'type' for input type, got '" log-stream fputs input-token-type log-stream fput-type "'.\n" log-stream fputs
                        input-token-address log-stream fput-here
                        1 call-sys-exit
                      end end
                    end
                  end

                  while true do
                    source-name source-file line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting procedure output type.\n" log-stream fputs
                      token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    let output-token-type output-token-address output-token-arg in
                      output-token-type TYPE-KEYWORD = if
                        output-token-arg KEYWORD-IN != if
                          LOG.ERR log-stream fputs "Unexpected keyword while expecting output type, got '" log-stream fputs output-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                          token-address log-stream fput-here
                          1 call-sys-exit
                        end

                        break
                      else output-token-type TYPE-TYPE = if
                        // TODO: Check if the output queue was filled.
                        output-token-arg outputs-array outputs-length queue64.append
                      else
                        "Expected a 'type' for output type, got '" log-stream fputs output-token-type log-stream fput-type "'.\n" log-stream fputs
                        output-token-address log-stream fput-here
                        1 call-sys-exit
                      end end
                    end
                  end

                  source-name source-file output-file
                  line-no char-no
                  data-definitions-array datas-length
                  global-names-array global-sizes-array globals-length
                  macro-names-array macro-tokens-array macros-length
                  proc-name-token-arg proc-name-token-address
                  inputs-array inputs-length
                  log-stream
                  compile-procedure
                end

                proc-name-token-address mfree
              end
              
              token-address mfree
            else
              LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
              token-address log-stream fput-here
              1 call-sys-exit
            end end end end
            
          else
            LOG.ERR log-stream fputs "Expected a keyword type, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
            token-address log-stream fput-here
            1 call-sys-exit
          end
        end
      end drop drop drop
    end

    "\nsegment .data\n" output-file fputs
    0 while dup datas-length @64 < do let i in
      "    data_" output-file fputs i output-file fputu ": db " output-file fputs
      data-definitions-array i 8 * + @64 let data in
        0 while dup data mlength < do let j in
          j data + @8 output-file fputu ", " output-file fputs
        j end inc end drop
      end
      // output-file 2 neg SEEK-CUR fseek drop
      "\n" output-file fputs
    i end inc end drop

    // TODO: Print the global variables to file.
    
    "
segment .bss
    local_memory:   resb 67108864
    local_ptr:      resq 1
    call_stack:     resq 67108864
    call_ptr:       resq 1
" output-file fputs
    
    source-file fclose
  end
end end


proc main
  int int -- int
in let argc argv in
  // Initialize malloc.
  malloc.init

  // Make file name dynamic.
  SOURCE-NAME to-dynamic let source-name in
    source-name is-null if
      "'malloc' failed while making the source name dynamic.\n" puts
      1 call-sys-exit
    end

    OUTPUT-NAME inc to-dynamic fopen-write let output in
      // Check if the file is opened successfully.
      output isn-pos if
        "Could not open output file.\n" puts
        1 call-sys-exit
      end
 
      memory global-names-array     sizeof(ptr) GLOBALS-MAX-COUNT    * and
             global-sizes-array     sizeof(ptr) GLOBALS-MAX-COUNT    * and
             globals-length         sizeof(int)                        and
             
             macro-names-array      sizeof(ptr) MACROS-MAX-COUNT     * and
             macro-tokens-array     sizeof(ptr) MACROS-MAX-COUNT     * and
             macros-length          sizeof(int)                        and
             
             data-definitions-array sizeof(ptr) MACROS-MAX-COUNT     * and
             datas-length           sizeof(int)                        and
             
             libraries-array        sizeof(int) LIBRARIES-MAX-COUNT  * and
             libraries-length       sizeof(int)                        in

        0 globals-length   !64
        0 macros-length    !64
        0 libraries-length !64

        source-name output
        data-definitions-array datas-length
        global-names-array global-sizes-array globals-length
        macro-names-array macro-tokens-array macros-length
        libraries-array libraries-length
        STDERR
        compile-file
      end
      
      output fclose
    end
  end
end 0 end


/*

Name definitions:
  Public:
    Global variables
    Macros
    Procedures
  Private:
    Local variables
    Let variables

Stack data:  
  0  - 7  -> type
  8  - n  -> args

1: Integer constant args:
  8  - 15 -> constant

2: Real stack data args:

3: Read address args:
  8  - 15 -> address

4: Global address args:
  8  - 15 -> global address name

n: Operator args (addition, subtraction, multiplication, division, bit shifting, bitwise operators):
  8  - 15 -> constant
  16 - n  -> other operands

Differences with the Python compiler:
  - In this compiler, if a name is redefined; it is overwritten. In the Python compiler, that would cause an error.
  - Precompilation.

Syscall register arguments:
%rdi %rsi %rdx %r10 %r8 %r9.
    
TODO: There are many tokens, whose address and/or argument should have been 'mfree'd.
*/
