include libs/linux_x86/io.corth
include libs/linux_x86/sys.corth

macro malloc.ARRAY-SIZE       262144 endmacro
macro malloc.AVAIL-QUEUE-SIZE 64     endmacro
include libs/dynamic/malloc.corth
include libs/dynamic/utils.corth

include libs/memory.corth

include libs/collections/queue64.corth

macro CHAR-NULL      0  endmacro
macro CHAR-NEWLINE   10 endmacro
macro CHAR-ESCAPE    27 endmacro
macro CHAR-SPACE     32 endmacro
macro CHAR-DQUOTE    34 endmacro
macro CHAR-ASTERISK  42 endmacro
macro CHAR-SLASH     47 endmacro
macro CHAR-BACKSLASH 92 endmacro
macro CHAR-SQUOTE    96 endmacro

include debug.corth
include enums.corth


// TODO: Make not hard-coded
macro FILE-NAME "example.corth" dec endmacro

macro TOKEN-MAX-LENGTH 0x4000 endmacro
macro MACRO-MAX-TOKENS 0x4000 endmacro
macro PROC-MAX-IO 0x100 endmacro


proc fread
  // ptr: start int: length file-desc: file-desc
  ptr int file-desc -- int
  // Reads a region of a file stream and returns file pointer to its original position.
in let start length file in
  // Get original position.
  file ftell let original in
  
    // Read bytes and return the total bytes read.
    start length file fgets

    // Return the file pointer to its original pointer.
    file original SEEK-SET fseek drop
  end
end end


proc strip-file
  // file-desc: file ptr: line-no ptr: char-no -- bool: reached-eof
  file-desc ptr ptr -- bool
  // Removes the newline and spaces from the start of a file stream
  // Keeps track the line and char number as the bytes are read.
  // Also, checks if EOF is reached.
in let file line-no char-no in
  memory char 1 in
    while true do
      char 1 file fgets is-zero if
        true return
      else char @8 CHAR-NEWLINE = if
        0 char-no !64
        line-no @inc64
      else char @8 CHAR-SPACE = if
        char-no @inc64
      else
        file 1 neg SEEK-CUR fseek drop
        false return
      end end end
    end
  end
end false end  // dummy return


proc lex-next-token
  // file-desc: file-desc ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream --
  file-desc ptr ptr ptr ptr file-desc --
  // Gets the next token string before any newline or space and fills a buffer.
  // Keeps track of the line and char number as the bytes are read.
  // NOTE: If buffer-end exceeds buffer + TOKEN-MAX-LENGTH, exits program.
in let file line-no char-no buffer buffer-end log-stream in
    while true do
      buffer-end @64 1 file fread is-zero if                // Reached end of file.
        char-no @inc64
        return
      else buffer-end @64 @8 CHAR-NEWLINE = if              // Reached newline.
        char-no @inc64
        return
      else buffer-end @64 @8 CHAR-SPACE = if                // Reached space.
        char-no @inc64
        return
      else buffer-end @64 buffer - TOKEN-MAX-LENGTH >= if   // Reached the end of the buffer.
        LOG.ERR log-stream fputs "Found a token longer than TOKEN-MAX-LENGTH, stopping execution.\n" log-stream fputs
        1 call-sys-exit
      else                                                  // There is still space in the buffer.
        file 1 SEEK-CUR fseek drop
        buffer-end @inc64
        char-no    @inc64
      end end end end
    end
end end


proc lex-next-string
  // file-desc: file-desc ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream --
  file-desc ptr ptr ptr ptr file-desc --
  // Gets the next string before a double quote.
  // Keeps track of the line and char number as the bytes are read.
  // NOTE: If buffer-end exceeds buffer + TOKEN-MAX-LENGTH, exits program.
  // NOTE: If EOF is reached before a double quote is found, exits program.
  // TODO: Add escapes.
in let file line-no char-no buffer buffer-end log-stream in
  while true do
    buffer-end @64 1 file fgets is-zero if                  // Reached end of file.
      LOG.ERR log-stream fputs "Reached EOF before finding any '\"'.\n" log-stream fputs
      1 call-sys-exit
    else buffer-end @64 @8 CHAR-DQUOTE = if                 // Reached double quote.
      char-no    @inc64
      return
    else buffer-end @64 buffer - TOKEN-MAX-LENGTH >= if     // Reached the end of the buffer.
      LOG.ERR log-stream fputs "Found a token longer than TOKEN-MAX-LENGTH, stopping execution.\n" log-stream fputs
      1 call-sys-exit
    else buffer-end @64 @8 CHAR-NEWLINE = if                // Reached new line.
      buffer-end @inc64
      line-no    @inc64
      0 char-no !64
    else                                                   
      buffer-end @inc64
      char-no    @inc64
    end end end end
  end
end end


proc skip-line
  // file-desc: file-desc ptr: line-no ptr: char-no file-desc: log-stream --
  file-desc ptr ptr file-desc --
  // Moves the file pointer until it passes a newline, or EOF is reached.
  // Keeps track of the line and char number as the bytes are read.
in let file line-no char-no log-stream in
  line-no @inc64
  0 char-no !64
  
  memory char 1 in
    while true do
      char 1 file fgets is-zero if
        return
      else char @8 CHAR-NEWLINE = if
        return
      end end
    end
  end
end end


proc skip-block-comment
  // file-desc: file-desc ptr: line-no ptr: char-np file-desc: log-stream --
  file-desc ptr ptr file-desc --
  // Moves the file pointer until it passes a block comment end, or EOF is reached.
  // Keeps track of the line and char number as the bytes are read.
in let file line-no char-no log-stream in
  memory char 1 in
    while true do
      char 1 file fgets is-zero if                          // Reached EOF while expecting a block comment end.
        LOG.WARN log-stream fputs "Reached EOF while expecting a block comment end.\n" log-stream fputs
        return
        
      else char @8 CHAR-ASTERISK = if                       // Reached asterisk.
        char 1 file fgets is-zero if                        // Reached EOF while expecting a block comment end.
          LOG.WARN log-stream fputs "Reached EOF while expecting a block comment end.\n" log-stream fputs
          return
        end

        char @8 CHAR-SLASH = if                             // Reached block comment end.
          return
        end
        
      else char @8 CHAR-NEWLINE = if                        // Reached a newline.
        line-no @inc64
        0 char-no !64
        
      else                                                  // Reached any other character
        char-no @inc64
      end end end
    end
  end
end end


proc create-name-token
  // ptr: file-name file-desc: file-desc int: start-line int: start-char int: start-at ptr: line-no ptr: char-no ptr: buffer ptr: buffer-end file-desc: log-stream -- int: token-type ptr: address [int|ptr]: arg bool: is-available
  ptr file-desc int int int ptr ptr ptr ptr file-desc -- int ptr int bool
  // Checks if the name is a keyword or an intrinsic, and creates a new token.
  // TODO: Implement keywords.
  // TODO: Implement intrinsic keywords.
in let file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream in
  // Get full token.
  file line-no char-no buffer buffer-end log-stream lex-next-token

  buffer-end @64 buffer - let buffer-size in
    // Check if the token is a keyword.
    // I hate my life.
         buffer buffer-size KEYWORD-INCLUDE-STR    memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-INCLUDE    true
    else buffer buffer-size KEYWORD-MACRO-STR      memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-MACRO      true
    else buffer buffer-size KEYWORD-ENDMACRO-STR   memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-ENDMACRO   true
    else buffer buffer-size KEYWORD-PROC-STR       memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-PROC       true
    else buffer buffer-size KEYWORD-END-STR        memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-END        true
    else buffer buffer-size KEYWORD-RETURN-STR     memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-RETURN     true
    else buffer buffer-size KEYWORD-RETURNS-STR    memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-RETURNS    true
    else buffer buffer-size KEYWORD-MEMORY-STR     memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-MEMORY     true
    else buffer buffer-size KEYWORD-AND-STR        memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-AND        true
    else buffer buffer-size KEYWORD-IN-STR         memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-IN         true
    else buffer buffer-size KEYWORD-LET-STR        memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-LET        true
    else buffer buffer-size KEYWORD-IF-STR         memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-IF         true
    else buffer buffer-size KEYWORD-ELSE-STR       memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-ELSE       true
    else buffer buffer-size KEYWORD-WHILE-STR      memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-WHILE      true
    else buffer buffer-size KEYWORD-DO-STR         memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-DO         true
    else buffer buffer-size KEYWORD-BREAK-STR      memcmp8 if KEYWORD-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address KEYWORD-BREAK      true
    
    // I still hate my life.
    else buffer buffer-size INTRINSIC-ADD-STR      memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-ADD      true
    else buffer buffer-size INTRINSIC-SUB-STR      memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-SUB      true
    else buffer buffer-size INTRINSIC-MUL-STR      memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-MUL      true
    else buffer buffer-size INTRINSIC-MUL2-STR     memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-MUL2     true
    else buffer buffer-size INTRINSIC-FULLMUL-STR  memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-FULLMUL  true
    else buffer buffer-size INTRINSIC-DIV-STR      memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-DIV      true
    else buffer buffer-size INTRINSIC-MOD-STR      memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-MOD      true
    else buffer buffer-size INTRINSIC-DIVMOD-STR   memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-DIVMOD   true
    else buffer buffer-size INTRINSIC-UMUL-STR     memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-UMUL     true
    else buffer buffer-size INTRINSIC-UMUL2-STR    memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-UMUL2    true
    else buffer buffer-size INTRINSIC-UFULLMUL-STR memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-UFULLMUL true
    else buffer buffer-size INTRINSIC-UDIV-STR     memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-UDIV     true
    else buffer buffer-size INTRINSIC-UMOD-STR     memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-UMOD     true
    else buffer buffer-size INTRINSIC-UDIVMOD-STR  memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-UDIVMOD  true
    else buffer buffer-size INTRINSIC-BAND-STR     memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-BAND     true
    else buffer buffer-size INTRINSIC-BOR-STR      memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-BOR      true
    else buffer buffer-size INTRINSIC-BXOR-STR     memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-BXOR     true
    else buffer buffer-size INTRINSIC-BNOT-STR     memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-BNOT     true
    else buffer buffer-size INTRINSIC-EQUAL-STR    memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-EQUAL    true
    else buffer buffer-size INTRINSIC-LESS-STR     memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-LESS     true
    else buffer buffer-size INTRINSIC-TRUE-STR     memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-TRUE     true
    else buffer buffer-size INTRINSIC-FALSE-STR    memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-FALSE    true
    else buffer buffer-size INTRINSIC-LOAD8-STR    memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-LOAD8    true
    else buffer buffer-size INTRINSIC-STORE8-STR   memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-STORE8   true
    else buffer buffer-size INTRINSIC-LOAD64-STR   memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-LOAD64   true
    else buffer buffer-size INTRINSIC-STORE64-STR  memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-STORE64  true
    else buffer buffer-size INTRINSIC-SYSCALL0-STR memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-SYSCALL0 true
    else buffer buffer-size INTRINSIC-SYSCALL1-STR memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-SYSCALL1 true
    else buffer buffer-size INTRINSIC-SYSCALL2-STR memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-SYSCALL2 true
    else buffer buffer-size INTRINSIC-SYSCALL3-STR memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-SYSCALL3 true
    else buffer buffer-size INTRINSIC-SYSCALL4-STR memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-SYSCALL4 true
    else buffer buffer-size INTRINSIC-SYSCALL5-STR memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-SYSCALL5 true
    else buffer buffer-size INTRINSIC-SYSCALL6-STR memcmp8 if INTRINSIC-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address INTRINSIC-SYSCALL6 true
    
    else buffer buffer-size TYPE-INT-STR           memcmp8 if TYPE-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address TYPE-INT           true
    else buffer buffer-size TYPE-BOOL-STR          memcmp8 if TYPE-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address TYPE-BOOL          true
    else
      // Return token type, address and argument.
      NAME-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address buffer buffer-size to-dynamic true

    // This is nightmare fuel.
    end end end end end end end end end end end end end end end
    end end end end end end end end end end end end end end end
    end end end end end end end end end end end end end end end
    end end end end end end
  end
end end


proc get-next-token
  // ptr: file-name file-desc: file-desc ptr: line-no ptr: char-no file-desc: log-stream -- int: token-type ptr: address [int|ptr]: arg bool: is-available 
  ptr file-desc ptr ptr file-desc -- int ptr int bool
  // Generates a token and returns.
  // NOTE: If there is no token available, every other parameter is either NULLPTR or invalid.
in let file-name file line-no char-no log-stream in
  memory buffer     TOKEN-MAX-LENGTH and
         buffer-end sizeof(int)      in

    file line-no char-no strip-file if
      NULL-TYPE NULLPTR 0 false return
    end
    
    buffer buffer-end !64

    line-no @64 char-no @64 file ftell let start-line start-char start-at in
      buffer 1 file fgets drop
      buffer-end @inc64
    
      buffer @8 '0' '9' is-range if
        // -------- Integer type --------
        // TODO: Add bases.

        // Get full token.
        file line-no char-no buffer buffer-end log-stream lex-next-token

        // Return token type, address and argument.
        INTEGER-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address buffer buffer-end @64 buffer - str.dec-to-int true
        
      else buffer @8 CHAR-SQUOTE = if
        // -------- Characters --------
        
        buffer inc 1 file fgets is-zero if                  // Reached EOF while expecting a character.
          LOG.ERR log-stream fputs "Reached EOF before finding a character after single quote.\n" log-stream fputs LOG.RESET log-stream fputs
          1 call-sys-exit
        end

        // Get the character
        buffer inc @8 let character in
          character CHAR-BACKSLASH = if
            // -------- Escapes --------
            // TODO: Add escapes.
            LOG.TODO log-stream fputs "Escapes are not implemented yet.\n" log-stream fputs
            1 call-sys-exit
          end
          
          buffer 2 + 1 file fgets is-zero if              // Reached EOF while expecting a single quote.
            LOG.ERR log-stream fputs "Reached EOF before finding a single quote after single quote and character.\n" log-stream fputs
            1 call-sys-exit
          end

          buffer 2 + @8 CHAR-SQUOTE != if                 // Was expecting a single quote, but found another character.
            LOG.ERR log-stream fputs "Expected a single quote, found '" log-stream fputs buffer 2 + 1 log-stream fputs "'.\n" log-stream fputs
            1 call-sys-exit
          end

          // Return token type, address and argument.
          INTEGER-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address character true
        end
        
      else buffer @8 CHAR-DQUOTE = if
        // -------- String type --------

        // Move the buffer-end left once, so the quote is removed.
        buffer-end @dec64

        // Get full string.
        file line-no char-no buffer buffer-end log-stream lex-next-string

        // Return token type, address and argument.
        STRING-TYPE file-name start-line start-char start-at line-no @64 char-no @64 file ftell generate-address buffer buffer-end @64 buffer - to-dynamic true
        
      else buffer @8 CHAR-SLASH = if
        // -------- Slash (Name and comments) --------
        
        buffer inc 1 file fgets is-zero if
          // -------- Names and keyword types --------
          file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream create-name-token
          
        else
          buffer inc @8 CHAR-SLASH = if
            // -------- Single ine comment --------

            // Skip this line.
            file line-no char-no log-stream skip-line

            // Get next token and return it.
            file-name file line-no char-no log-stream get-next-token

          else buffer inc @8 CHAR-ASTERISK = if
            // -------- Block comment --------

            // Skip the block comment.
            file line-no char-no log-stream skip-block-comment

            // Get next token and return it.
            file-name file line-no char-no log-stream get-next-token
            
          else
            // -------- Names and keyword types --------
            file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream create-name-token
            
          end end
        end
      else
        // -------- Name and keyword types --------
        file-name file start-line start-char start-at line-no char-no buffer buffer-end log-stream create-name-token
      end end end end
    end
  end
end end


proc compile-file
  // ptr: source-name file-desc: output-file ptr: libraries-queue-array ptr: libraries-queue-length file-desc: log-stream
  ptr file-desc ptr ptr file-desc -- 
in let source-name output-file libraries-queue-array libraries-queue-length log-stream in
  source-name add-null let c-source-name in
    c-source-name fopen-read c-source-name mfree
  end

  let source in
    // Check if the source is opened.
    source isn-pos if
      LOG.ERR log-stream fputs "Could not open source file '" log-stream fputs source-name source-name mlength dec log-stream fputs "'\n" log-stream fputs LOG.RESET log-stream fputs
      1 call-sys-exit
      return
    end
    
    memory line-no sizeof(int) and
           char-no sizeof(int) in

      // Reset line-no and char-no variables.
      1 line-no !64
      0 char-no !64

      // Get next token and check if there is one available.
      while
        source-name source line-no char-no log-stream get-next-token do
        let token-type token-address token-arg in
          token-type KEYWORD-TYPE = if
            // -------- Global keywords --------
            
                 token-arg KEYWORD-INCLUDE = if
              // -------- 'include' keyword --------
              // TODO: Create a function to include.
              // TODO: Allow including packages.
              // TODO: Add library search locations.
              // TODO: Add pragma once.

              // Get the next token, which should be the include path.
              source-name source line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting an include path.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let path-token-type path-token-address path-token-arg in
                path-token-type NAME-TYPE != if
                  LOG.ERR log-stream fputs "Expected a 'name' for path after 'include', got '" log-stream fputs path-token-type log-stream fput-type "'.\n" log-stream fputs
                  path-token-address log-stream fput-here
                  1 call-sys-exit
                end
                
                path-token-arg output-file libraries-queue-array libraries-queue-length log-stream compile-file
              end
              
            else token-arg KEYWORD-MEMORY  = if
              // -------- 'memory' keyword --------

              // Get the next token, which sould be the include path.
              source-name source line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a global variable name.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let variable-name-token-type variable-name-token-address variable-name-token-arg in
                variable-name-token-type NAME-TYPE != if
                  LOG.ERR log-stream fputs "Expected a 'name' for global variable name after 'memory', got '" log-stream fputs variable-name-token-type log-stream fput-type "'.\n" log-stream fputs
                  variable-name-token-address log-stream fput-here
                  1 call-sys-exit
                end

                // TODO: Implement the size calculation part.
              end
              
            else token-arg KEYWORD-MACRO   = if
              // -------- 'macro' keyword --------

              // Get the next token, which should be the name of the macro.
              source-name source line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a macro name.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let macro-name-token-type macro-name-token-address macro-name-token-arg in
                macro-name-token-type NAME-TYPE != if
                  LOG.ERR log-stream fputs "Expected a 'name' for macro name after 'macro', got '" log-stream fputs macro-name-token-arg log-stream fput-type "'.\n" log-stream fputs
                  macro-name-token-address log-stream fput-here
                  1 call-sys-exit
                end

                // macro-tokens-array and macro-tokens-length are used to create a QUEUE for macro tokens.
                memory macro-tokens-array  MACRO-MAX-TOKENS sizeof(int) * and
                       macro-tokens-length sizeof(int)                    in
                       
                  while true do
                    // Get next tokens, until an 'endmacro' is found.
                    source-name source line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting an 'endmacro' in macro '" log-stream fputs macro-name-token-arg macro-name-token-arg mlength log-stream fputs "'.\n" log-stream fputs
                      token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    let macro-new-token-type macro-new-token-address macro-new-token-arg in
                      macro-tokens-length MACRO-MAX-TOKENS - 3 < if
                        LOG.ERR log-stream fputs "Macro '" log-stream fputs macro-name-token-arg macro-name-token-arg mlength log-stream fputs "' is longer than MACRO-MAX-TOKENS, stopping execution.\n" log-stream fputs
                        token-address log-stream fput-here
                        1 call-sys-exit
                      end

                      macro-new-token-type KEYWORD-TYPE = if
                        // TODO: Save the macro
                        break
                      end
                      
                      macro-new-token-type    macro-tokens-array macro-tokens-length queue64.append
                      macro-new-token-address macro-tokens-array macro-tokens-length queue64.append
                      macro-new-token-arg     macro-tokens-array macro-tokens-length queue64.append
                    end
                  end
                end
              end
              
            else token-arg KEYWORD-PROC    = if
              // -------- 'proc' keyword --------

              // Get the next token, which should be the name of the procedure.
              source-name source line-no char-no log-stream get-next-token ! if
                LOG.ERR log-stream fputs "Reached EOF while expecting a procedure name.\n" log-stream fputs
                token-address log-stream fput-here
                1 call-sys-exit
              end

              let proc-name-token-type proc-name-token-address proc-name-token-arg in
                proc-name-token-type NAME-TYPE != if
                  "Expected a 'name' for procedure name after 'proc', got " log-stream fputs proc-name-token-type log-stream fput-type "'.\n" log-stream fputs
                  proc-name-token-type log-stream fput-here
                  1 call-sys-exit
                end

                // macro-tokens-array and macro-tokens-length are used to create a QUEUE for macro tokens.
                memory inputs-array   sizeof(int) PROC-MAX-IO * and
                       inputs-length  sizeof(int)               and
                       outputs-array  sizeof(int) PROC-MAX-IO * and
                       outputs-length sizeof(int)               in

                  while true do
                    source-name source line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting procedure input type.\n" log-stream fputs
                      token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    let input-token-type input-token-address input-token-arg in
                      input-token-type KEYWORD-TYPE = if
                        input-token-arg KEYWORD-RETURNS != if
                          LOG.ERR log-stream fputs "Unexpected keyword while expecting input type, got '" log-stream fputs input-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                          token-address log-stream fput-here
                          1 call-sys-exit
                        end

                        break
                      else input-token-type TYPE-TYPE = if
                        // TODO: Check if the input queue was filled.
                        input-token-arg inputs-array inputs-length queue64.append
                      else
                        "Expected a 'type' for input type, got '" log-stream fputs input-token-type log-stream fput-type "'.\n" log-stream fputs
                        input-token-address log-stream fput-here
                        1 call-sys-exit
                      end end
                    end
                  end

                  while true do
                    source-name source line-no char-no log-stream get-next-token ! if
                      LOG.ERR log-stream fputs "Reached EOF while expecting procedure output type.\n" log-stream fputs
                      token-address log-stream fput-here
                      1 call-sys-exit
                    end

                    let output-token-type output-token-address output-token-arg in
                      output-token-type KEYWORD-TYPE = if
                        output-token-arg KEYWORD-IN != if
                          LOG.ERR log-stream fputs "Unexpected keyword while expecting output type, got '" log-stream fputs output-token-arg log-stream fput-keyword "'.\n" log-stream fputs
                          token-address log-stream fput-here
                          1 call-sys-exit
                        end

                        break
                      else output-token-type TYPE-TYPE = if
                        // TODO: Check if the output queue was filled.
                        output-token-arg outputs-array outputs-length queue64.append
                      else
                        "Expected a 'type' for output type, got '" log-stream fputs output-token-type log-stream fput-type "'.\n" log-stream fputs
                        output-token-address log-stream fput-here
                        1 call-sys-exit
                      end end
                    end
                  end
                end
              end
              
            else
              LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
              token-address log-stream fput-here
              1 call-sys-exit
              
            end end end end
          else
            LOG.ERR log-stream fputs "Expected a keyword type, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
            token-address log-stream fput-here
            1 call-sys-exit
          end
        end
      end drop drop drop
    end
    
    source fclose
  end
end end


proc main
  int int -- int
in let argc argv in
  // Initialize malloc.
  malloc.init

  // Make file name dynamic.
  FILE-NAME inc to-dynamic let file-name in
    // Check if the file is opened successfully.
    file-name is-null if
      "There is not enough space for file-name\n" puts
      1 call-sys-exit
    end

    memory libraries-queue-array  sizeof(int) 0x100 * and
           libraries-queue-length sizeof(int)         in

      0 libraries-queue-length !64
           
      file-name STDOUT libraries-queue-array libraries-queue-length STDERR compile-file
    end
  end
end 0 end


/*

Name definitions:

  Public:
    Global variables
    Macros
    Procedures

  Private:
    Local variables
    Let variables
    
*/
