/*

    ============================
    ==== Euler project #??? ====
    ============================

This example solves an euler project question that I don't know the number of.

Let's say there is a function, f(x).

If x is odd, f(x) returns 3x + 1.
If x is even, f(x) returns x / 2.

We keep doing that until we reach 1.

Our goal is to find the number with the most amount of steps required to reach 1.

START and END macros define the search ends. Program will print the best it has found until some point.

When START = 1 and END = 
*/


include libs/io.corth


macro START 1 endmacro
macro END 1000000 endmacro

memory best sizeof(int) end

memory n sizeof(int) end
memory step sizeof(int) end

macro set-best best swp store8 endmacro
macro set-n       n swp store8 endmacro
macro set-step step swp store8 endmacro

macro get-best best load8 endmacro
macro get-n       n load8 endmacro
macro get-step step load8 endmacro

macro update
  get-n 2 % 0 = if 
    get-n 2 / set-n
  else
    get-n 3 * inc set-n
  end
endmacro

proc main
  -- int
in
  START while dup END <= do
    dup set-n
    0 set-step

    while get-n 1 != do
      update
      get-step inc set-step
    end

    get-step get-best > if
      "Found better, " puts
      dup putu
      ". This number requires " puts
      get-step putu
      " steps\n" puts
      get-step set-best
    end
  inc end drop

  0
end
