include "dynamic/utils.corth"
include "linux_x86/io/output.corth"
include "core/stack.corth"

macro sizeof(position) 16 endmacro
macro sizeof(address)  48 endmacro

macro ADDR.FILE  0  endmacro
macro ADDR.PREV  8  endmacro
macro ADDR.START 16 endmacro
macro ADDR.END   32 endmacro

macro POS.LINE   0  endmacro
macro POS.CHAR   8  endmacro

namespace LOG
macro INFO  "\x1b[1;97m[INFO]\x1b[0;97m "    endmacro
macro WARN  "\x1b[1;33m[WARNING]\x1b[0;97m " endmacro
macro SOFT  "\x1b[1;31m[SOFT]\x1b[0;97m "    endmacro
macro ERR   "\x1b[1;31m[ERROR]\x1b[0;97m "   endmacro
macro BUG   "\x1b[1;31m[BUG]\x1b[0;97m "     endmacro
macro CMD   "\x1b[1;32m[CMD]\x1b[0;97m "     endmacro
macro TODO  "\x1b[1;35m[TODO]\x1b[0;97m "    endmacro
macro HERE  "\x1b[1;32m[HERE]\x1b[0;97m "    endmacro
endnamespace


// This buffer can be used to easily write many spaces at once.
// NOTE: Trying to write more than .-BUFFER-SIZE characters may cause problems.
macro  SPACE-BUFFER-SIZE 256               endmacro
memory space-buffer      SPACE-BUFFER-SIZE end

macro  TILDE-BUFFER-SIZE 256               endmacro
memory tilde-buffer      TILDE-BUFFER-SIZE end


macro sizeof(position_) 24 endmacro
macro position:file   0 + endmacro
macro position:pos    8 + endmacro
macro position:prev  16 + endmacro


macro sizeof(log)  24 endmacro
macro log:type    0 + endmacro
macro log:arg1    8 + endmacro
macro log:arg2   16 + endmacro


proc debug-init -> in
  // Set up the space-buffer.
  space-buffer SPACE-BUFFER-SIZE ' ' memset8

  // Set up the tilde-buffer.
  tilde-buffer TILDE-BUFFER-SIZE '~' memset8
end


proc generate-address
  // ptr: file-name ptr: previous int: start-line int: start-char int: end-line int: end-char -> ptr: address
  ptr ptr int int int int -> ptr
  // Returns a dynamicly-placed object to store the address of token.
in
  sizeof(address) malloc let address in
    address isn-null if
      // Store the arguments.
      address ADDR.END   + POS.CHAR + !64
      address ADDR.END   + POS.LINE + !64
      address ADDR.START + POS.CHAR + !64
      address ADDR.START + POS.LINE + !64
      address ADDR.PREV  + !64
      address ADDR.FILE  + !64
    else
      // Remove the unused arguments.
      drop drop drop drop drop drop
    end

    // Return the address.
    address
  end
end


proc fput-position
  // int: line-no int: char-no file-desc: file-desc
  int int file-desc ->
  // Prints a position.
in let line-no char-no file in
  line-no file fputu ":" file fputs char-no file fputu
end end


proc seek-line
  // int: line file-desc: file-desc
  int file-desc ->
  // Shifts the file pointer by a specified amount of lines.
in let file in
  memory char 1 in
    while dup isn-zero do
      // If EOF is reached, returns immediately.
      char 1 file fgets is-zero if drop return end

      // If a newline is reached, decrease the counter.
      char @8 '\n' = if dec end
    end drop
  end
end end


proc fput-line
  // file-desc: source file-desc: file-desc -> int: line-length
  file-desc file-desc -> int
  // Keeps printing until a newline is found.
  // Returns the length of line read.
in let source file in
  memory char 1 in
    0 while true do
      // If EOF is reached, return immediately.
      char 1 source fgets is-zero if return end

      // If a newline character is reached, return immediately.
      char @8 '\n' = if return end

      // Print the byte to the file stream.
      char 1 file fputs
    inc end
  end
end end


macro fputu-full let _value_ _file_ in
  // int: int file-desc: file-desc

  memory _buffer_ 20 in
    _buffer_ _value_ intconvud let _buffer_start_ in
      _buffer_ _buffer_start_ _buffer_ - ' ' memset8
    end

    _buffer_ 20 _file_ fputs
  end
end endmacro


proc fput-address
  // ptr: address file-desc: log-stream
  ptr file-desc ->
  // Prints the formatted address of a token.
in let address log-stream in
  address ADDR.FILE + @64 let file-name in
    "file '" log-stream fputs file-name file-name mlength log-stream fputs
    "' [" log-stream fputs
    address ADDR.START + POS.LINE + @64 address ADDR.START + POS.CHAR + @64 log-stream fput-position
    "]-[" log-stream fputs
    address ADDR.END + POS.LINE + @64 address ADDR.END + POS.CHAR + @64 log-stream fput-position
    "]" log-stream fputs
  end
end end


proc fput-lines
  // ptr: address file-desc: log-stream
  ptr file-desc ->
  // Prints the formatted lines of a token.
in let address log-stream in
  address ADDR.FILE + @64 address ADDR.START + address ADDR.END + let file-name start-pos end-pos in
    // Add a null character and open the file.
    file-name null-term8 fopen-r let file in
      // Check if file could be opened.
      file isn-pos if
        "<file-unavailable>\n" log-stream fputs
        return
      end

      start-pos POS.LINE + @64 start-pos POS.CHAR + @64 end-pos POS.LINE + @64 end-pos POS.CHAR + @64 let start-line start-char end-line end-char in

        // Move the file pointer to the start.
        file 0 SEEK-WHENCE:SET lseek drop start-line dec file seek-line

        start-line end-line = if
          start-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
            "                      " log-stream fputs space-buffer start-char log-stream fputs tilde-buffer end-char start-char - log-stream fputs log-stream fputnl
          end
        else
          start-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
            "                      " log-stream fputs space-buffer start-char log-stream fputs tilde-buffer length start-char - log-stream fputs log-stream fputnl
          end

          start-line inc while dup end-line < do
            dup log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
              "                      " log-stream fputs tilde-buffer length log-stream fputs log-stream fputnl
            end
          inc end drop

          end-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
            "                      " log-stream fputs tilde-buffer end-char log-stream fputs log-stream fputnl
          end
        end

        // Close the file.
        file fclose drop
      end
    end
  end
end end


proc fput-lines-position
  // int: line-no int: char-no ptr: file-name file-desc: log-stream
  int int ptr file-desc ->
  // Prints the formatted linees of a token.
in let line-no char-no file-name log-stream in
  // Add a null character for fopen.
  file-name null-term8 fopen-r let file in
    // Check if the file could be opened.
    file isn-pos if
      "<file-unavailable>\n" log-stream fputs
      return
    end

    // Move the file pointer to the start,
    file 0 SEEK-WHENCE:SET lseek drop line-no dec file seek-line

    line-no log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
      "                      " log-stream fputs space-buffer char-no log-stream fputs tilde-buffer 1 log-stream fputs log-stream fputnl
    end

    // Close the file.
    file fclose drop
  end
end end


proc fput-here
  // ptr: address file-desc: log-stream ->
  ptr file-desc ->
in let address log-stream in
  LOG:HERE log-stream fputs address log-stream fput-address ":\n" log-stream fputs
  address log-stream fput-lines

  address ADDR.PREV + @64 let prev in
    prev isn-null if
      prev log-stream fput-here
    end
  end
end end


macro fput-here-position let _line_no_ _char_no_ _file_name_ _log_stream_ in
  // ptr: position file-desc: log-stream ->
  LOG:HERE _log_stream_ fputs "At " _log_stream_ fputs _line_no_ _char_no_ _log_stream_ fput-position " in '" _log_stream_ fputs _file_name_ _file_name_ mlength _log_stream_ fputs "':\n" _log_stream_ fputs
  _line_no_ _char_no_ _file_name_ _log_stream_ fput-lines-position
end endmacro


macro fput-inside-procedure let _procedure_name_ _procedure_address_ _log_stream_ in
  // ptr: _address_ ptr: _procedure_name_ ptr: _procedure_address_ file-desc: _log_stream_ ->
  LOG:INFO _log_stream_ fputs "Inside procedure '" _log_stream_ fputs _procedure_name_ _procedure_name_ mlength _log_stream_ fputs "'.\n" _log_stream_ fputs
  LOG:HERE _log_stream_ fputs _procedure_address_ _log_stream_ fput-address ":\n" _log_stream_ fputs

  _procedure_address_ _log_stream_ fput-lines
end endmacro


proc generate-position
  // ptr: file int: pos -> ptr: pos
  ptr int -> ptr
in sizeof(position_) malloc let object in
  object isn-null if
    object position:pos  !64
    object position:file !64

    NULLPTR object position:prev !64
  else drop drop end
object end end


// Exits with error code.
proc unescapable -> in 1 exit drop end


proc generate-log0
  // int: type -> ptr: log-item
  int -> ptr
in sizeof(log) malloc let object in
  object isn-null if
    object log:type !64
  else drop end
object end end


proc generate-log1
  // int: arg1 int: type -> ptr: log-item
  int int -> ptr
in sizeof(log) malloc let object in
  object isn-null if
    object log:type !64
    object log:arg1 !64
  else drop drop end
object end end


proc generate-log2
  // int: arg1 int: arg2 int: type -> ptr: log-item
  int int int -> ptr
in sizeof(log) malloc let object in
  object isn-null if
    object log:type !64
    object log:arg2 !64
    object log:arg1 !64
  else drop drop drop end
object end end


namespace LOG-TYPE
// -------- Info messages (prefix: 0xxxx) --------

// -------- Warnings (prefix: 1xxxx) --------

// -------- Error messages (prefix: 2xxxx) --------

//// General errors (prefix: 20xxx)

//// Lexer errors (prefix: 21xxx)
macro REACHED-EOF       0x21000 endmacro  //
macro REACHED-EOL       0x21001 endmacro  //
macro TOKEN-TOO-LONG    0x21002 endmacro  //
macro INVALID-ESCAPE    0x21003 endmacro  // log-item: reason
macro NOT-HEX-DIGIT     0x21004 endmacro  //
macro NOT-ESCAPE-CHAR   0x21005 endmacro  //
macro INV-STR-LIT       0x21006 endmacro  // log-item: reason
macro INV-INT-LIT       0x21007 endmacro  //
macro INV-CHAR-LIT      0x21008 endmacro  //

//// Parsing errors (prefix: 22xxx)
macro NO-TOKEN          0x22000 endmacro  // log-item: reason
macro UNXPCT-TYPE       0x22001 endmacro
macro UNXPCT-KEYWORD    0x22002 endmacro

//// Compilation errors (prefix: 23xxx)
macro STACK-NOT-MATCH   0x23000 endmacro  // log-item: reason
macro NOT-ENOUGH-ITEMS  0x23001 endmacro  //
macro INV-ITEM-TYPE     0x23002 endmacro  //
macro INV-ITEM-MODE     0x23003 endmacro  //
macro ERROR-INTRINSIC   0X23004 endmacro  // log-item: reason address: token-address
macro ERROR-KEYWORD     0X23005 endmacro  // log-item: reason address: token-address
macro ERROR-PROC        0x23006 endmacro  // log-item: reason
macro MEM-SIZE-MISMATCH 0x23007 endmacro  //
macro UNREACHABLE       0x23008 endmacro  //
macro REDEF-LOCAL-NAME  0x23009 endmacro  //
macro UNDEF-NAME        0x2300a endmacro  //

// -------- Assertions (prefix: 3xxxx) --------
macro MALLOC-FAILED     0x30000 endmacro  //
macro EXT-LEN-INVALID   0X30001 endmacro  //
macro UNKNOWN-MODE      0x30002 endmacro  //
macro UNKNOWN-INTRINSIC 0x30003 endmacro  //
macro UNKNOWN-KEYWORD   0x30004 endmacro  //
macro CANNOT-FIND-VAR   0x30005 endmacro  //

endnamespace


proc fput-log-item
  // ptr: log-item file-desc: log-stream ->
  ptr file-desc ->
in let log-item log-stream in
  log-item log:type @64
  log-item log:arg1 @64
  log-item log:arg2 @64
  let type arg1 arg2 in
    "(#" log-stream fputs type log-stream fputx ") " log-stream fputs

    // Information messages

    // Warnings

    // General errors

    // Lexer errors
    type LOG-TYPE:REACHED-EOF = if
      "reached EOF\n" log-stream fputs

    else type LOG-TYPE:REACHED-EOL = if
      "reached EOL\n" log-stream fputs

    else type LOG-TYPE:TOKEN-TOO-LONG = if
      "token is too long\n" log-stream fputs

    else type LOG-TYPE:INVALID-ESCAPE = if
      "escape code is invalid because:\n" log-stream fputs
      arg1 log-stream fput-log-item

    else type LOG-TYPE:NOT-HEX-DIGIT = if
      "not an hexadecimal digit\n" log-stream fputs

    else type LOG-TYPE:NOT-ESCAPE-CHAR = if
      "invalid escape character\n" log-stream fputs

    else type LOG-TYPE:INV-STR-LIT = if
      "could not parse string literal because:\n" log-stream fputs
      arg1 log-stream fput-log-item

    else type LOG-TYPE:INV-INT-LIT = if
      "could not parse string literal\n" log-stream fputs

    else type LOG-TYPE:INV-CHAR-LIT = if
      "could not parse string literal\n" log-stream fputs

    // Parser errors
    else type LOG-TYPE:NO-TOKEN = if
      "token expected but none available because:\n" log-stream fputs
      arg1 log-stream fput-log-item

    else type LOG-TYPE:UNXPCT-TYPE = if
      "unexpected token type\n" log-stream fputs

    else type LOG-TYPE:UNXPCT-KEYWORD = if
      "unexpected keyword\n" log-stream fputs

    // Compilation errors
    else type LOG-TYPE:STACK-NOT-MATCH = if
      "stack does not match the expected stack\n" log-stream fputs

    else type LOG-TYPE:NOT-ENOUGH-ITEMS = if
      "stack does not have enough items\n" log-stream fputs

    else type LOG-TYPE:INV-ITEM-TYPE = if
      "invalid item type\n" log-stream fputs

    else type LOG-TYPE:INV-ITEM-MODE = if
      "invalid item mode\n" log-stream fputs

    else type LOG-TYPE:ERROR-INTRINSIC = if
      "could not compile intrinsic\n" log-stream fputs
      arg2 log-stream fput-here
      "because\n" log-stream fputs
      arg1 log-stream fput-log-item

    else type LOG-TYPE:ERROR-PROC = if
      "could not compile procedure because:\n" log-stream fputs
      arg1 log-stream fput-log-item

    else type LOG-TYPE:MEM-SIZE-MISMATCH = if
      "load/store size does not match\n" log-stream fputs

    else type LOG-TYPE:UNREACHABLE = if
      "end of procedure must be reachable\n" log-stream fputs

    else type LOG-TYPE:REDEF-LOCAL-NAME = if
      "name redefined\n" log-stream fputs

    else type LOG-TYPE:UNDEF-NAME = if
      "name not defined locally or globally\n" log-stream fputs

    // Assertions
    else type LOG-TYPE:MALLOC-FAILED = if
      "malloc failed\n" log-stream fputs

    else type LOG-TYPE:EXT-LEN-INVALID = if
      "extended array length is not a multiple of 3\n" log-stream fputs

    else type LOG-TYPE:UNKNOWN-INTRINSIC = if
      "unknown intrinsic id\n" log-stream fputs

    else type LOG-TYPE:UNKNOWN-KEYWORD = if
      "unknown keyword id\n" log-stream fputs

    else type LOG-TYPE:UNKNOWN-MODE = if
      "unknown stack item mode\n" log-stream fputs

    else type LOG-TYPE:CANNOT-FIND-VAR = if
      "can not find variable in the name replace list\n" log-stream fputs

    else
      "unknown\n" log-stream fputs
    end end end end end end end end end end end end end end end end end end end end end end end end end end end end end
  end
end
