include "dynamic/utils.corth"
include "linux_x86/io/output.corth"
include "core/stack.corth"

macro sizeof(position) 16 endmacro
macro sizeof(address)  48 endmacro

macro ADDR.FILE  0  endmacro
macro ADDR.PREV  8  endmacro
macro ADDR.START 16 endmacro
macro ADDR.END   32 endmacro

macro POS.LINE   0  endmacro
macro POS.CHAR   8  endmacro

namespace LOG
macro INFO  "\x1b[1;97m[INFO]\x1b[0;97m "    endmacro
macro WARN  "\x1b[1;33m[WARNING]\x1b[0;97m " endmacro
macro SOFT  "\x1b[1;31m[SOFT]\x1b[0;97m "    endmacro
macro ERR   "\x1b[1;31m[ERROR]\x1b[0;97m "   endmacro
macro BUG   "\x1b[1;31m[BUG]\x1b[0;97m "     endmacro
macro CMD   "\x1b[1;32m[CMD]\x1b[0;97m "     endmacro
macro TODO  "\x1b[1;35m[TODO]\x1b[0;97m "    endmacro
macro HERE  "\x1b[1;32m[HERE]\x1b[0;97m "    endmacro
endnamespace


// This buffer can be used to easily write many spaces at once.
// NOTE: Trying to write more than .-BUFFER-SIZE characters may cause problems.
macro  SPACE-BUFFER-SIZE 256               endmacro
memory space-buffer      SPACE-BUFFER-SIZE end

macro  TILDE-BUFFER-SIZE 256               endmacro
memory tilde-buffer      TILDE-BUFFER-SIZE end


macro sizeof(position_) 24 endmacro
macro position:file   0 + endmacro
macro position:pos    8 + endmacro
macro position:prev  16 + endmacro


macro sizeof(log)  24 endmacro
macro log:type    0 + endmacro
macro log:arg1    8 + endmacro
macro log:arg2   16 + endmacro


proc debug-init -> in
  // Set up the space-buffer.
  space-buffer SPACE-BUFFER-SIZE ' ' memset8

  // Set up the tilde-buffer.
  tilde-buffer TILDE-BUFFER-SIZE '~' memset8
end


proc generate-address
  // ptr: file-name ptr: previous int: start-line int: start-char int: end-line int: end-char -> ptr: address
  ptr ptr int int int int -> ptr
  // Returns a dynamicly-placed object to store the address of token.
in
  sizeof(address) malloc let address in
    address isn-null if
      // Store the arguments.
      address ADDR.END   + POS.CHAR + !64
      address ADDR.END   + POS.LINE + !64
      address ADDR.START + POS.CHAR + !64
      address ADDR.START + POS.LINE + !64
      address ADDR.PREV  + !64
      address ADDR.FILE  + !64
    else
      // Remove the unused arguments.
      drop drop drop drop drop drop
    end

    // Return the address.
    address
  end
end


proc fput-position
  // int: line-no int: char-no file-desc: file-desc
  int int file-desc ->
  // Prints a position.
in let line-no char-no file in
  line-no file fputu ":" file fputs char-no file fputu
end end


proc seek-line
  // int: line file-desc: file-desc
  int file-desc ->
  // Shifts the file pointer by a specified amount of lines.
in let file in
  memory char 1 in
    while dup isn-zero do
      // If EOF is reached, returns immediately.
      char 1 file fgets is-zero if drop return end

      // If a newline is reached, decrease the counter.
      char @8 '\n' = if dec end
    end drop
  end
end end


proc fput-line
  // file-desc: source file-desc: file-desc -> int: line-length
  file-desc file-desc -> int
  // Keeps printing until a newline is found.
  // Returns the length of line read.
in let source file in
  memory char 1 in
    0 while true do
      // If EOF is reached, return immediately.
      char 1 source fgets is-zero if return end

      // If a newline character is reached, return immediately.
      char @8 '\n' = if return end

      // Print the byte to the file stream.
      char 1 file fputs
    inc end
  end
end end


macro fputu-full let _value_ _file_ in
  // int: int file-desc: file-desc

  memory _buffer_ 20 in
    _buffer_ _value_ intconvud let _buffer_start_ in
      _buffer_ _buffer_start_ _buffer_ - ' ' memset8
    end

    _buffer_ 20 _file_ fputs
  end
end endmacro


proc fput-address
  // ptr: address file-desc: log-stream
  ptr file-desc ->
  // Prints the formatted address of a token.
in let address log-stream in
  address ADDR.FILE + @64 let file-name in
    "file '" log-stream fputs file-name file-name mlength log-stream fputs
    "' [" log-stream fputs
    address ADDR.START + POS.LINE + @64 address ADDR.START + POS.CHAR + @64 log-stream fput-position
    "]-[" log-stream fputs
    address ADDR.END + POS.LINE + @64 address ADDR.END + POS.CHAR + @64 log-stream fput-position
    "]" log-stream fputs
  end
end end


proc fput-lines
  // ptr: address file-desc: log-stream
  ptr file-desc ->
  // Prints the formatted lines of a token.
in let address log-stream in
  address ADDR.FILE + @64 address ADDR.START + address ADDR.END + let file-name start-pos end-pos in
    // Add a null character and open the file.
    file-name null-term8 fopen-r let file in
      // Check if file could be opened.
      file isn-pos if
        "<file-unavailable>\n" log-stream fputs
        return
      end

      start-pos POS.LINE + @64 start-pos POS.CHAR + @64 end-pos POS.LINE + @64 end-pos POS.CHAR + @64 let start-line start-char end-line end-char in

        // Move the file pointer to the start.
        file 0 SEEK-WHENCE:SET lseek drop start-line dec file seek-line

        start-line end-line = if
          start-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
            "                      " log-stream fputs space-buffer start-char log-stream fputs tilde-buffer end-char start-char - log-stream fputs log-stream fputnl
          end
        else
          start-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
            "                      " log-stream fputs space-buffer start-char log-stream fputs tilde-buffer length start-char - log-stream fputs log-stream fputnl
          end

          start-line inc while dup end-line < do
            dup log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
              "                      " log-stream fputs tilde-buffer length log-stream fputs log-stream fputnl
            end
          inc end drop

          end-line log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
            "                      " log-stream fputs tilde-buffer end-char log-stream fputs log-stream fputnl
          end
        end

        // Close the file.
        file fclose drop
      end
    end
  end
end end


proc fput-lines-position
  // int: line-no int: char-no ptr: file-name file-desc: log-stream
  int int ptr file-desc ->
  // Prints the formatted linees of a token.
in let line-no char-no file-name log-stream in
  // Add a null character for fopen.
  file-name null-term8 fopen-r let file in
    // Check if the file could be opened.
    file isn-pos if
      "<file-unavailable>\n" log-stream fputs
      return
    end

    // Move the file pointer to the start,
    file 0 SEEK-WHENCE:SET lseek drop line-no dec file seek-line

    line-no log-stream fputu-full ": " log-stream fputs file log-stream fput-line log-stream fputnl let length in
      "                      " log-stream fputs space-buffer char-no log-stream fputs tilde-buffer 1 log-stream fputs log-stream fputnl
    end

    // Close the file.
    file fclose drop
  end
end end


proc fput-here
  // ptr: address file-desc: log-stream ->
  ptr file-desc ->
in let address log-stream in
  LOG:HERE log-stream fputs address log-stream fput-address ":\n" log-stream fputs
  address log-stream fput-lines

  address ADDR.PREV + @64 let prev in
    prev isn-null if
      prev log-stream fput-here
    end
  end
end end


macro fput-here-position let _line_no_ _char_no_ _file_name_ _log_stream_ in
  // ptr: position file-desc: log-stream ->
  LOG:HERE _log_stream_ fputs "At " _log_stream_ fputs _line_no_ _char_no_ _log_stream_ fput-position " in '" _log_stream_ fputs _file_name_ _file_name_ mlength _log_stream_ fputs "':\n" _log_stream_ fputs
  _line_no_ _char_no_ _file_name_ _log_stream_ fput-lines-position
end endmacro


macro fput-inside-procedure let _procedure_name_ _procedure_address_ _log_stream_ in
  // ptr: _address_ ptr: _procedure_name_ ptr: _procedure_address_ file-desc: _log_stream_ ->
  LOG:INFO _log_stream_ fputs "Inside procedure '" _log_stream_ fputs _procedure_name_ _procedure_name_ mlength _log_stream_ fputs "'.\n" _log_stream_ fputs
  LOG:HERE _log_stream_ fputs _procedure_address_ _log_stream_ fput-address ":\n" _log_stream_ fputs

  _procedure_address_ _log_stream_ fput-lines
end endmacro


proc report-bug
  // file-desc: file-desc ->
  file-desc ->
in let log-stream in
  LOG:ERR log-stream fputs "This should have been impossible to reach.\n" log-stream fputs
  LOG:INFO log-stream fputs "This is probably caused by a bug in the compiler.\n" log-stream fputs
end end


proc generate-position
  // ptr: file int: pos -> ptr: pos
  ptr int -> ptr
in sizeof(position_) malloc let object in
  object isn-null if
    object position:pos  !64
    object position:file !64

    NULLPTR object position:prev !64
  else drop drop end
object end end


proc generate-log0
  // int: type -> ptr: log-item
  int -> ptr
in sizeof(log) malloc let object in
  object isn-null if
    object log:type !64
  else drop end
object end end


proc generate-log1
  // int: arg1 int: type -> ptr: log-item
  int int -> ptr
in sizeof(log) malloc let object in
  object isn-null if
    object log:type !64
    object log:arg1 !64
  else drop drop end
object end end


proc generate-log2
  // int: arg1 int: arg2 int: type -> ptr: log-item
  int int int -> ptr
in sizeof(log) malloc let object in
  object isn-null if
    object log:type !64
    object log:arg2 !64
    object log:arg1 !64
  else drop drop drop end
object end end


namespace LOG-TYPE
// Info messages (prefix: 0x0)

// Warnings (prefix: 0x1)

// Error messages (prefix: 0x2)
macro REACHED-EOF       0x20000 endmacro  //
macro REACHED-EOL       0x20001 endmacro  //
macro NO-TOKEN          0x20002 endmacro  // log-item: reason
macro TOKEN-TOO-LONG    0x20003 endmacro  //
macro INVALID-ESCAPE    0x20004 endmacro  // log-item: reason
macro NOT-HEX-DIGIT     0x20005 endmacro  //
macro NOT-ESCAPE-CHAR   0x20006 endmacro  //
macro INV-STR-LIT       0x20007 endmacro  // log-item: reason
macro INV-INT-LIT       0x20008 endmacro  //
macro INV-CHAR-LIT      0x20009 endmacro  //

// Assertions (prefix: 0x3)
macro MALLOC-FAILED     0x30000 endmacro  //
macro EXT-LEN-INVALID   0X30001 endmacro  //
endnamespace


proc fput-log-item
  // ptr: log-item file-desc: log-stream ->
  ptr file-desc ->
in let log-item log-stream in
  log-item log:type @64
  log-item log:arg1 @64
  log-item log:arg2 @64
  let type arg1 arg2 in
    "(#" log-stream fputs type log-stream fputx ") " log-stream fputs

    // Errors
    type LOG-TYPE:REACHED-EOF = if
      "reached EOF\n" log-stream fputs

    else type LOG-TYPE:REACHED-EOL = if
      "reached EOL\n" log-stream fputs

    else type LOG-TYPE:NO-TOKEN = if
      "no token available because:\n" log-stream fputs
      arg1 log-stream fput-log-item

    else type LOG-TYPE:TOKEN-TOO-LONG = if
      "token is too long\n" log-stream fputs

    else type LOG-TYPE:INVALID-ESCAPE = if
      "escape code is invalid because:\n" log-stream fputs
      arg1 log-stream fput-log-item

    else type LOG-TYPE:NOT-HEX-DIGIT = if
      "not an hexadecimal digit\n" log-stream fputs

    else type LOG-TYPE:NOT-ESCAPE-CHAR = if
      "invalid escape character\n" log-stream fputs

    else type LOG-TYPE:INV-STR-LIT = if
      "could not parse string literal because:\n" log-stream fputs
      arg1 log-stream fput-log-item

    else type LOG-TYPE:INV-INT-LIT = if
      "could not parse string literal\n" log-stream fputs

    else type LOG-TYPE:INV-CHAR-LIT = if
      "could not parse string literal\n" log-stream fputs

    // Assertions
    else type LOG-TYPE:MALLOC-FAILED = if
      "malloc failed\n" log-stream fputs

    else type LOG-TYPE:EXT-LEN-INVALID = if
      "extended array length is not a multiple of 3\n" log-stream fputs

    else
      "unknown\n" log-stream fputs
    end end end end end end end end end end end end
  end
end end
