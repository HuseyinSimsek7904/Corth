include "linux_x86/sys.corth"
include "linux_x86/io/output.corth"
include "linux_x86/io/input.corth"
include "linux_x86/io/ostrbuf.corth"

include "core/stack.corth"
include "core/arithmetic.corth"
include "core/memory.corth"

include "dynamic/malloc.corth"
include "dynamic/utils.corth"

macro string-builder.RESIZING 64 endmacro

include "linux_x86/path.corth"

include "collections/list64.corth"
include "collections/deque64.corth"
include "collections/stack64.corth"
include "collections/str_map64.corth"
include "collections/str_set8.corth"

include "lexer.corth"
include "debug.corth"
include "enums.corth"
include "local_stack.corth"


// str: expect-message bool: extend-macros -> int: token-type ptr: address [int|ptr]: arg
// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compiler:get-next-token let expect-address expect-length extend-macros in
  // Calls get-next-token and checks if a token is available-dstr. If there are no tokens, prints an error message.
  source-name source-file
  extended-array extended-start extended-end
  macro-names macro-tokens macros-length
  log-stream extend-macros get-next-token ! if
    LOG:ERR log-stream fputs "Reached EOF while expecting " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs
    EXIT-CODE:ERROR exit drop
  end
end endmacro


// ptr: token-arg ptr: expect-addr int: expect-length int: expected-token-arg
// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compiler:check-type let _token_type_ expect-address expect-length expected-token-type in
  expected-token-type _token_type_ != if
    LOG:ERR log-stream fputs "Expected a '" log-stream fputs expected-token-type log-stream fput-type  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_type_ log-stream fput-type "'.\n" log-stream fputs
    EXIT-CODE:ERROR exit drop
  end
end endmacro


// ptr: token-arg ptr: expect-addr int: expect-length int: expected-token-arg
// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compiler:check-keyword let _token_arg_ expect-address expect-length expected-token-arg in
  expected-token-arg _token_arg_ != if
    LOG:ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs
    EXIT-CODE:ERROR exit drop
  end
end endmacro


// ptr: token-arg ptr: expect-addr int: expect-length int: expected-token-arg
// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compiler:check-label let _token_arg_ expect-address expect-length expected-token-arg in
  expected-token-arg _token_arg_ != if
    LOG:ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs
    EXIT-CODE:ERROR exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compiler:check-null let expect-address expect-length in
  is-null if
    LOG:ERR log-stream fputs "'malloc' failed while " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs
    EXIT-CODE:ERROR exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure:new-label-id
  label-id-counter @64 dup inc label-id-counter !64
endmacro


macro invalid-usage-of-intrinsic
  LOG:ERR log-stream fputs "Invalid argument types.\n" log-stream fputs
  EXIT-CODE:ERROR exit drop
endmacro


proc compare-stack-types
  // ptr: old-stack ptr: local-stack ptr: local-stack-length -> bool: is-equal
  ptr ptr ptr -> bool
in let old-stack local-stack local-stack-length in
  local-stack-length @64 8 * old-stack mlength != if false return end

  0 while dup local-stack-length @64 < do let i in
    i old-stack array64:get stack-item:get-type i local-stack array64:get stack-item:get-type != if false return end
  i end inc end drop
end true end


proc compare-stack-types-types
  // ptr: types-array int: types-length ptr: local-stack ptr: local-stack-length -> bool: is-equal
  ptr int ptr ptr -> bool
in let
  types-array types-length
  local-stack local-stack-length
in
  types-length local-stack-length @64 != if false return end

  0 while dup types-length < do let i in
    i local-stack array64:get stack-item:get-type i types-array array64:get != if false return end
  i end inc end drop
end true end


proc compare-sub-stack-types-types
  // ptr: types-array int: types-length ptr: local-stack ptr: local-stack-length -> bool: is-equal
  ptr int ptr ptr -> bool
in let
  types-array types-length
  local-stack local-stack-length
in
  types-length local-stack-length @64 > if false return end

  types-length while dup isn-zero do dec let i in
    pop-item let item in
      i types-array array64:get let expected in
        item stack-item:get-type expected != if false return end
      end
    end
  i end end drop
end true end


proc fput-stack-contents
  // ptr: stack-ptr int: stack-length file-desc: log-stream ->
  ptr int file-desc ->
in let stack length log-stream in
  length is-zero if
    "<empty>\n" log-stream fputs
    return
  end

  0 while dup length dec < do peek i in
    i stack array64:get stack-item:get-type log-stream fput-int-type " " log-stream fputs
  end inc end drop

  length dec stack array64:get stack-item:get-type log-stream fput-int-type
end end


proc fput-types
  // ptr: types-array int: types-length file-desc: log-stream ->
  ptr int file-desc ->
in let types-array types-length log-stream in
  types-length is-zero if
    "<empty>\n" log-stream fputs
    return
  end

  0 while dup types-length dec < do peek i in
    i types-array array64:get log-stream fput-int-type " " log-stream fputs
  end inc end drop

  types-length dec types-array array64:get log-stream fput-int-type
end end


proc check-stack-types
  // ptr: old-stack ptr: local-stack ptr: local-stack-length file-desc: log-stream ->
  ptr ptr ptr file-desc ->
in let old-stack local-stack local-stack-length log-stream in
  old-stack local-stack local-stack-length compare-stack-types ! if
    LOG:ERR log-stream fputs "Stack contents do not match.\n" log-stream fputs
    LOG:INFO log-stream fputs old-stack old-stack mlength 8 / log-stream fput-stack-contents log-stream fputnl
    LOG:INFO log-stream fputs local-stack local-stack-length @64 log-stream fput-stack-contents log-stream fputnl

    EXIT-CODE:ERROR exit drop
  end
end end


proc check-stack-types-types
  // ptr: types-array int: types-length
  ptr int
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // file-desc: log-stream
  file-desc ->
in let
  types-array types-length
  local-stack local-stack-length
  log-stream
in
  types-array types-length local-stack local-stack-length compare-stack-types-types ! if
    LOG:ERR log-stream fputs "Stack contents do not match.\n" log-stream fputs
    LOG:INFO log-stream fputs "Expected '" log-stream fputs types-array types-length log-stream fput-types "'.\n" log-stream fputs
    LOG:INFO log-stream fputs "Got '" log-stream fputs local-stack local-stack-length @64 log-stream fput-stack-contents "'.\n" log-stream fputs

    EXIT-CODE:ERROR exit drop
  end
end end


proc check-sub-stack-types-types
  // ptr: types-array int: types-length
  ptr int
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // file-desc: log-stream
  file-desc ->
in let
  types-array types-length
  local-stack local-stack-length
  log-stream
in
  types-array types-length local-stack local-stack-length compare-sub-stack-types-types ! if
    LOG:ERR log-stream fputs "Stack contents do not match.\n" log-stream fputs
    LOG:INFO log-stream fputs "Expected '" log-stream fputs types-array types-length log-stream fput-types "'.\n" log-stream fputs
    LOG:INFO log-stream fputs "Got '" log-stream fputs local-stack local-stack-length @64 log-stream fput-stack-contents "'.\n" log-stream fputs

    EXIT-CODE:ERROR exit drop
  end
end end


proc add-intrinsic
  // ptr: token-address ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream file-desc: log-stream ->
  ptr ptr ptr ptr ptr file-desc ->
in let token-address local-stack local-stack-length peeked-item output-stream log-stream in
  2 is-items-available ! if invalid-usage-of-intrinsic end

  pop-item pop-item let item2 item1 in
    item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
    item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

    item1 stack-item:get-mode STACK-MODE:IMM = if
      item2 stack-item:get-mode STACK-MODE:IMM = if
        item1 stack-item:get-arg1 item2 stack-item:get-arg1 + push-int-immediate

      else item2 stack-item:get-mode STACK-MODE:LOCAL = if
        item1 stack-item:get-arg1 item2 stack-item:get-arg1 + push-int-local

      else
        INT-TYPE:INT push-real

        output-stream
        item2                     nasm:push
        item1 stack-item:get-arg1 nasm:add-immediate
        drop
      end end

    else item2 stack-item:get-mode STACK-MODE:IMM = if
      item1 stack-item:get-mode STACK-MODE:LOCAL = if
        item1 stack-item:get-arg1 item2 stack-item:get-arg1 + push-int-local

      else
        INT-TYPE:INT push-real

        output-stream
        item1                     nasm:push
        item2 stack-item:get-arg1 nasm:add-immediate
        drop
      end

    else
      INT-TYPE:INT push-real

      output-stream
      item2 register:RAX         nasm:mov-reg-item
      item1                      nasm:push
      "    add     [rsp], rax\n" ostrbuf:puts
      drop
    end end

    item1 stack-item:mfree
    item2 stack-item:mfree
  end
end end


proc get-register-name
  // int: intrinsic -> int: register-id
  int -> ptr
in let intrinsic in
       intrinsic INTRINSIC:STORE8  = if register:AL
  else intrinsic INTRINSIC:STORE16 = if register:AX
  else intrinsic INTRINSIC:STORE32 = if register:EAX
  else intrinsic INTRINSIC:STORE64 = if register:RAX
  else intrinsic INTRINSIC:LOAD8   = if register:AL
  else intrinsic INTRINSIC:LOAD16  = if register:AX
  else intrinsic INTRINSIC:LOAD32  = if register:EAX
  else intrinsic INTRINSIC:LOAD64  = if register:RAX
  else
    LOG:ERR STDERR fputs "Not a 'load' or 'store' intrinsic.\n" STDERR fputs
    1 exit drop
    0 // dummy
  end end end end end end end end
end end


proc load-intrinsic
  // ptr: token-address int: intrinsic ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream file-desc: log-stream ->
  ptr int ptr ptr ptr ptr file-desc ->
  // NOTE: Register is one of 'al', 'ax', 'eax', 'rax'.
in let token-address intrinsic local-stack local-stack-length peeked-item output-stream log-stream in
  1 is-items-available ! if invalid-usage-of-intrinsic end

  pop-item let item in
    item stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

    item stack-item:get-mode STACK-MODE:LOCAL = if
      intrinsic INTRINSIC:LOAD64 = if item stack-item:get-arg1 push-@64local return end
      intrinsic INTRINSIC:LOAD8  = if item stack-item:get-arg1 push-@8local  return end
    end

    item stack-item:get-mode STACK-MODE:GLOBAL = if
      intrinsic INTRINSIC:LOAD64 = if item stack-item:get-arg1 push-@64global return end
      intrinsic INTRINSIC:LOAD8  = if item stack-item:get-arg1 push-@8global  return end
    end

    INT-TYPE:INT push-real

    output-stream
    item register:RBX             nasm:mov-reg-item

    intrinsic INTRINSIC:LOAD64 = if
      "    push    qword [rbx]\n" ostrbuf:puts

    else
      register:RAX                nasm:mov-reg-zero
      "    mov     "              ostrbuf:puts
      intrinsic get-register-name nasm:put-register
      ", [rbx]\n"                 ostrbuf:puts
      register:RAX                nasm:push-register
    end
    drop
  end
end end


proc store-intrinsic-sub
  // ptr: value-item ptr: address-item int: address-item-length ptr: token-address int: intrinsic ptr: output-stream file-desc: log-stream ->
  ptr ptr int ptr int ptr file-desc ->
in let value-item address-item address-item-length token-address intrinsic output-stream log-stream in
  output-stream

  value-item stack-item:get-mode STACK-MODE:REAL = if
    intrinsic INTRINSIC:STORE64 = if
      "    pop     qword ["            ostrbuf:puts
      address-item address-item-length ostrbuf:puts
      "]\n"                            ostrbuf:puts
      drop
      return
    end
  end

  value-item stack-item:get-mode STACK-MODE:IMM = if
    intrinsic INTRINSIC:STORE64 = if
      value-item stack-item:get-arg1 nasm:is-signed-dword if
        "    mov     qword ["            ostrbuf:puts
        address-item address-item-length ostrbuf:puts
        "], "                            ostrbuf:puts
        value-item stack-item:get-arg1   ostrbuf:puti
                                         ostrbuf:putnl

        drop
        return
      end

    else intrinsic INTRINSIC:STORE8 = if
      "    mov     byte ["             ostrbuf:puts
      address-item address-item-length ostrbuf:puts
      "], "                            ostrbuf:puts
      value-item stack-item:get-arg1   ostrbuf:puti
                                       ostrbuf:putnl

      drop
      return
    end end
  end

  value-item stack-item:get-mode STACK-MODE:GLOBAL = if
    intrinsic INTRINSIC:STORE64 != if
      LOG:ERR log-stream fputs "Global variable addresses can not be stored in less than 64 bits.\n" log-stream fputs
      1 exit drop
    end

    "    mov     qword ["            ostrbuf:puts
    address-item address-item-length ostrbuf:puts
    "], global_"                     ostrbuf:puts

    value-item stack-item:get-arg1 nasm:fput-alpha

    ostrbuf:putnl
    drop
    return
  end

  value-item stack-item:get-mode STACK-MODE:DATA = if
    intrinsic INTRINSIC:STORE64 != if
      LOG:ERR log-stream fputs "Data addresses can not be stored in less than 64 bits.\n" log-stream fputs
      1 exit drop
    end

    "    mov     qword [" ostrbuf:puts
    address-item address-item-length ostrbuf:puts
    "], data_" ostrbuf:puts
    value-item stack-item:get-arg1 ostrbuf:putu
    ostrbuf:putnl
    drop
    return
  end

  value-item register:RAX          nasm:mov-reg-item
  "    mov     ["                  ostrbuf:puts
  address-item address-item-length ostrbuf:puts
  "], "                            ostrbuf:puts
  intrinsic get-register-name      nasm:put-register
                                   ostrbuf:putnl

  drop
end end



proc store-intrinsic
  // ptr: token-address int: intrinsic ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream file-desc: log-stream ->
  ptr int ptr ptr ptr ptr file-desc ->
  // NOTE: Register is one of 'bl', 'bx', 'ebx', 'rbx'.
in let token-address intrinsic local-stack local-stack-length peeked-item output-stream log-stream in
  2 is-items-available ! if invalid-usage-of-intrinsic end

  output-stream
  pop-item pop-item let address-item value-item in
    value-item   stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
    address-item stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

    local-stack local-stack-length output-stream local-stack.convert-@local-real

    address-item stack-item:get-mode STACK-MODE:IMM = if
      LOG:ERR log-stream fputs "Store intrinsics do not take immediate value as address argument.\n" log-stream fputs
      1 exit drop

    else address-item stack-item:get-mode STACK-MODE:LOCAL = if
      // TODO: Fix this disgusting hack.
      "    mov     rbx, [local_ptr]\n" ostrbuf:puts

      memory buffer 20 in
        buffer address-item stack-item:get-arg1 intconvud let buffer-start in
          "rbx + " buffer-start buffer 20 + buffer-start - to-dynamic8-join
        end
      end

      let object in
        value-item object object mlength token-address intrinsic output-stream log-stream store-intrinsic-sub
        object mfree drop
      end

    else address-item stack-item:get-mode STACK-MODE:GLOBAL = if
      address-item stack-item:get-arg1 nasm:global-label let label in
        value-item label label mlength token-address intrinsic output-stream log-stream store-intrinsic-sub
        label mfree drop
      end

    else
      address-item register:RBX nasm:mov-reg-item
      value-item register:RBX register:get-register-name token-address intrinsic output-stream log-stream store-intrinsic-sub
    end end end
  end
  drop
end end


proc get-log2
  int -> int
  // Returns 0-63 for whole powers of 2, <0 otherwise.
in let x in
       x           1 = if 0
  else x       is-zero if MIN-INT
  else x 2  % isn-zero if MIN-INT
  else                    x 2 / get-log2 inc
  end end end
end end


proc multiply-immediate-any
  // bool: upper int: immediate ptr: item ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream ->
  bool int ptr ptr ptr ptr ptr ->
in let upper immediate item local-stack local-stack-length peeked-item output-stream in
  immediate get-log2 let log2 in
    INT-TYPE:INT push-real

    // TODO: Multiplication by numbers that are not whole powers of 2 without using the 'mul' instruction is possible.
    output-stream
    log2 is-neg if
      item      register:RAX        nasm:mov-reg-item
      immediate register:RBX        nasm:mov-reg-immediate

      "    imul    rbx\n"           ostrbuf:puts

      upper if register:RDX else register:RAX end nasm:push-register

    else
      item                          nasm:push

      upper if
        "    sar     qword [rsp], " ostrbuf:puts
        64 log2 -                   ostrbuf:putu

      else
        "    sal     qword [rsp], " ostrbuf:puts
        log2                        ostrbuf:putu
      end

                                    ostrbuf:putnl
    end
    drop
  end
end end


proc multiply-intrinsic
  // ptr: token-address bool: upper ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream file-desc: log-stream ->
  ptr bool ptr ptr ptr ptr file-desc ->
in let token-address upper local-stack local-stack-length peeked-item output-stream log-stream in
  2 is-items-available ! if invalid-usage-of-intrinsic end

  pop-item pop-item let item2 item1 in
    item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
    item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

    item1 stack-item:get-mode STACK-MODE:IMM = if
      item2 stack-item:get-mode STACK-MODE:IMM = if
        item1 stack-item:get-arg1 item2 stack-item:get-arg1

        upper if *2 else * end

        push-int-immediate
      else
        upper item1 stack-item:get-arg1 item2 local-stack local-stack-length peeked-item output-stream multiply-immediate-any
      end

    else
      item2 stack-item:get-mode STACK-MODE:IMM = if
        upper item2 stack-item:get-arg1 item1 local-stack local-stack-length peeked-item output-stream multiply-immediate-any
      else
        INT-TYPE:INT push-real

        output-stream
        item2 register:RBX  nasm:mov-reg-item
        item1 register:RAX  nasm:mov-reg-item
        "    imul    rbx\n" ostrbuf:puts
        upper if register:RDX else register:RAX end nasm:push-register
        drop
      end
    end

    item1 stack-item:mfree
    item2 stack-item:mfree
  end
end end


proc bitwise-and-any-immediate
  // ptr: item int: immediate ptr: local-stack ptr: local-stack-length ptr: output-stream ->
  ptr int ptr ptr ptr ->
in let item immediate local-stack local-stack-length output-stream in
  output-stream
  item                        nasm:push
  "    and     qword [rsp], " ostrbuf:puts
  immediate                   ostrbuf:putu
                              ostrbuf:putnl
  drop
end end


proc divide-intrinsic
  // ptr: token-address bool: modulo ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream file-desc: log-stream ->
  ptr bool ptr ptr ptr ptr file-desc ->
in let token-address modulo local-stack local-stack-length peeked-item output-stream log-stream in
  2 is-items-available ! if invalid-usage-of-intrinsic end

  output-stream

  pop-item pop-item let item2 item1 in
    item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
    item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

    item2 stack-item:get-mode STACK-MODE:IMM = if
      item2 stack-item:get-arg1 get-log2 let log2 in
        INT-TYPE:INT push-real

        // TODO: Division/modulo by numbers that are not whole powers of 2 without using the 'div' instruction is possible.
        log2 isn-neg modulo & if
          item1 item2 stack-item:get-arg1 dec local-stack local-stack-length output-stream bitwise-and-any-immediate

        else
          item2 register:RBX  nasm:mov-reg-item
          item1 register:RAX  nasm:mov-reg-item
                register:RDX  nasm:mov-reg-zero
          "    idiv    rbx\n" ostrbuf:puts
          modulo if register:RDX else register:RAX end nasm:push-register
        end
      end

    else
      INT-TYPE:INT push-real

      item2 register:RBX  nasm:mov-reg-item
      item1 register:RAX  nasm:mov-reg-item
            register:RDX  nasm:mov-reg-zero
      "    idiv    rbx\n" ostrbuf:puts
      modulo if register:RDX else register:RAX end nasm:push-register
    end

    item1 stack-item:mfree
    item2 stack-item:mfree
  end

  drop
end end


proc compile-intrinsic
  // ptr: source-name file-desc: source-file ptr: output-stream
  ptr file-desc ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: peeked-item
  ptr
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // file-desc: log-stream
  file-desc ->

  // Compiles an intrinsic in a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let
  source-name source-file output-stream
  local-stack local-stack-length
  peeked-item
  token-type token-address token-arg
  log-stream
in
       token-arg INTRINSIC:ADD = if token-address local-stack local-stack-length peeked-item output-stream log-stream add-intrinsic
  else token-arg INTRINSIC:SUB = if
    // -------- Intrinsic '-' --------
    2 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      item2 stack-item:get-mode STACK-MODE:IMM = if
        item1                     nasm:push
        item2 stack-item:get-arg1 neg nasm:add-immediate

      else
        item2 register:RAX         nasm:mov-reg-item
        item1                      nasm:push
        "    sub     [rsp], rax\n" ostrbuf:puts
      end
      drop

      item1 stack-item:mfree
      item2 stack-item:mfree
    end

  else token-arg INTRINSIC:BOR = if
    // -------- Intrinsic '||' --------
    2 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      item2 register:RAX         nasm:mov-reg-item
      item1                      nasm:push
      "    or      [rsp], rax\n" ostrbuf:puts
      drop

      item1 stack-item:mfree
      item2 stack-item:mfree
    end

  else token-arg INTRINSIC:BAND = if
    // -------- Intrinsic '&&' --------
    2 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item let item1 item2 in
      item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      item2 register:RAX         nasm:mov-reg-item
      item1                      nasm:push
      "    and     [rsp], rax\n" ostrbuf:puts
      drop

      item1 stack-item:mfree
      item2 stack-item:mfree
    end

  else token-arg INTRINSIC:BXOR = if
    // -------- Intrinsic '^^' --------
    2 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item let item1 item2 in
      item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      item2 register:RAX         nasm:mov-reg-item
      item1                      nasm:push
      "    xor     [rsp], rax\n" ostrbuf:puts
      drop

      item1 stack-item:mfree
      item2 stack-item:mfree
    end

  else token-arg INTRINSIC:BNOT = if
    // -------- Intrinsic '!!' --------

    1 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item let item in
      item stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      item stack-item:get-mode STACK-MODE:IMM = if
        item stack-item:get-arg1 !! push-int-immediate

      else
        INT-TYPE:INT push-real

        output-stream
        item                        nasm:push
        "    not     qword [rsp]\n" ostrbuf:puts
        drop
      end

      item stack-item:mfree
    end

  else token-arg INTRINSIC:MUL     = if token-address false local-stack local-stack-length peeked-item output-stream log-stream multiply-intrinsic
  else token-arg INTRINSIC:MUL2    = if token-address true  local-stack local-stack-length peeked-item output-stream log-stream multiply-intrinsic
  else token-arg INTRINSIC:DIV     = if token-address false local-stack local-stack-length peeked-item output-stream log-stream divide-intrinsic
  else token-arg INTRINSIC:MOD     = if token-address true  local-stack local-stack-length peeked-item output-stream log-stream divide-intrinsic

  else token-arg INTRINSIC:LOAD8   = if token-address token-arg local-stack local-stack-length peeked-item output-stream log-stream load-intrinsic
  else token-arg INTRINSIC:LOAD16  = if token-address token-arg local-stack local-stack-length peeked-item output-stream log-stream load-intrinsic
  else token-arg INTRINSIC:LOAD32  = if token-address token-arg local-stack local-stack-length peeked-item output-stream log-stream load-intrinsic
  else token-arg INTRINSIC:LOAD64  = if token-address token-arg local-stack local-stack-length peeked-item output-stream log-stream load-intrinsic

  else token-arg INTRINSIC:STORE8  = if token-address token-arg local-stack local-stack-length peeked-item output-stream log-stream store-intrinsic
  else token-arg INTRINSIC:STORE16 = if token-address token-arg local-stack local-stack-length peeked-item output-stream log-stream store-intrinsic
  else token-arg INTRINSIC:STORE32 = if token-address token-arg local-stack local-stack-length peeked-item output-stream log-stream store-intrinsic
  else token-arg INTRINSIC:STORE64 = if token-address token-arg local-stack local-stack-length peeked-item output-stream log-stream store-intrinsic

  else token-arg INTRINSIC:SYSCALL0 = if
    // -------- Intrinsic 'syscall0' --------

    1 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item let op-item in
      op-item   stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      op-item   stack-item:mfree
    end

  else token-arg INTRINSIC:SYSCALL1 = if
    // -------- Intrinsic 'syscall1' --------

    2 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item let op-item arg-item1 in
      arg-item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      op-item   stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      op-item   stack-item:mfree
    end

  else token-arg INTRINSIC:SYSCALL2 = if
    // -------- Intrinsic 'syscall2' --------

    3 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item let op-item arg-item2 arg-item1 in
      arg-item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      op-item   stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      op-item   stack-item:mfree
    end

  else token-arg INTRINSIC:SYSCALL3 = if
    // -------- Intrinsic 'syscall3' --------

    4 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item pop-item  let op-item arg-item3 arg-item2 arg-item1 in
      arg-item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item3 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      op-item   stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item3 register:RDX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      arg-item3 stack-item:mfree
      op-item   stack-item:mfree
    end

  else token-arg INTRINSIC:SYSCALL4 = if
    // -------- Intrinsic 'syscall4' --------

    5 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item pop-item pop-item let op-item arg-item4 arg-item3 arg-item2 arg-item1 in
      arg-item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item3 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item4 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      op-item   stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item4 register:R10 nasm:mov-reg-item
      arg-item3 register:RDX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      arg-item3 stack-item:mfree
      arg-item4 stack-item:mfree
      op-item   stack-item:mfree
    end

  else token-arg INTRINSIC:SYSCALL5 = if
    // -------- Intrinsic 'syscall5' --------

    6 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item pop-item pop-item pop-item let op-item arg-item5 arg-item4 arg-item3 arg-item2 arg-item1 in
      arg-item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item3 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item4 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item5 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      op-item   stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item5 register:R8  nasm:mov-reg-item
      arg-item4 register:R10 nasm:mov-reg-item
      arg-item3 register:RDX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      arg-item3 stack-item:mfree
      arg-item4 stack-item:mfree
      arg-item5 stack-item:mfree
      op-item   stack-item:mfree
    end

  else token-arg INTRINSIC:SYSCALL6 = if
    // -------- Intrinsic 'syscall6' --------

    7 is-items-available ! if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item pop-item pop-item pop-item pop-item let op-item arg-item6 arg-item5 arg-item4 arg-item3 arg-item2 arg-item1 in
      arg-item1 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item2 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item3 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item4 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item5 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      arg-item6 stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end
      op-item   stack-item:get-type INT-TYPE:INT != if invalid-usage-of-intrinsic end

      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item6 register:R9  nasm:mov-reg-item
      arg-item5 register:R8  nasm:mov-reg-item
      arg-item4 register:R10 nasm:mov-reg-item
      arg-item3 register:RDX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      arg-item3 stack-item:mfree
      arg-item4 stack-item:mfree
      arg-item5 stack-item:mfree
      arg-item6 stack-item:mfree
      op-item   stack-item:mfree
    end

  else
    LOG:TODO log-stream fputs "Intrinsic '" log-stream fputs token-arg log-stream fput-intrinsic "' is not implemented yet.\n" log-stream fputs
    EXIT-CODE:ERROR exit drop
  end end end end end end end end end end end end end end end end end end end end end end end end end
end end


proc collect-let-like-names
  // ptr: new-names-list
  ptr
  // ptr: source-name file-desc: source-file
  ptr file-desc
  // ptr: macro-names ptr: macro-tokens ptr: macros-length
  ptr ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // file-desc: log-stream
  file-desc
  ->
  // Fills new-names-list until an 'in' keyword is found.
in let
  new-names-list
  source-name source-file
  macro-names macro-tokens macros-length
  extended-array extended-start extended-end
  log-stream
in
  // Get the names of the 'let' variables.
  while true do
    // Get the name of the variable.
    "a 'name' for 'let' variable" false compiler:get-next-token

    let new-token-type new-token-address new-token-arg in
      new-token-type TOKEN-TYPE:KEYWORD = if
        // If token is a keyword, it must be a 'in' keyword.
        new-token-arg "after 'let'" KEYWORD:IN compiler:check-keyword

        // If the token is a 'in' keyword, break the loop.
        break
      end

      // Check the type of the token.
      new-token-type "after 'let'" TOKEN-TYPE:NAME compiler:check-type

      // TODO: Change the way that the variables are stored, so that we can also store their addresses.
      new-token-arg new-names-list list64:append
    end
  end
end end


proc collect-memory-like-names
  // ptr: new-names-list ptr: new-sizes-list int: terminator-keyword
  ptr ptr int
  // ptr: source-name file-desc: source-file
  ptr file-desc
  // ptr: macro-names ptr: macro-tokens ptr: macros-length
  ptr ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // file-desc: log-stream
  file-desc ->
  // Fills new-names-list and new-sizes-list until a terminator keyword is found.
in let
  new-names-list new-sizes-list terminator-keyword
  source-name source-file
  macro-names macro-tokens macros-length
  extended-array extended-start extended-end
  log-stream
in
  while
    // Get the variable name.
    "a variable name" false compiler:get-next-token

    let memory-name-type memory-name-address memory-name-arg in
      memory-name-type "" TOKEN-TYPE:NAME compiler:check-type

      // Get the variable size.
      "a variable size" true compiler:get-next-token

      let memory-size-type memory-size-address memory-size-arg in
        // The token after variable name should be an 'integer'.
        memory-size-type "" TOKEN-TYPE:INTEGER compiler:check-type

        "an 'end'" true compiler:get-next-token

        let memory-end-type memory-end-address memory-end-arg in
          // The token after variable size should be a 'keyword'.
          memory-end-type "" TOKEN-TYPE:KEYWORD compiler:check-type

          memory-name-arg new-names-list list64:append
          memory-size-arg new-sizes-list list64:append

          // Check if the keyword is not the terminator keyword.
          memory-end-arg terminator-keyword != dup

          // If keyword is not the terminator, check if it is 'and'.
          if memory-end-arg "after 'memory'" KEYWORD:AND compiler:check-keyword end
        end
      end
    end
  do end
end end


proc compile-unreachable
  // ptr: source-name file-desc: source-file ptr: output-stream
  ptr file-desc ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: peeked-item
  ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // ptr: labels-list ptr: label-id-counter
  ptr ptr
  // ptr: local-memory-end
  ptr
  // ptr: let-names ptr: let-addresses ptr: let-vars-length
  ptr ptr ptr
  // ptr: output-array int: output-length
  ptr int
  // file-desc: log-stream
  file-desc
  // ptr: local-memory-max
  ptr
  ->
  // Consume tokens until an reachable code is received.
  // All of the tokens must be keywords as intrinsics can not allow branches.
in let
  source-name source-file output-stream
  macro-names macro-tokens macros-length
  local-stack local-stack-length
  peeked-item
  extended-array extended-start extended-end
  labels-list label-id-counter
  local-memory-end
  let-names let-addresses let-vars-length
  output-array output-length
  log-stream
  local-memory-max
in
  while true do
    "end of unreachable branch" true compiler:get-next-token

    let token-type token-address token-arg in
      token-type "in unreachable branch" TOKEN-TYPE:KEYWORD compiler:check-type
      token-arg "in unreachable branch" KEYWORD:END compiler:check-keyword

      labels-list list64:length is-zero if
        LOG:ERR log-stream fputs "End of 'proc' must be reachable.\n" log-stream fputs
        EXIT-CODE:ERROR exit drop
      end

      labels-list list64:pop-last let label in
        label @64 label 8 + @64 let start-keyword start-address in
          start-keyword KEYWORD:IF = if
            label 16 + @64 label 24 + @64 let start-id start-stack in
              // Overwrite the contents of the local-stack with the old contents.
              start-stack local-stack local-stack-length local-stack.overwrite

              output-stream
              start-id nasm:label
              drop

              // Deallocate 'start-stack'.
              start-stack _local-stack.mfree

              return
            end
          end

          start-keyword KEYWORD:LET = if
            label 16 + @64 label 24 + @64 let new-names old-local-memory-end in
              0 while dup new-names mlength 8 / < do peek i in i 8 * new-names + @64 let name in
                name mlength 1 = if name @8 '_' != else true end if
                  name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                    LOG:ERR  log-stream fputs "Could not find the 'let' variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                    log-stream report-bug
                    EXIT-CODE:ERROR exit drop
                  end
                end
              end end inc end drop

              old-local-memory-end local-stack local-stack-length output-stream local-stack.convert-deleted-real

              old-local-memory-end local-memory-end !64

              // Deallocate 'new-names'.
              new-names mfree drop
            end

          else start-keyword KEYWORD:PEEK = if
            label 16 + @64 label 24 + @64 let new-names old-peeked-item in
              0 while dup new-names mlength 8 / < do peek i in i 8 * new-names + @64 let name in
                name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                  LOG:ERR  log-stream fputs "Could not find the 'peek' variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                  log-stream report-bug
                  EXIT-CODE:ERROR exit drop
                end
              end end inc end drop

              old-peeked-item peeked-item !64

              // Deallocate 'new-names'.
              new-names mfree drop
            end

          else start-keyword KEYWORD:MEMORY = if
            label 16 + @64 label 24 + @64 let new-names old-local-memory-end in
              0 while dup new-names mlength 8 / < do peek i in i 8 * new-names + @64 let name in
                name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                  LOG:ERR  log-stream fputs "Could not find the local variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs

                  log-stream report-bug
                  EXIT-CODE:ERROR exit drop
                end
              end end inc end drop

              old-local-memory-end local-stack local-stack-length output-stream local-stack.convert-deleted-real

              old-local-memory-end local-memory-end !64

              // Deallocate 'new-names'.
              new-names mfree drop
            end

          else
            LOG:ERR log-stream fputs "Can not end '" log-stream fputs start-keyword log-stream fput-keyword "' in unreachable branch.\n" log-stream fputs
            EXIT-CODE:ERROR exit drop
          end end end
        end
      end
    end
  end
end end


proc compile-keyword
  // ptr: source-name file-desc: source-file ptr: output-stream
  ptr file-desc ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: peeked-item
  ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // ptr: labels-list ptr: label-id-counter
  ptr ptr
  // ptr: local-memory-end
  ptr
  // ptr: let-names ptr: let-addresses ptr: let-vars-length
  ptr ptr ptr
  // ptr: output-array int: output-length
  ptr int
  // file-desc: log-stream
  file-desc
  // ptr: local-memory-max
  ptr
  ->
  // bool: end-of-procedure
  bool
in let
  source-name source-file output-stream
  macro-names macro-tokens macros-length
  local-stack local-stack-length
  peeked-item
  extended-array extended-start extended-end
  token-type token-address token-arg
  labels-list label-id-counter
  local-memory-end
  let-names let-addresses let-vars-length
  output-array output-length
  log-stream
  local-memory-max
in
  token-arg KEYWORD:END = if
    // -------- Keyword 'end' --------

    labels-list list64:length is-zero if
      // -------- End of 'proc' --------

      local-stack local-stack-length output-stream local-stack.convert-last-items-real

      // Check if the stack is correct.
      output-array output-length
      local-stack local-stack-length
      log-stream
      check-stack-types-types

      true return
    end

    labels-list list64:pop-last let label in
      label @64 label 8 + @64 let start-keyword start-address in
        start-keyword KEYWORD:IF = if
          // -------- End of 'if' --------
          label 16 + @64 label 24 + @64 let start-id start-stack in
            local-stack local-stack-length output-stream local-stack.convert-last-items-real

            // Check for the stack changes.
            start-stack local-stack local-stack-length log-stream check-stack-types

            output-stream
            start-id nasm:label
            drop

            // Deallocate 'start-stack'.
            start-stack _local-stack.mfree
          end

        else start-keyword KEYWORD:ELSE = if
          // -------- End of 'else' --------

          label 16 + @64 label 24 + @64 label 32 + @64 let else-address start-id start-stack in
            local-stack local-stack-length output-stream local-stack.convert-last-items-real

            // Check for the stack changes.
            start-stack local-stack local-stack-length log-stream check-stack-types

            output-stream
            start-id nasm:label
            drop

            // Deallocate 'start-stack'.
            start-stack _local-stack.mfree
          end

        else start-keyword KEYWORD:WHILE = if
          // -------- End of 'while' --------

          LOG:ERR  log-stream fputs "You probably forgot a 'do' after 'while'.\n" log-stream fputs
          LOG:INFO log-stream fputs "A 'while-do' loop can be created as: 'while <condition> do <code> end'\n" log-stream fputs

          EXIT-CODE:ERROR exit drop

        else start-keyword KEYWORD:DO = if
          // -------- End of 'do' --------

          label 16 + @64 label 24 + @64 label 32 + @64 label 40 + @64 label 48 + @64 label 56 + @64 let
            while-label-id do-address unbroken-end-id broken-end-id while-stack do-stack
          in
            // Check for the stack changes.
            while-stack local-stack local-stack-length log-stream check-stack-types

            // Overwrite the contents of the local-stack.
            do-stack local-stack local-stack-length local-stack.overwrite

            output-stream
            while-label-id  nasm:jump-label
            unbroken-end-id nasm:label
            broken-end-id   nasm:label
            drop

            // Deallocate 'while-stack' and 'do-stack'.
            while-stack _local-stack.mfree
            do-stack _local-stack.mfree
          end

        else start-keyword KEYWORD:LET = if
          // -------- End of 'let' --------

          label 16 + @64 label 24 + @64 let new-names old-local-memory-end in
            0 while dup new-names mlength 8 / < do peek i in i 8 * new-names + @64 let name in
              name mlength 1 = if name @8 '_' != else true end if
                name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                  LOG:ERR  log-stream fputs "Could not find the 'let' variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                  log-stream report-bug
                  EXIT-CODE:ERROR exit drop
                end
              end
            end end inc end drop

            old-local-memory-end local-stack local-stack-length output-stream local-stack.convert-deleted-real

            old-local-memory-end local-memory-end !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end

        else start-keyword KEYWORD:PEEK = if
          // -------- End of 'peek' --------

          label 16 + @64 label 24 + @64 let new-names old-peeked-item in
            0 while dup new-names mlength 8 / < do peek i in i 8 * new-names + @64 let name in
              name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                LOG:ERR  log-stream fputs "Could not find the 'peek' variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                log-stream report-bug
                EXIT-CODE:ERROR exit drop
              end
            end end inc end drop

            old-peeked-item peeked-item !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end

        else start-keyword KEYWORD:MEMORY = if
          // -------- End of 'memory' --------

          label 16 + @64 label 24 + @64 let new-names old-local-memory-end in
            0 while dup new-names mlength 8 / < do peek i in i 8 * new-names + @64 let name in
              name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                LOG:ERR log-stream fputs "Could not find the local variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs

                log-stream report-bug
                EXIT-CODE:ERROR exit drop
              end
            end end inc end drop

            old-local-memory-end local-stack local-stack-length output-stream local-stack.convert-deleted-real

            old-local-memory-end local-memory-end !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end

        else
          LOG:TODO log-stream fputs "'end' after keyword '" log-stream fputs start-keyword log-stream fput-keyword "' is not implemented yet.\n" log-stream fputs
          EXIT-CODE:ERROR exit drop
        end end end end end end end
      end

      // Deallocate label object.
      label mfree drop
    end

  else token-arg KEYWORD:IF = if
    // -------- Keyword 'if' --------
    // <condition> if <any> end
    // <condition> if <any> else <any> end

    // TODO: These are not implemented yet.
    // <condition> if <any> (elif <condition> if <any>)* end

    // Label structure:
    //  0- 7 -> KEYWORD:IF
    //  8-15 -> Starter address
    // 16-23 -> Label ID
    // 24-31 -> Old stack

    1 is-items-available ! if
      LOG:ERR log-stream fputs "'if' requires a bool, there was no items in the stack.\n" log-stream fputs
      EXIT-CODE:ERROR exit drop
    end

    pop-item let item in
      item stack-item:get-type INT-TYPE:BOOL != if
        LOG:ERR log-stream fputs "'if' requires a bool\n" log-stream fputs
        EXIT-CODE:ERROR exit drop
      end

      output-stream
      item nasm:convert-real
      drop

      item stack-item:mfree
    end

    local-stack local-stack-length local-stack.copy let copy-stack in
      32 malloc let obj in
        obj "creating a label object for 'if'" compiler:check-null

        compile-procedure:new-label-id let label-id in
          KEYWORD:IF           obj      !64
          0                    obj 8  + !64
          label-id             obj 16 + !64
          copy-stack           obj 24 + !64

          obj labels-list list64:append

          output-stream
          "    pop     rax\n"      ostrbuf:puts
          "    test    rax, rax\n" ostrbuf:puts
          label-id                 nasm:jump-zero-label
          drop
        end
      end
    end

  else token-arg KEYWORD:ELSE = if
    // -------- Keyword 'else' --------
    // <condition> if <any> else <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:ELSE
    //  8-15 -> If address
    // 16-23 -> Else address
    // 24-31 -> Label ID
    // 32-39 -> Old stack

    labels-list list64:length is-zero if
      LOG:ERR log-stream fputs "'else' requires 'if'.\n" log-stream fputs
      EXIT-CODE:ERROR exit drop
    end

    local-stack local-stack-length output-stream local-stack.convert-last-items-real

    labels-list list64:pop-last let label in
      label @64 label 8 + @64 let old-keyword old-address in
        old-keyword "before 'else'" KEYWORD:IF compiler:check-label

        label 16 + @64 label 24 + @64 let start-id start-stack in
          local-stack local-stack-length local-stack.copy let copy-stack in
            // Overwrite the contents of the local-stack.
            start-stack local-stack local-stack-length local-stack.overwrite

            compile-procedure:new-label-id let label-id in
              output-stream
              label-id nasm:jump-label
              start-id nasm:label
              drop

              40 malloc let new-label in
                new-label "creating a label object for 'else'" compiler:check-null

                KEYWORD:ELSE         new-label      !64
                old-address          new-label 8  + !64
                0                    new-label 16 + !64
                label-id             new-label 24 + !64
                copy-stack           new-label 32 + !64

                new-label labels-list list64:append
              end
            end
          end

          // Deallocate 'start-stack'.
          start-stack _local-stack.mfree
        end
      end

      // Deallocate label object.
      label mfree drop
    end

  else token-arg KEYWORD:WHILE = if
    // -------- Keyword 'while' --------
    // while <condition> do <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:WHILE
    //  8-15 -> Starter address
    // 16-23 -> Label ID
    // 24-31 -> Old stack

    local-stack local-stack-length local-stack.copy let copy-stack in
      copy-stack "creating a label object for 'while'" compiler:check-null

      compile-procedure:new-label-id let label-id in
        local-stack local-stack-length output-stream local-stack.convert-last-items-real

        output-stream
        label-id nasm:label
        drop

        32 malloc let new-label in
          new-label "creating a label object for 'while'" compiler:check-null

          KEYWORD:WHILE        new-label      !64
          0                    new-label 8  + !64
          label-id             new-label 16 + !64
          copy-stack           new-label 24 + !64

          new-label labels-list list64:append
        end
      end
    end

  else token-arg KEYWORD:DO = if
    // -------- Keyword 'do' --------
    // while <condition> do <any> end

    // TODO: These are not implemented yet.
    // while <condition> do <any> [else <any>] end

    // Label structure:
    //  0- 7 -> KEYWORD:DO
    //  8-15 -> While address
    // 16-23 -> While label label ID
    // 24-31 -> Do address
    // 32-39 -> Unbroken loop end label ID
    // 40-47 -> Broken loop end label ID
    // 48-55 -> While stack
    // 56-63 -> Do stack

    // Check if the local stack contains any item.
    1 is-items-available ! if
      LOG:ERR log-stream fputs "'do' requires a bool, there was no items in the stack.\n" log-stream fputs
      EXIT-CODE:ERROR exit drop
    end

    local-stack local-stack-length output-stream local-stack.convert-last-items-real

    // Remove the bool value from the local-stack.
    pop-item let item in
      item stack-item:get-type INT-TYPE:BOOL != if
        LOG:ERR log-stream fputs "'do' requires a bool.\n" log-stream fputs
        EXIT-CODE:ERROR exit drop
      end

      item stack-item:mfree
    end

    // Get the 'while' label.
    labels-list list64:pop-last let old-label in
      old-label @64 old-label 8 + @64 let old-keyword old-address in
        // Check if the label type is 'while'.
        old-keyword "before 'do'" KEYWORD:WHILE compiler:check-label

        old-label 16 + @64 old-label 24 + @64 let old-label-id old-stack in
          compile-procedure:new-label-id compile-procedure:new-label-id let unbroken-end-label-id broken-end-label-id in
            compile-procedure:new-label-id compile-procedure:new-label-id let unbroken-end-id broken-end-id in
              output-stream
              "    pop     rax\n"      ostrbuf:puts
              "    test    rax, rax\n" ostrbuf:puts
              unbroken-end-id          nasm:jump-zero-label
              drop

              local-stack local-stack-length local-stack.copy let copy-stack in
                copy-stack "copying the stack for 'do'" compiler:check-null

                64 malloc let new-label in
                  new-label "creating a label object for 'do' after 'while'" compiler:check-null

                  KEYWORD:DO               new-label      !64
                  old-address              new-label 8  + !64
                  old-label-id             new-label 16 + !64
                  0                        new-label 24 + !64
                  unbroken-end-id          new-label 32 + !64
                  broken-end-id            new-label 40 + !64
                  old-stack                new-label 48 + !64
                  copy-stack               new-label 56 + !64
                  new-label labels-list list64:append
                end
              end
            end
          end
        end
      end
    end

  else token-arg KEYWORD:BREAK = if
    // -------- Keyword 'break' -------
    // break

    labels-list list64:end-addr while dup labels-list list64:array-addr > do 8 - let label-addr in
      label-addr @64 @64 label-addr @64 8 + @64 let old-keyword old-address in
        old-keyword KEYWORD:DO = if
          label-addr @64 32 + @64 label-addr @64 24 + @64 label-addr @64 56 + @64 let broken-end-id do-address do-stack in
            // Check for the stack contents.
            do-stack local-stack local-stack-length log-stream check-stack-types

            local-stack local-stack-length output-stream local-stack.convert-last-items-real

            output-stream
            broken-end-id nasm:jump-label
            drop
          end

          source-name source-file output-stream
          macro-names macro-tokens macros-length
          local-stack local-stack-length
          peeked-item
          extended-array extended-start extended-end
          labels-list label-id-counter
          local-memory-end
          let-names let-addresses let-vars-length
          output-array output-length
          log-stream
          local-memory-max
          compile-unreachable
          0 break
        end
      end
    label-addr end end drop

  else token-arg KEYWORD:MEMORY = if
    // -------- Keyword 'memory' -------
    // memory <name> <size> (and <name> <size>)* in <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:MEMORY
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-31 -> Old local-memory-end

    // New names are stored in new-names and new-names-length stack. When the 'end' of 'memory' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) and
           new-sizes-list sizeof(ptr) in
      list64:init let dynamic in
        dynamic "creating list dynamic object for 'memory'" compiler:check-null

        dynamic new-names-list !64
      end

      list64:init let dynamic in
        dynamic "creating list dynamic object for 'memory'" compiler:check-null

        dynamic new-sizes-list !64
      end

      // TODO: Add proper pre-compilation for memory size.

      new-names-list new-sizes-list KEYWORD:IN
      source-name source-file
      macro-names macro-tokens macros-length
      extended-array extended-start extended-end
      log-stream
      collect-memory-like-names

      0 while dup new-names-list list64:length < do peek i in
        i new-names-list list64:get let name in
          INT-TYPE:INT STACK-MODE:LOCAL stack-item:create let replace-item in
            local-memory-end @64 dup
            replace-item stack-item:set-arg1
            i new-sizes-list list64:get + local-memory-end !64

            name replace-item let-names let-addresses let-vars-length str-map64:set-dstr if
              LOG:ERR log-stream fputs "Local variable '" log-stream fputs name dup mlength log-stream fputs "' was already defined before.\n" log-stream fputs
              EXIT-CODE:ERROR exit drop
            end
          end
        end
      end inc end drop

      local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

      32 malloc let new-label in
        new-label "creating a label object for 'memory'" compiler:check-null

        KEYWORD:MEMORY                   new-label      !64
        0                                new-label  8 + !64
        new-names-list list64:copy-array new-label 16 + !64
        local-memory-end @64             new-label 24 + !64

        new-label labels-list list64:append
      end

      // Deallocate 'new-names-list' and 'new-sizes-list' but keep the 'memory' variable names.
      new-names-list list64:mfree drop
      new-sizes-list list64:mfree drop
    end

  else token-arg KEYWORD:LET = if
    // -------- Keyword 'let' --------
    // let <name>* in <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:LET
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-32 -> Old local-memory-end

    // New names are stored in new-names and new-names-length stack. When the 'end' of 'let' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) in
      list64:init let dynamic in
        dynamic "creating list dynamic object for 'let'" compiler:check-null

        dynamic new-names-list !64
      end

      new-names-list
      source-name source-file
      macro-names macro-tokens macros-length
      extended-array extended-start extended-end
      log-stream
      collect-let-like-names

      local-memory-end @64 let old-local-memory-end in
        // This loop is separated from the one above, since this loop must run in the reverse order.
        new-names-list list64:length while dup isn-zero do dec peek i in
          1 is-items-available ! if
            LOG:ERR log-stream fputs "Expected a data before 'let' variable, but the stack was empty.\n" log-stream fputs
            EXIT-CODE:ERROR exit drop
          end

          pop-item i new-names-list list64:get let item variable-name in
            variable-name mlength 1 = if variable-name @8 '_' = else false end if
              item stack-item:get-mode STACK-MODE:REAL = if
                output-stream
                "    pop     r15\n" ostrbuf:puts
                drop
              end

            else
              item stack-item:get-mode STACK-MODE:IMM         =
              item stack-item:get-mode STACK-MODE:GLOBAL      = |
              item stack-item:get-mode STACK-MODE:@LOCALCONST = |
              item stack-item:get-mode STACK-MODE:LOCAL       = |
              item stack-item:get-mode STACK-MODE:DATA        = | if

                item stack-item:copy

              else
                local-stack local-stack-length output-stream local-stack.convert-last-items-real

                output-stream
                item                             nasm:convert-real
                "    mov     r15, [local_ptr]\n" ostrbuf:puts
                "    pop     qword [r15"         ostrbuf:puts
                local-memory-end @64 isn-zero if
                  " + "                          ostrbuf:puts
                  local-memory-end @64           ostrbuf:putu
                end
                "]\n"                            ostrbuf:puts
                drop

                item stack-item:get-type STACK-MODE:@LOCALCONST stack-item:create let replace-item in
                  local-memory-end @64 replace-item stack-item:set-arg1

                  replace-item
                end

                local-memory-end @64 8 + local-memory-end !64
              end

              let replace-item in
                variable-name replace-item let-names let-addresses let-vars-length str-map64:set-dstr if
                  LOG:ERR log-stream fputs "'let' variable '" log-stream fputs variable-name dup mlength log-stream fputs "' was already defined before.\n" log-stream fputs

                  // TODO: This does not show the address of the 'let' variable. This should be changed.
                  EXIT-CODE:ERROR exit drop
                end
              end

              local-memory-end @64 8 + local-memory-end !64
            end
          end
        end end drop

        local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

        32 malloc let new-label in
          new-label "creating a label object for 'let'" compiler:check-null

          KEYWORD:LET                      new-label      !64
          0                                new-label  8 + !64
          new-names-list list64:copy-array new-label 16 + !64
          old-local-memory-end             new-label 24 + !64

          new-label labels-list list64:append
        end
      end

      // Deallocate 'new-names-list' but keep the 'let' variable names.
      new-names-list list64:mfree drop
    end

  else token-arg KEYWORD:PEEK = if
    // -------- Keyword 'peek' --------
    // peek <name>* in <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:PEEK
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-32 -> Old peeked-item

    // New names are stored in new-names and new-names-length stack. When the 'end' of 'peek' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) in
      list64:init let dynamic in
        dynamic "creating list dynamic object for 'peek'" compiler:check-null

        dynamic new-names-list !64
      end

      new-names-list
      source-name source-file
      macro-names macro-tokens macros-length
      extended-array extended-start extended-end
      log-stream
      collect-let-like-names

      new-names-list list64:length is-items-available ! if
        LOG:ERR log-stream fputs "Stack does not contain enough items for 'peek'.\n" log-stream fputs
        EXIT-CODE:ERROR exit drop
      end

      peeked-item @64 let old-peeked-item in
        local-stack-length @64 peeked-item !64

        // This loop is separated from the one above, since this loop must run in the reverse order.
        new-names-list list64:length while dup isn-zero do dec peek i in
          local-stack-length @64 new-names-list list64:length - i + let item-index in
            item-index local-stack array64:get let item in
              i new-names-list list64:get let variable-name in
                item stack-item:get-mode STACK-MODE:IMM         =
                item stack-item:get-mode STACK-MODE:GLOBAL      = |
                item stack-item:get-mode STACK-MODE:@LOCALCONST = |
                item stack-item:get-mode STACK-MODE:LOCAL       = |
                item stack-item:get-mode STACK-MODE:DATA        = | if

                  item stack-item:copy

                else
                  item stack-item:get-type STACK-MODE:PEEKED stack-item:create let replace-item in
                    item-index replace-item stack-item:set-arg1
                  replace-item end
                end

                let replace-item in
                  variable-name replace-item let-names let-addresses let-vars-length str-map64:set-dstr if
                    LOG:ERR log-stream fputs "'peek' variable '" log-stream fputs variable-name dup mlength log-stream fputs "' was already defined before.\n" log-stream fputs

                    // TODO: This does not show the address of the 'peek' variable. This should be changed.
                    EXIT-CODE:ERROR exit drop
                  end
                end
              end
            end
          end
        end end drop

        32 malloc let new-label in
          new-label "creating a label object for 'peek'" compiler:check-null

          KEYWORD:PEEK                     new-label      !64
          token-address                    new-label  8 + !64
          new-names-list list64:copy-array new-label 16 + !64
          old-peeked-item                  new-label 24 + !64

          new-label labels-list list64:append
        end
      end

      // Deallocate 'new-names-list' but keep the 'peek' variable names.
      new-names-list list64:mfree drop
    end

  else token-arg KEYWORD:RETURN = if
    // -------- Keyword 'return' --------

    local-stack local-stack-length output-stream local-stack.convert-last-items-real

    output-array output-length
    local-stack local-stack-length
    log-stream
    check-stack-types-types

    output-stream
    "    jmp     .return\n" ostrbuf:puts
    drop

    source-name source-file output-stream
    macro-names macro-tokens macros-length
    local-stack local-stack-length
    peeked-item
    extended-array extended-start extended-end
    labels-list label-id-counter
    local-memory-end
    let-names let-addresses let-vars-length
    output-array output-length
    log-stream
    local-memory-max
    compile-unreachable

  else token-arg KEYWORD:CAST = if
    // -------- Keyword 'cast' --------

    // Get the variable name.
    "a type after 'cast'" false compiler:get-next-token

    let type-type type-address type-arg in
      // The token after 'cast' should be an 'intrinsic type'.
      type-type "after 'cast'" TOKEN-TYPE:INT-TYPE compiler:check-type

      local-stack local-stack-length output-stream local-stack.convert-last-items-real

      // Change the type of the last item.
      local-stack-length @64 dec local-stack array64:get let item in
        type-arg item stack-item:set-type
      end
    end

  else token-arg KEYWORD:SIZEOF = if
    // -------- Keyword 'sizeof' --------
    // sizeof <type>

    // TODO: These are not implemented yet.
    // sizeof <global-variable-name>
    // sizeof <string-immediate>
    // sizeof <local-name>

    "a type after 'sizeof'" true compiler:get-next-token

    let type-type type-address type-arg in
      // The token afrer 'sizeof' should be an 'intrinsic type'.
      type-type "after 'sizeof'" TOKEN-TYPE:INT-TYPE compiler:check-type

      // Push the size of the intrinsic type.
      type-arg get-int-type-sizeof push-int-immediate
    end

  else
    LOG:ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
    EXIT-CODE:ERROR exit drop
  end end end end end end end end end end end end
end false end


proc compile-procedure
  // ptr: source-name file-desc: source-file ptr: output-stream
  ptr file-desc ptr
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: peeked-item
  ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // ptr: output-array int: output-length
  ptr int
  // file-desc: log-stream ->
  file-desc ->
  // local-memory-max: int
  int

  // Compiles a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let
  source-name source-file output-stream
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names macro-tokens macros-length
  local-stack local-stack-length
  peeked-item
  extended-array extended-start extended-end
  output-types-array output-types-length
  log-stream
in

  // label-id-counter allows to create unique IDs for label labels.
  // let-names, let-addresses and let-vars-length create a str_map64:
  // local-memory-end keeps track of the first available-dstr position on the local memory.
  // local-memory-max keeps track of the maximum length of the local memory, to later allocate enough space.
  memory labels-list      sizeof(ptr)      and
         label-id-counter sizeof(int)      and
         let-names        LET-MAX-COUNT    and
         let-addresses    LET-MAX-COUNT    and
         let-vars-length  sizeof(int)      and
         local-memory-end sizeof(int)      and
         local-memory-max sizeof(int)      in

    list64:init let dynamic in
      dynamic "creating a list dynamic object" compiler:check-null

      dynamic labels-list !64
    end

    0 label-id-counter !64
    0 let-vars-length  !64
    0 local-memory-end !64
    0 local-memory-max !64

    while true do
      "end of procedure or procedure definition" true compiler:get-next-token

      let token-type token-address token-arg in
        // -- debug --
        // LOG:INFO log-stream fputs token-type token-arg log-stream fput-token log-stream fputnl

        token-type TOKEN-TYPE:INTEGER = if
          // -------- Constant integer --------

          token-arg push-int-immediate

        else token-type TOKEN-TYPE:STRING = if
          // -------- Strings --------

          data-definitions-list list64:length push-data
          token-arg mlength dec               push-int-immediate

          token-arg data-definitions-list list64:append

        else token-type TOKEN-TYPE:NAME = if
          // -------- Names --------

          token-arg let-names let-addresses let-vars-length str-map64:get-dstr if
            // -------- local variables --------

            let replace-item in
              // TODO: This is a quick work-around for 'peek' keyword. This condition should be removed and rewritten ASAP.

              replace-item stack-item:get-mode STACK-MODE:PEEKED = if
                replace-item stack-item:get-type push-real

                output-stream
                "    push    qword [rsp + " ostrbuf:puts
                local-stack-length @64 replace-item stack-item:get-arg1 - 2 - 8 * ostrbuf:puti
                "]\n" ostrbuf:puts
                drop
              else

                replace-item stack-item:copy push-item
              end
            end

          else drop token-arg global-names-array global-sizes-array globals-length str-map64:get-dstr if
            // -------- global 'memory' variables --------

            let address in
              INT-TYPE:INT STACK-MODE:GLOBAL stack-item:create let item in
                token-arg item stack-item:set-arg1

                item push-item
              end
            end

          else drop token-arg proc-names-array proc-names-array procs-length @64 8 * + str-sorted8:available-dstr if
            // -------- 'proc' calls --------

            let name-address in name-address proc-names-array - let delta in
              delta proc-inputs-array + delta proc-outputs-array + let input-address output-address in
                local-stack local-stack-length output-stream local-stack.convert-last-items-real

                input-address @64 input-address @64 mlength 8 /
                local-stack local-stack-length
                log-stream
                check-sub-stack-types-types

                0 while dup output-address @64 mlength 8 / < do peek i in
                  i output-address @64 array64:get let output in
                    output push-real
                  end
                end inc end drop

                compile-procedure:new-label-id let label-id in
                  output-stream
                  "    xchg    rsp, [call_ptr]\n"              ostrbuf:puts
                  "    push    .label_"                        ostrbuf:puts
                  label-id                                     ostrbuf:putu
                                                               ostrbuf:putnl
                  "    push    qword [local_ptr]\n"            ostrbuf:puts
                  "    add     qword [local_ptr], "            ostrbuf:puts
                  local-memory-end @64                         ostrbuf:putu
                                                               ostrbuf:putnl
                  "    xchg    rsp, [call_ptr]\n"              ostrbuf:puts
                  "    jmp     proc_"                          ostrbuf:puts
                  token-arg                                    nasm:fput-alpha
                                                               ostrbuf:putnl
                  label-id                                     nasm:label
                  drop
                end
              end
            end end

          else drop
            // TODO: Add Levenshtein distance algoritm to show the nearest matchs; which can be definitions, macros, procedures, keywords and intrinsics.

            LOG:ERR log-stream fputs "Name '" log-stream fputs token-arg token-arg mlength log-stream fputs "' is not defined as a local variable or a macro.\n" log-stream fputs
            EXIT-CODE:ERROR exit drop
          end end end

        else token-type TOKEN-TYPE:INTRINSIC = if
          // -------- Intrinsics --------

          source-name source-file output-stream
          local-stack local-stack-length
          peeked-item
          token-type token-address token-arg
          log-stream
          compile-intrinsic

        else token-type TOKEN-TYPE:KEYWORD = if
          // -------- Keywords --------

          source-name source-file output-stream
          macro-names macro-tokens macros-length
          local-stack local-stack-length
          peeked-item
          extended-array extended-start extended-end
          token-type token-address token-arg
          labels-list label-id-counter
          local-memory-end
          let-names let-addresses let-vars-length
          output-types-array output-types-length
          log-stream
          local-memory-max
          compile-keyword if local-memory-max @64 return end

        else
          LOG:ERR log-stream fputs "Unexpected type while expecting a keyword, an intrinsic, a string or an integer, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
          EXIT-CODE:ERROR exit drop
        end end end end end
      end
    end

    // Deallocate 'labels-list'.
    labels-list list64:mfree-deep drop
  end
end 0 end // dummy return


proc compile-file
  // ptr: source-name ptr: output-stream
  ptr ptr
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // include-paths-set
  ptr
  // libraries-set
  ptr
  // file-desc: log-stream
  file-desc ->

  // Compiles a Corth source file.
  // Compilation warning and errors are dumped to log-stream.

  // TODO: Add called-from to improve debugging.
in let
  source-name output-stream
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names macro-tokens macros-length
  include-paths-set
  libraries-set
  log-stream
in
  // Check if the library was included already.
  source-name libraries-set str-set8:add ! if return end

  // Open the source file.
  source-name fopen-r let source-file in
    // Check if the source is opened.
    source-file isn-pos if
      LOG:ERR log-stream fputs "Could not open source file '" log-stream fputs source-name source-name mlength dec log-stream fputs "'\n" log-stream fputs
      EXIT-CODE:ERROR exit drop
    end

    memory extended-array  EXTENDED-MAX-LENGTH and
           extended-start  sizeof(int)         and
           extended-end    sizeof(int)         and
           namespace-name  sizeof(ptr)         in

      // Reset extended-tokens.
      0 extended-start !64
      0 extended-end   !64

      // Reset namespace.
      NULLPTR namespace-name !64

      // Get next token and check if there is one available-dstr.
      while source-name source-file extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream true get-next-token do
        let token-type token-address token-arg in
          // -- debug --
          // LOG:INFO log-stream fputs token-type token-arg log-stream fput-token log-stream fputnl

          token-type "" TOKEN-TYPE:KEYWORD compiler:check-type

          // -------- Global keywords --------
          token-arg KEYWORD:INCLUDE = if
            // -------- Keyword 'include' --------
            // TODO: Create a function to include.
            // TODO: Allow including packages.

            // Get the next token, which should be the include path:
            "a 'name' for include path" false compiler:get-next-token

            let path-token-type path-token-address path-token-arg in
              path-token-type "as path after 'include'" TOKEN-TYPE:STRING compiler:check-type
              memory found sizeof(bool) in
                found !reset

                0 while dup include-paths-set list64:length < do peek i in
                  i include-paths-set list64:get let directory in
                    directory cstr:str path-token-arg path-token-arg mlength path:merge2-cstr let include-path in
                      // Check if the user has the required permissions.
                      memory stats sizeof(stat) in
                        include-path stats stat drop

                        // Check if user has access to the path:
                        include-path ACCESS-MODE:R_OK access is-zero if
                          // Mark as found.
                          found !set

                          stats 24 + @64 S_IFMT && let masked in
                            masked S_IFREG = if
                              // File including, call compile-file on the file.
                              include-path output-stream
                              data-definitions-list
                              global-names-array global-sizes-array globals-length
                              proc-names-array proc-inputs-array proc-outputs-array procs-length
                              macro-names macro-tokens macros-length
                              include-paths-set
                              libraries-set
                              log-stream compile-file

                            else masked S_IFDIR = if
                              // Directory including, should include all sub paths.
                              LOG:TODO log-stream fputs "Including directories is not implemented yet.\n" log-stream fputs
                              EXIT-CODE:ERROR exit drop

                            else
                              LOG:ERR log-stream fputs "Invalid file type, got " log-stream fputs masked log-stream fputo ".\n" log-stream fputs
                              EXIT-CODE:ERROR exit drop
                            end end
                          end

                          break
                        end
                      end

                      // Deallocate 'include-path'.
                      include-path mfree drop
                    end
                  end
                end inc end drop

                // Check if any library is found.
                found @bool ! if
                  LOG:ERR log-stream fputs "Could not find library '" log-stream fputs path-token-arg dup mlength log-stream fputs "'.\n" log-stream fputs
                  EXIT-CODE:ERROR exit drop
                end
              end
            end

          else token-arg KEYWORD:MEMORY = if
            // -------- Keyword 'memory' --------

            memory new-names-list sizeof(ptr) and
                   new-sizes-list sizeof(ptr) in
              list64:init let dynamic in
                dynamic "creating list dynamic object for 'memory'" compiler:check-null

                dynamic new-names-list !64
              end

              list64:init let dynamic in
                dynamic "creating list dynamic object for 'memory'" compiler:check-null

                dynamic new-sizes-list !64
              end

              new-names-list new-sizes-list KEYWORD:END
              source-name source-file
              macro-names macro-tokens macros-length
              extended-array extended-start extended-end
              log-stream
              collect-memory-like-names

              0 while dup new-names-list list64:length < do peek i in
                // Get the full name of the variable.
                namespace-name @64 is-null if
                  i new-names-list list64:get
                else
                  namespace-name @64 i new-names-list list64:get djoin
                end

                let name in
                  // Store the variable.
                  name i new-sizes-list list64:get global-names-array global-sizes-array globals-length str-map64:set-dstr if
                    LOG:ERR log-stream fputs "Global variable '" log-stream fputs name dup mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                    EXIT-CODE:ERROR exit drop
                  end
                end
              end inc end drop

              // Deallocate 'new-names-list' and 'new-sizes-list' but keep the 'memory' variable names.
              new-names-list list64:mfree drop
              new-sizes-list list64:mfree drop
            end

          else token-arg KEYWORD:MACRO = if
            // -------- Keyword 'macro' --------

            // Get the next token, which should be the name of the macro.
            "a 'name' after 'macro'" false compiler:get-next-token

            let macro-name-token-type macro-name-token-address macro-name-token-arg in
              macro-name-token-type "as macro name after 'macro'" TOKEN-TYPE:NAME compiler:check-type

              // macro-tokens and macro-tokens-length are used to create a STACK for macro tokens.
              memory macro-tokens-list sizeof(ptr) in
                list64:init let dynamic in
                  dynamic "creating list dynamic object for 'macro'" compiler:check-null

                  dynamic macro-tokens-list !64
                end

                while true do
                  // Get next tokens, until an 'endmacro' is found.
                  "an 'endmacro' after 'macro'" false compiler:get-next-token

                  let macro-new-token-type macro-new-token-address macro-new-token-arg in
                    // If the token is an 'endmacro' keyword, break the loop.
                    macro-new-token-type TOKEN-TYPE:KEYWORD = if
                      macro-new-token-arg KEYWORD:ENDMACRO = if
                        break
                      end
                    end

                    // Add the token attributes to the macro-tokens-list.
                    macro-new-token-type    macro-tokens-list list64:append
                    macro-new-token-address macro-tokens-list list64:append
                    macro-new-token-arg     macro-tokens-list list64:append
                  end
                end

                // TODO: Check if the macros stack was filled.
                namespace-name @64 is-null if
                  macro-name-token-arg
                else
                  namespace-name @64 macro-name-token-arg djoin
                end let name in
                  name macro-tokens-list list64:copy-array macro-names macro-tokens macros-length str-map64:set-dstr if
                    LOG:ERR log-stream fputs "Macro '" log-stream fputs name dup mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                    EXIT-CODE:ERROR exit drop
                  end
                end

                // Deallocate 'macro-tokens-list'.
                macro-tokens-list list64:mfree drop
              end
            end

          else token-arg KEYWORD:PROC = if
            // -------- 'proc' keyword --------

            // Get the next token, which should be the name of the procedure.
            "a 'name' after 'proc'" false compiler:get-next-token

            let proc-name-token-type proc-name-token-address proc-name-token-arg in
              proc-name-token-type "as procedure name after 'procedure'" TOKEN-TYPE:NAME compiler:check-type

              memory input-list  sizeof(ptr) and
                     output-list sizeof(ptr) in

                // TODO: Check if the dynamic object is NULLPTR or not.
                list64:init input-list !64
                list64:init output-list !64

                // Get the input types.
                while true do
                  // Get the token.
                  "a 'type' after 'proc' for input" true compiler:get-next-token

                  let input-token-type input-token-address input-token-arg in
                    input-token-type TOKEN-TYPE:KEYWORD = if
                      // If the token was a keyword, it must be a 'KEYWORD:RETURN'.
                      input-token-arg "after 'proc' inputs" KEYWORD:RETURNS compiler:check-keyword

                      // If the token was a 'KEYWORD:RETURNS', break the loop.
                      break
                    end

                    // Check if the token is of type-type.
                    input-token-type "after 'proc'" TOKEN-TYPE:INT-TYPE compiler:check-type

                    input-token-arg input-list list64:append
                  end
                end

                // Get the output types.
                while true do
                  // Get the token.
                  "a 'type' after 'proc' for output" true compiler:get-next-token

                  let output-token-type output-token-address output-token-arg in
                    output-token-type TOKEN-TYPE:KEYWORD = if
                      // If the token is a keyword, it must be a 'KEYWORD:IN'.
                      output-token-arg "after 'proc' outputs" KEYWORD:IN compiler:check-keyword

                      // If the token was a 'KEYWORD:IN', break the loop.
                      break
                    end

                    // Check if the token is of type-type.
                    output-token-type "after '->'" TOKEN-TYPE:INT-TYPE compiler:check-type

                    output-token-arg output-list list64:append
                  end
                end

                // Store the full name of the procedure, its input and outputs.
                // Check if the procedure was defined already.
                namespace-name @64 is-null if
                  proc-name-token-arg
                else
                  namespace-name @64 proc-name-token-arg djoin
                end

                let full-name in
                  full-name proc-names-array proc-names-array procs-length @64 8 * + str-sorted8:available-dstr if
                    drop
                    LOG:ERR log-stream fputs "Procedure '" log-stream fputs full-name full-name  mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                    EXIT-CODE:ERROR exit drop
                    return
                  end

                  let name-address in
                    name-address proc-names-array - let delta in
                      proc-inputs-array delta + proc-outputs-array delta + let input-address output-address in
                        // Shift the array to insert the name, input and output.
                        name-address   name-address   8 + procs-length @64 name-address   proc-names-array   - 8 / - memcpy64i
                        input-address  input-address  8 + procs-length @64 input-address  proc-inputs-array  - 8 / - memcpy64i
                        output-address output-address 8 + procs-length @64 output-address proc-outputs-array - 8 / - memcpy64i

                        // Save the name, inputs and outputs of the procedure.
                        full-name               dcopy name-address   !64
                        input-list  list64:copy-array input-address  !64
                        output-list list64:copy-array output-address !64

                        procs-length @inc64
                      end
                    end
                  end

                  // Create the stack for the procedure.
                  memory local-stack        STACK-MAX-ITEMS and
                         local-stack-length sizeof(int)     and
                         peeked-item        sizeof(int)     in

                    0 local-stack-length !64
                    0 peeked-item        !64

                    0 while dup input-list list64:length < do peek i in
                      i input-list list64:get let type in
                        type push-real
                      end
                    end inc end drop

                    output-stream
                    "proc_"        ostrbuf:puts
                    full-name      nasm:fput-alpha
                    ":\n"          ostrbuf:puts
                    drop

                    source-name source-file output-stream
                    data-definitions-list
                    global-names-array global-sizes-array globals-length
                    proc-names-array proc-inputs-array proc-outputs-array procs-length
                    macro-names macro-tokens macros-length
                    local-stack local-stack-length
                    peeked-item
                    extended-array extended-start extended-end
                    output-list list64:to-array
                    log-stream
                    compile-procedure drop

                    output-stream
                    ".return:\n"                        ostrbuf:puts
                    "    xchg    rsp, [call_ptr]\n"     ostrbuf:puts
                    "    pop     qword [local_ptr]\n"   ostrbuf:puts
                    "    pop     rax\n"                 ostrbuf:puts
                    "    xchg    rsp, [call_ptr]\n"     ostrbuf:puts
                    "    jmp     rax\n"                 ostrbuf:puts
                    drop
                  end
                end

                // Deallocate input-list and output-list.
                input-list  list64:mfree drop
                output-list list64:mfree drop
              end
            end

          else token-arg KEYWORD:NAMESPACE = if
            namespace-name @64 isn-null if
              LOG:ERR log-stream fputs "Keyword 'namespace' can not be used inside a namespace.\n" log-stream fputs
              EXIT-CODE:ERROR exit drop
            end

            // Get the next token, which should be the name of the procedure.
            "a 'name' after 'namespace'" false compiler:get-next-token

            let name-type name-address name-arg in
              name-type "as namespace name after 'namespace'" TOKEN-TYPE:NAME compiler:check-type

              ':' name-arg dappend8 namespace-name !64
            end

          else token-arg KEYWORD:ENDNAMESPACE = if
            namespace-name @64 is-null if
              LOG:ERR log-stream fputs "Keyword 'endnamespace' must be used after a 'namespace' keyword.\n" log-stream fputs
              EXIT-CODE:ERROR exit drop
            end

            NULLPTR namespace-name !64

          else
            LOG:ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
            EXIT-CODE:ERROR exit drop
          end end end end end end
        end
      end drop drop drop
    end

    source-file fclose drop
  end
end end


proc compile-nasm
  // ptr: source-name ptr: output-name ptr: include-paths-set file-desc: log-stream ->
  ptr ptr ptr file-desc ->
in let source-name output-name include-paths-set log-stream in
  // Create the output file.
  output-name 0o777 creat dup isn-pos if
    LOG:ERR log-stream fputs "Could not create output file '" log-stream fputs output-name output-name cstr:len log-stream fputs "'.\n" log-stream fputs
    EXIT-CODE:ERROR exit drop
  end

  let output-file in
    // Check if the file is opened successfully.
    output-file isn-pos if
      LOG:ERR log-stream fputs "Could not open output file '" log-stream fputs output-name output-name cstr:len log-stream fputs "'.\n" log-stream fputs
      EXIT-CODE:ERROR exit drop
    end

    memory output-stream OUTPUT-STREAM-SIZE in
      output-file OUTPUT-STREAM-SIZE output-stream ostrbuf:init

      output-stream
      "segment .text\n"                                   ostrbuf:puts
      "global _start\n"                                   ostrbuf:puts
      "_start:\n"                                         ostrbuf:puts
      "    mov     qword [call_ptr], call_stack\n"        ostrbuf:puts
      "    add     qword [call_ptr], 0x4000\n"            ostrbuf:puts
      "    mov     qword [local_ptr], local_memory\n"     ostrbuf:puts
      "    xchg    rsp, [call_ptr]\n"                     ostrbuf:puts
      "    push    corth_endofprogram\n"                  ostrbuf:puts
      "    push    qword [local_ptr]\n"                   ostrbuf:puts
      "    xchg    rsp, [call_ptr]\n"                     ostrbuf:puts
      "    mov     rax, [rsp]\n"                          ostrbuf:puts
      "    mov     rbx, rsp\n"                            ostrbuf:puts
      "    add     rbx, 8\n"                              ostrbuf:puts
      "    mov     rdx, rax\n"                            ostrbuf:puts
      "    shl     rdx, 3\n"                              ostrbuf:puts
      "    sub     rsp, rdx\n"                            ostrbuf:puts
      "    push    rax\n"                                 ostrbuf:puts
      "    push    rbx\n"                                 ostrbuf:puts
      "    jmp     proc_main\n"                           ostrbuf:puts
      "corth_endofprogram:\n"                             ostrbuf:puts
      "    mov     rax, 60\n"                             ostrbuf:puts
      "    pop     rdi\n"                                 ostrbuf:puts
      "    syscall\n"                                     ostrbuf:puts
      drop

      memory global-names-array     GLOBALS-MAX-COUNT and
             global-sizes-array     GLOBALS-MAX-COUNT and
             globals-length         sizeof(int)       and

             proc-names-array       PROCS-MAX-COUNT   and
             proc-inputs-array      PROCS-MAX-COUNT   and
             proc-outputs-array     PROCS-MAX-COUNT   and
             procs-length           sizeof(int)       and

             macro-names            MACROS-MAX-COUNT  and
             macro-tokens           MACROS-MAX-COUNT  and
             macros-length          sizeof(int)       and

             data-definitions-list  sizeof(ptr)       and

             libraries-set          sizeof(ptr)       in

        0 globals-length   !64
        0 procs-length     !64
        0 macros-length    !64

        list64:init let dynamic in
          dynamic "creating a list dynamic object for data-definitions-list" compiler:check-null

          dynamic data-definitions-list !64
        end

        list64:init let dynamic in
          dynamic "creating a list dynamic object for libraries-set.\n" compiler:check-null

          dynamic libraries-set !64
        end

        source-name output-stream
        data-definitions-list
        global-names-array global-sizes-array globals-length
        proc-names-array proc-inputs-array proc-outputs-array procs-length
        macro-names macro-tokens macros-length
        include-paths-set
        libraries-set
        log-stream
        compile-file

        // Print the data labels.
        output-stream
        "segment .data\n"       ostrbuf:puts
        0 while dup data-definitions-list list64:length < do let i in
          "    data_"           ostrbuf:puts
          i                     ostrbuf:putu
          ": db "               ostrbuf:puts

          i data-definitions-list list64:get let data in
            0 while dup data mlength < do let j in
              j data + @8       ostrbuf:putu
              ", "              ostrbuf:puts
            j end inc end drop
          end

                                ostrbuf:putnl
        i end inc end drop

        // Print the global memory labels.
        "segment .bss\n"                                    ostrbuf:puts
        "    local_memory:   resb 67108864\n"               ostrbuf:puts
        "    local_ptr:      resq 1\n"                      ostrbuf:puts
        "    call_stack:     resb 67108864\n"               ostrbuf:puts
        "    call_ptr:       resq 1\n"                      ostrbuf:puts

        0 while dup globals-length @64 < do let i in
          i global-names-array array64:get i global-sizes-array array64:get let variable-name variable-size in
            "    global_"                    ostrbuf:puts
            i global-names-array array64:get nasm:fput-alpha
            ": resb "                        ostrbuf:puts
            variable-size                    ostrbuf:putu
                                             ostrbuf:putnl

            // Deallocate the name of the variable.
            variable-name mfree drop
          end
        i end inc end drop

        // Flush the remaining in the output-stream.
        output-stream ostrbuf:flush
        drop

        // Deallocate space allocated for procedures.
        0 while dup procs-length @64 < do peek i in
          i proc-names-array   array64:get mfree drop
          i proc-inputs-array  array64:get mfree drop
          i proc-outputs-array array64:get mfree drop
        end inc end drop

        // Deallocate space allocated for macros.
        0 while dup macros-length @64 < do peek i in
          i macro-names array64:get mfree drop

          i macro-tokens array64:get let tokens in
            0 while dup tokens mlength 24 / < do peek j in
              j tokens array64:get j inc tokens array64:get j 2 + tokens array64:get let token-type token-address token-arg in
                // Deallocate 'token-arg' if the token is either a 'name' or a 'string'.
                token-type TOKEN-TYPE:NAME = token-type TOKEN-TYPE:STRING = | if
                  token-arg mfree drop
                end
              end
            end 3 + end drop

            // Deallocate 'tokens'.
            tokens mfree drop
          end
        end inc end drop

        // Deallocate the space allocated for libraries-set.
        libraries-set list64:mfree-deep drop

        // Deallocate the space allocated for data-definitions-list
        data-definitions-list list64:mfree-deep drop
      end
    end

    output-file fclose drop
  end
end end
