include "linux_x86/sys.corth"
include "linux_x86/io/output.corth"
include "linux_x86/io/input.corth"
include "linux_x86/io/ostrbuf.corth"

include "core/stack.corth"
include "core/arithmetic.corth"
include "core/memory.corth"

include "dynamic/malloc.corth"
include "dynamic/utils.corth"

macro string-builder.RESIZING 64 endmacro

include "linux_x86/path.corth"

include "collections/list64.corth"
include "collections/deque64.corth"
include "collections/stack64.corth"
include "collections/str_map64.corth"
include "collections/str_set8.corth"

include "lexer.corth"
include "debug.corth"
include "enums.corth"
include "local_stack.corth"


// bool: extend-macros -> int: token-type ptr: address [int|ptr]: arg
// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compiler:get-next-token let extend-macros in
  // Calls get-next-token and checks if a token is available-dstr. If there are no tokens, prints an error message.
  source-name source-file
  extended-array extended-start extended-end
  macro-names macro-tokens macros-length
  extend-macros get-next-token
end endmacro


// bool: extend-macros -> int: token-type ptr: address [int|ptr]: arg ptr: log-item
// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compiler:expect-next-token let extend-macros in
  // Calls get-next-token and checks if a token is available-dstr. If there are no tokens, prints an error message.
  source-name source-file
  extended-array extended-start extended-end
  macro-names macro-tokens macros-length
  extend-macros expect-next-token
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure:new-label-id
  label-id-counter @64 dup inc label-id-counter !64
endmacro


proc compare-stack-types
  // ptr: old-stack ptr: local-stack ptr: local-stack-length -> ptr: log-item
  ptr ptr ptr -> ptr
  // Checks if the local stack IS EQUAL TO the correct stack item types.
  // NOTE: old-stack must be an array of stack items.
in let old-stack local-stack local-stack-length in
  local-stack-length @64 8 * old-stack mlength != if LOG-TYPE:STACK-SIZE-NOT-EQ generate-log0 return end

  0 while dup local-stack-length @64 < do let i in
    i old-stack array64:get stack-item:get-type i local-stack array64:get stack-item:get-type != if LOG-TYPE:STACK-NOT-MATCH generate-log0 return end
  i end inc end drop
end NULLPTR end


proc compare-stack-types-types
  // ptr: types-array int: types-length ptr: local-stack ptr: local-stack-length -> ptr: log-item
  ptr int ptr ptr -> ptr
  // Checks if the local stack IS EQUAL TO the correct stack item types.
  // NOTE: types-array and types-length must be an array of stack item types.
in let
  types-array types-length
  local-stack local-stack-length
in
  types-length local-stack-length @64 != if LOG-TYPE:STACK-SIZE-NOT-EQ generate-log0 return end

  0 while dup types-length < do let i in
    i local-stack array64:get stack-item:get-type i types-array array64:get != if LOG-TYPE:STACK-NOT-MATCH generate-log0 return end
  i end inc end drop
end NULLPTR end


proc compare-sub-stack-types-types
  // ptr: types-array int: types-length ptr: local-stack ptr: local-stack-length -> ptr: log-item
  ptr int ptr ptr -> ptr
  // Checks if the local stack ENDS WITH the correct stack item types.
  // NOTE: types-array and types-length must be an array of stack item types.
in let
  types-array types-length
  local-stack local-stack-length
in
  types-length local-stack-length @64 > if LOG-TYPE:NOT-ENOUGH-ITEMS generate-log0 return end

  types-length while dup isn-zero do dec let i in
    pop-item let item in
      i types-array array64:get let expected in
        item stack-item:get-type expected != if LOG-TYPE:STACK-NOT-MATCH generate-log0 return end
      end
    end
  i end end drop
end NULLPTR end


// int: int-type -> ptr: item ptr: log-item
// NOTE: Must be used inside the bodies of procedures that return only the log-item and nothing else.
// NOTE: Stack must be empty.
macro compiler:try-pop let _type_ in
  local-stack-length @64 is-zero if
    LOG-TYPE:NOT-ENOUGH-ITEMS generate-log0 return
  end

  local-stack-length @64 peeked-item @64 = if
    LOG-TYPE:ACCESSED-PEEKED generate-log0 return
  end

  pop-item dup stack-item:get-type _type_ != if drop
    LOG-TYPE:INV-ITEM-TYPE generate-log0 return
  end
end endmacro


proc add-intrinsic
  // ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream -> ptr: log-item
  ptr ptr ptr ptr -> ptr
in let local-stack local-stack-length peeked-item output-stream in
  INT-TYPE:INT compiler:try-pop let item2 in
  INT-TYPE:INT compiler:try-pop let item1 in
    item1 stack-item:get-mode STACK-MODE:IMM = if
      item2 stack-item:get-mode STACK-MODE:IMM = if
        item1 stack-item:get-arg1 item2 stack-item:get-arg1 + push-int-immediate

      else item2 stack-item:get-mode STACK-MODE:LOCAL = if
        item1 stack-item:get-arg1 item2 stack-item:get-arg1 + push-int-local

      else
        INT-TYPE:INT push-real

        output-stream
        item2                     nasm:push
        item1 stack-item:get-arg1 nasm:add-immediate
        drop
      end end

    else item2 stack-item:get-mode STACK-MODE:IMM = if
      item1 stack-item:get-mode STACK-MODE:LOCAL = if
        item1 stack-item:get-arg1 item2 stack-item:get-arg1 + push-int-local

      else
        INT-TYPE:INT push-real

        output-stream
        item1                     nasm:push
        item2 stack-item:get-arg1 nasm:add-immediate
        drop
      end

    else
      INT-TYPE:INT push-real

      output-stream
      item2 register:RAX         nasm:mov-reg-item
      item1                      nasm:push
      "    add     [rsp], rax\n" ostrbuf:puts
      drop
    end end

    item1 stack-item:mfree
    item2 stack-item:mfree
  end end
NULLPTR end end


proc get-register-name
  // int: intrinsic -> int: register-id
  int -> ptr
in let intrinsic in
       intrinsic INTRINSIC:STORE8  = if register:AL
  else intrinsic INTRINSIC:STORE16 = if register:AX
  else intrinsic INTRINSIC:STORE32 = if register:EAX
  else intrinsic INTRINSIC:STORE64 = if register:RAX
  else intrinsic INTRINSIC:LOAD8   = if register:AL
  else intrinsic INTRINSIC:LOAD16  = if register:AX
  else intrinsic INTRINSIC:LOAD32  = if register:EAX
  else intrinsic INTRINSIC:LOAD64  = if register:RAX
  else                                  register:UNKNOWN
  end end end end end end end end
end end


proc load-intrinsic
  // int: intrinsic ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream -> ptr: log-item
  int ptr ptr ptr ptr -> ptr
  // NOTE: Register is one of 'al', 'ax', 'eax', 'rax'.
in let intrinsic local-stack local-stack-length peeked-item output-stream in
  INT-TYPE:INT compiler:try-pop let item in
    item stack-item:get-mode STACK-MODE:LOCAL = if
      intrinsic INTRINSIC:LOAD64 = if item stack-item:get-arg1 push-@64local NULLPTR return end
      intrinsic INTRINSIC:LOAD8  = if item stack-item:get-arg1 push-@8local  NULLPTR return end
    end

    item stack-item:get-mode STACK-MODE:GLOBAL = if
      intrinsic INTRINSIC:LOAD64 = if item stack-item:get-arg1 push-@64global NULLPTR return end
      intrinsic INTRINSIC:LOAD8  = if item stack-item:get-arg1 push-@8global  NULLPTR return end
    end

    INT-TYPE:INT push-real

    output-stream
    item register:RBX             nasm:mov-reg-item

    intrinsic INTRINSIC:LOAD64 = if
      "    push    qword [rbx]\n" ostrbuf:puts

    else
      register:RAX                nasm:mov-reg-zero
      "    mov     "              ostrbuf:puts
      intrinsic get-register-name nasm:put-register
      ", [rbx]\n"                 ostrbuf:puts
      register:RAX                nasm:push-register
    end
    drop
  end
NULLPTR end end


proc store-intrinsic-sub
  // ptr: value-item ptr: address-item int: address-item-length int: intrinsic ptr: output-stream -> ptr: log-item
  ptr ptr int int ptr -> ptr
in let value-item address-item address-item-length intrinsic output-stream in
  output-stream

  value-item stack-item:get-mode STACK-MODE:REAL = if
    intrinsic INTRINSIC:STORE64 = if
      "    pop     qword ["            ostrbuf:puts
      address-item address-item-length ostrbuf:puts
      "]\n"                            ostrbuf:puts
      drop NULLPTR return
    end
  end

  value-item stack-item:get-mode STACK-MODE:IMM = if
    intrinsic INTRINSIC:STORE64 = if
      value-item stack-item:get-arg1 nasm:is-signed-dword if
        "    mov     qword ["            ostrbuf:puts
        address-item address-item-length ostrbuf:puts
        "], "                            ostrbuf:puts
        value-item stack-item:get-arg1   ostrbuf:puti
                                         ostrbuf:putnl

        drop NULLPTR return
      end

    else intrinsic INTRINSIC:STORE8 = if
      "    mov     byte ["             ostrbuf:puts
      address-item address-item-length ostrbuf:puts
      "], "                            ostrbuf:puts
      value-item stack-item:get-arg1   ostrbuf:puti
                                       ostrbuf:putnl

      drop NULLPTR return
    end end
  end

  value-item stack-item:get-mode STACK-MODE:GLOBAL = if
    intrinsic INTRINSIC:STORE64 != if
      drop LOG-TYPE:MEM-SIZE-MISMATCH generate-log0 return
    end

    "    mov     qword ["            ostrbuf:puts
    address-item address-item-length ostrbuf:puts
    "], global_"                     ostrbuf:puts
    value-item stack-item:get-arg1   nasm:put-alpha
                                     ostrbuf:putnl
    drop NULLPTR return
  end

  value-item stack-item:get-mode STACK-MODE:DATA = if
    intrinsic INTRINSIC:STORE64 != if
      drop LOG-TYPE:MEM-SIZE-MISMATCH generate-log0 return
    end

    "    mov     qword [" ostrbuf:puts
    address-item address-item-length ostrbuf:puts
    "], data_"                       ostrbuf:puts
    value-item stack-item:get-arg1   ostrbuf:putu
                                     ostrbuf:putnl
    drop NULLPTR return
  end

  value-item register:RAX          nasm:mov-reg-item
  "    mov     ["                  ostrbuf:puts
  address-item address-item-length ostrbuf:puts
  "], "                            ostrbuf:puts
  intrinsic get-register-name      nasm:put-register
                                   ostrbuf:putnl

  drop
NULLPTR end end



proc store-intrinsic
  // ptr: int: intrinsic ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream -> ptr: log-item
  int ptr ptr ptr ptr -> ptr
  // NOTE: Register is one of 'bl', 'bx', 'ebx', 'rbx'.
in let intrinsic local-stack local-stack-length peeked-item output-stream in
  INT-TYPE:INT compiler:try-pop let address-item in
  INT-TYPE:INT compiler:try-pop let value-item in
    address-item stack-item:get-mode STACK-MODE:IMM = if
      LOG-TYPE:INV-ITEM-MODE generate-log0 return
    end

    local-stack local-stack-length output-stream local-stack.convert-@local-real

    output-stream
    address-item stack-item:get-mode STACK-MODE:LOCAL = if
      // TODO: Fix this disgusting hack.
      "    mov     rbx, [local_ptr]\n" ostrbuf:puts

      memory buffer 20 in
        buffer address-item stack-item:get-arg1 intconvud let buffer-start in
          "rbx + " buffer-start buffer 20 + buffer-start - to-dynamic8-join
        end
      end

      let object in
        value-item object object mlength intrinsic output-stream store-intrinsic-sub let log-item in
          log-item isn-null if drop log-item return end
        end
        object mfree drop
      end

    else address-item stack-item:get-mode STACK-MODE:GLOBAL = if
      address-item stack-item:get-arg1 nasm:global-label let label in
        value-item label label mlength intrinsic output-stream store-intrinsic-sub let log-item in
          log-item isn-null if drop log-item return end
        end
        label mfree drop
      end

    else
      address-item register:RBX nasm:mov-reg-item
      value-item register:RBX register:get-register-name intrinsic output-stream store-intrinsic-sub let log-item in
        log-item isn-null if drop log-item return end
      end
    end end
    drop
  end end
NULLPTR end end


proc get-log2
  int -> int
  // Returns 0-63 for whole powers of 2, <0 otherwise.
in let x in
       x           1 = if 0
  else x       is-zero if MIN-INT
  else x 2  % isn-zero if MIN-INT
  else                    x 2 / get-log2 inc
  end end end
end end


proc multiply-immediate-any
  // bool: upper int: immediate ptr: item ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream ->
  bool int ptr ptr ptr ptr ptr ->
in let upper immediate item local-stack local-stack-length peeked-item output-stream in
  immediate get-log2 let log2 in
    INT-TYPE:INT push-real

    // TODO: Multiplication by numbers that are not whole powers of 2 without using the 'mul' instruction is possible.
    output-stream
    log2 is-neg if
      item      register:RAX        nasm:mov-reg-item
      immediate register:RBX        nasm:mov-reg-immediate

      "    imul    rbx\n"           ostrbuf:puts

      upper if register:RDX else register:RAX end nasm:push-register

    else
      item                          nasm:push

      upper if
        "    sar     qword [rsp], " ostrbuf:puts
        64 log2 -                   ostrbuf:putu

      else
        "    sal     qword [rsp], " ostrbuf:puts
        log2                        ostrbuf:putu
      end

                                    ostrbuf:putnl
    end
    drop
  end
end end


proc multiply-intrinsic
  // bool: upper ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream -> ptr: log-item
  bool ptr ptr ptr ptr -> ptr
in let upper local-stack local-stack-length peeked-item output-stream in
  INT-TYPE:INT compiler:try-pop let item2 in
  INT-TYPE:INT compiler:try-pop let item1 in
    item1 stack-item:get-mode STACK-MODE:IMM = if
      item2 stack-item:get-mode STACK-MODE:IMM = if
        item1 stack-item:get-arg1 item2 stack-item:get-arg1

        upper if *2 else * end

        push-int-immediate
      else
        upper item1 stack-item:get-arg1 item2 local-stack local-stack-length peeked-item output-stream multiply-immediate-any
      end

    else
      item2 stack-item:get-mode STACK-MODE:IMM = if
        upper item2 stack-item:get-arg1 item1 local-stack local-stack-length peeked-item output-stream multiply-immediate-any
      else
        INT-TYPE:INT push-real

        output-stream
        item2 register:RBX  nasm:mov-reg-item
        item1 register:RAX  nasm:mov-reg-item
        "    imul    rbx\n" ostrbuf:puts
        upper if register:RDX else register:RAX end nasm:push-register
        drop
      end
    end

    item1 stack-item:mfree
    item2 stack-item:mfree
  end end
NULLPTR end end


proc bitwise-and-any-immediate
  // ptr: item int: immediate ptr: local-stack ptr: local-stack-length ptr: output-stream ->
  ptr int ptr ptr ptr ->
in let item immediate local-stack local-stack-length output-stream in
  output-stream
  item                        nasm:push
  "    and     qword [rsp], " ostrbuf:puts
  immediate                   ostrbuf:putu
                              ostrbuf:putnl
  drop
end end


proc divide-intrinsic
  // bool: modulo ptr: local-stack ptr: local-stack-length ptr: peeked-item ptr: output-stream -> ptr: log-item
  bool ptr ptr ptr ptr -> ptr
in let modulo local-stack local-stack-length peeked-item output-stream in
  INT-TYPE:INT compiler:try-pop let item2 in
  INT-TYPE:INT compiler:try-pop let item1 in
    output-stream
    item2 stack-item:get-mode STACK-MODE:IMM = if
      item2 stack-item:get-arg1 get-log2 let log2 in
        INT-TYPE:INT push-real

        // TODO: Division/modulo by numbers that are not whole powers of 2 without using the 'div' instruction is possible.
        log2 isn-neg modulo & if
          item1 item2 stack-item:get-arg1 dec local-stack local-stack-length output-stream bitwise-and-any-immediate

        else
          item2 register:RBX  nasm:mov-reg-item
          item1 register:RAX  nasm:mov-reg-item
                register:RDX  nasm:mov-reg-zero
          "    idiv    rbx\n" ostrbuf:puts
          modulo if register:RDX else register:RAX end nasm:push-register
        end
      end

    else
      INT-TYPE:INT push-real

      item2 register:RBX  nasm:mov-reg-item
      item1 register:RAX  nasm:mov-reg-item
            register:RDX  nasm:mov-reg-zero
      "    idiv    rbx\n" ostrbuf:puts
      modulo if register:RDX else register:RAX end nasm:push-register
    end

    item1 stack-item:mfree
    item2 stack-item:mfree
  end end

  drop
NULLPTR end end


proc compile-intrinsic
  // ptr: source-name file-desc: source-file ptr: output-stream
  ptr file-desc ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length ptr: peeked-item
  ptr ptr ptr
  // int: token-type [int|ptr]: token-arg ->
  int int ->
  // ptr: log-item
  ptr

  // Compiles an intrinsic in a Corth procedure.
in let
  source-name source-file output-stream
  procedure-name procedure-address
  local-stack local-stack-length peeked-item
  token-type token-arg
in
  token-arg INTRINSIC:ADD = if
    local-stack local-stack-length peeked-item output-stream add-intrinsic dup isn-null if return end drop

  else token-arg INTRINSIC:SUB = if
    // -------- Intrinsic '-' --------
    INT-TYPE:INT compiler:try-pop let item2 in
    INT-TYPE:INT compiler:try-pop let item1 in
      INT-TYPE:INT push-real

      output-stream
      item2 stack-item:get-mode STACK-MODE:IMM = if
        item1                     nasm:push
        item2 stack-item:get-arg1 neg nasm:add-immediate

      else
        item2 register:RAX         nasm:mov-reg-item
        item1                      nasm:push
        "    sub     [rsp], rax\n" ostrbuf:puts
      end
      drop

      item1 stack-item:mfree
      item2 stack-item:mfree
    end end

  else token-arg INTRINSIC:BOR = if
    // -------- Intrinsic '||' --------
    INT-TYPE:INT compiler:try-pop let item2 in
    INT-TYPE:INT compiler:try-pop let item1 in
      INT-TYPE:INT push-real

      output-stream
      item2 register:RAX         nasm:mov-reg-item
      item1                      nasm:push
      "    or      [rsp], rax\n" ostrbuf:puts
      drop

      item1 stack-item:mfree
      item2 stack-item:mfree
    end end

  else token-arg INTRINSIC:BAND = if
    // -------- Intrinsic '&&' --------
    INT-TYPE:INT compiler:try-pop let item2 in
    INT-TYPE:INT compiler:try-pop let item1 in
      INT-TYPE:INT push-real

      output-stream
      item2 register:RAX         nasm:mov-reg-item
      item1                      nasm:push
      "    and     [rsp], rax\n" ostrbuf:puts
      drop

      item1 stack-item:mfree
      item2 stack-item:mfree
    end end

  else token-arg INTRINSIC:BXOR = if
    // -------- Intrinsic '^^' --------
    INT-TYPE:INT compiler:try-pop let item2 in
    INT-TYPE:INT compiler:try-pop let item1 in
      INT-TYPE:INT push-real

      output-stream
      item2 register:RAX         nasm:mov-reg-item
      item1                      nasm:push
      "    xor     [rsp], rax\n" ostrbuf:puts
      drop

      item1 stack-item:mfree
      item2 stack-item:mfree
    end end

  else token-arg INTRINSIC:BNOT = if
    // -------- Intrinsic '!!' --------
    INT-TYPE:INT compiler:try-pop let item in
      item stack-item:get-mode STACK-MODE:IMM = if
        item stack-item:get-arg1 !! push-int-immediate

      else
        INT-TYPE:INT push-real

        output-stream
        item                        nasm:push
        "    not     qword [rsp]\n" ostrbuf:puts
        drop
      end

      item stack-item:mfree
    end

  else token-arg INTRINSIC:MUL     = if
    false local-stack local-stack-length peeked-item output-stream multiply-intrinsic dup isn-null if
      return
    end drop

  else token-arg INTRINSIC:MUL2    = if
    true  local-stack local-stack-length peeked-item output-stream multiply-intrinsic dup isn-null if
      return
    end drop

  else token-arg INTRINSIC:DIV     = if
    false local-stack local-stack-length peeked-item output-stream divide-intrinsic dup isn-null if
      return
    end drop

  else token-arg INTRINSIC:MOD     = if
    true  local-stack local-stack-length peeked-item output-stream divide-intrinsic dup isn-null if
      return
    end drop

  else token-arg INTRINSIC:LOAD8   =
       token-arg INTRINSIC:LOAD16  = |
       token-arg INTRINSIC:LOAD32  = |
       token-arg INTRINSIC:LOAD64  = | if
    token-arg local-stack local-stack-length peeked-item output-stream load-intrinsic dup isn-null if
      return
    end drop

  else token-arg INTRINSIC:STORE8  =
       token-arg INTRINSIC:STORE16 = |
       token-arg INTRINSIC:STORE32 = |
       token-arg INTRINSIC:STORE64 = | if
    token-arg local-stack local-stack-length peeked-item output-stream store-intrinsic dup isn-null if
      return
    end drop

  else token-arg INTRINSIC:SYSCALL0 = if
    // -------- Intrinsic 'syscall0' --------

    INT-TYPE:INT compiler:try-pop let op-item in
      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      op-item   stack-item:mfree
    end

  else token-arg INTRINSIC:SYSCALL1 = if
    // -------- Intrinsic 'syscall1' --------

    INT-TYPE:INT compiler:try-pop let op-item in
    INT-TYPE:INT compiler:try-pop let arg-item1 in
      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      op-item   stack-item:mfree
    end end

  else token-arg INTRINSIC:SYSCALL2 = if
    // -------- Intrinsic 'syscall2' --------

    INT-TYPE:INT compiler:try-pop let op-item in
    INT-TYPE:INT compiler:try-pop let arg-item2 in
    INT-TYPE:INT compiler:try-pop let arg-item1 in
      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      op-item   stack-item:mfree
    end end end

  else token-arg INTRINSIC:SYSCALL3 = if
    // -------- Intrinsic 'syscall3' --------

    INT-TYPE:INT compiler:try-pop let op-item in
    INT-TYPE:INT compiler:try-pop let arg-item3 in
    INT-TYPE:INT compiler:try-pop let arg-item2 in
    INT-TYPE:INT compiler:try-pop let arg-item1 in
      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item3 register:RDX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      arg-item3 stack-item:mfree
      op-item   stack-item:mfree
    end end end end

  else token-arg INTRINSIC:SYSCALL4 = if
    // -------- Intrinsic 'syscall4' --------

    INT-TYPE:INT compiler:try-pop let op-item in
    INT-TYPE:INT compiler:try-pop let arg-item4 in
    INT-TYPE:INT compiler:try-pop let arg-item3 in
    INT-TYPE:INT compiler:try-pop let arg-item2 in
    INT-TYPE:INT compiler:try-pop let arg-item1 in
      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item4 register:R10 nasm:mov-reg-item
      arg-item3 register:RDX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      arg-item3 stack-item:mfree
      arg-item4 stack-item:mfree
      op-item   stack-item:mfree
    end end end end end

  else token-arg INTRINSIC:SYSCALL5 = if
    // -------- Intrinsic 'syscall5' --------

    INT-TYPE:INT compiler:try-pop let op-item in
    INT-TYPE:INT compiler:try-pop let arg-item5 in
    INT-TYPE:INT compiler:try-pop let arg-item4 in
    INT-TYPE:INT compiler:try-pop let arg-item3 in
    INT-TYPE:INT compiler:try-pop let arg-item2 in
    INT-TYPE:INT compiler:try-pop let arg-item1 in
      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item5 register:R8  nasm:mov-reg-item
      arg-item4 register:R10 nasm:mov-reg-item
      arg-item3 register:RDX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      arg-item3 stack-item:mfree
      arg-item4 stack-item:mfree
      arg-item5 stack-item:mfree
      op-item   stack-item:mfree
    end end end end end end

  else
    token-arg INTRINSIC:SYSCALL6 != if
      LOG-TYPE:UNKNOWN-INTRINSIC generate-log0 return
    end

    // -------- Intrinsic 'syscall6' --------

    INT-TYPE:INT compiler:try-pop let op-item in
    INT-TYPE:INT compiler:try-pop let arg-item6 in
    INT-TYPE:INT compiler:try-pop let arg-item5 in
    INT-TYPE:INT compiler:try-pop let arg-item4 in
    INT-TYPE:INT compiler:try-pop let arg-item3 in
    INT-TYPE:INT compiler:try-pop let arg-item2 in
    INT-TYPE:INT compiler:try-pop let arg-item1 in
      INT-TYPE:INT push-real

      output-stream
      op-item   register:RAX nasm:mov-reg-item
      arg-item6 register:R9  nasm:mov-reg-item
      arg-item5 register:R8  nasm:mov-reg-item
      arg-item4 register:R10 nasm:mov-reg-item
      arg-item3 register:RDX nasm:mov-reg-item
      arg-item2 register:RSI nasm:mov-reg-item
      arg-item1 register:RDI nasm:mov-reg-item
                             nasm:syscall
      register:RAX           nasm:push-register
      drop

      arg-item1 stack-item:mfree
      arg-item2 stack-item:mfree
      arg-item3 stack-item:mfree
      arg-item4 stack-item:mfree
      arg-item5 stack-item:mfree
      arg-item6 stack-item:mfree
      op-item   stack-item:mfree
    end end end end end end end
  end end end end end end end end end end end end end end end end end end
NULLPTR end end


proc collect-let-like-names
  // ptr: new-names-list
  ptr
  // ptr: source-name file-desc: source-file
  ptr file-desc
  // ptr: macro-names ptr: macro-tokens ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  ->
  // ptr: log-item
  ptr
  // Fills new-names-list until an 'in' keyword is found.
in let
  new-names-list
  source-name source-file
  macro-names macro-tokens macros-length
  procedure-name procedure-address
  extended-array extended-start extended-end
in
  // Get the names of the 'let' variables.
  while true do
    // Get the name of the variable.
    false compiler:expect-next-token let new-token-type new-token-address new-token-arg log-item in
      log-item isn-null if log-item return end

      new-token-type TOKEN-TYPE:KEYWORD = if
        // If token is a keyword, it must be a 'in' keyword.
        new-token-arg KEYWORD:IN != if
          LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
        end

        // Deallocate 'new-token-address'.
        new-token-address mfree drop

        // If the token is a 'in' keyword, break the loop.
        break
      end

      // Check the type of the token.
      new-token-type TOKEN-TYPE:NAME != if
        LOG-TYPE:UNXPCT-TYPE generate-log0 return
      end

      // TODO: Change the way that the variables are stored, so that we can also store their addresses.
      new-token-arg new-names-list list64:append

      // Deallocate 'new-token-address'.
      new-token-address mfree drop
    end
  end
NULLPTR end end


proc collect-memory-like-names
  // ptr: new-names-list ptr: new-sizes-list int: terminator-keyword
  ptr ptr int
  // ptr: source-name file-desc: source-file
  ptr file-desc
  // ptr: macro-names ptr: macro-tokens ptr: macros-length
  ptr ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  ->
  // ptr: log-item
  ptr
  // Fills new-names-list and new-sizes-list until a terminator keyword is found.
in let
  new-names-list new-sizes-list terminator-keyword
  source-name source-file
  macro-names macro-tokens macros-length
  extended-array extended-start extended-end
in
  while
    // Get the variable name.

    false compiler:expect-next-token let log-item in log-item isn-null if
      drop drop drop log-item return end
    end

    let memory-name-type memory-name-address memory-name-arg in
      memory-name-type TOKEN-TYPE:NAME != if
        LOG-TYPE:UNXPCT-TYPE generate-log0 return
      end

      // Get the variable size.
      true compiler:expect-next-token let log-item in log-item isn-null if
        drop drop drop log-item return
      end end

      let memory-size-type memory-size-address memory-size-arg in
        // The token after variable name should be an 'integer'.
        memory-size-type TOKEN-TYPE:INTEGER != if
          LOG-TYPE:UNXPCT-TYPE generate-log0 return
        end

        true compiler:expect-next-token let log-item in log-item isn-null if
          drop drop drop log-item return
        end end

        let memory-end-type memory-end-address memory-end-arg in
          // The token after variable size should be a 'keyword'.
          memory-end-type TOKEN-TYPE:KEYWORD != if
            LOG-TYPE:UNXPCT-TYPE generate-log0 return
          end

          memory-name-arg new-names-list list64:append
          memory-size-arg new-sizes-list list64:append

          // Check if the keyword is not the terminator keyword.
          memory-end-arg terminator-keyword != dup if
            memory-end-arg KEYWORD:AND != if
              // If keyword is not the terminator, check if it is 'and'.
              drop LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
            end
          end

          // Deallocate 'memory-end-address'.
          memory-end-address mfree drop
        end

        // Deallocate 'memory-size-address'.
        memory-size-address mfree drop
      end

      // Deallocate 'memory-name-address'.
      memory-name-address mfree drop
    end
  do end
NULLPTR end end


proc compile-unreachable
  // ptr: source-name file-desc: source-file ptr: output-stream
  ptr file-desc ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: peeked-item
  ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // ptr: labels-list ptr: label-id-counter
  ptr ptr
  // ptr: local-memory-end
  ptr
  // ptr: let-names ptr: let-addresses ptr: let-vars-length
  ptr ptr ptr
  // ptr: output-array int: output-length
  ptr int
  // ptr: local-memory-max
  ptr
  ->
  // ptr: log-item
  ptr
  // Consume tokens until an reachable code is received.
  // All of the tokens must be keywords as intrinsics can not allow branches.
in let
  source-name source-file output-stream
  macro-names macro-tokens macros-length
  procedure-name procedure-address
  local-stack local-stack-length
  peeked-item
  extended-array extended-start extended-end
  labels-list label-id-counter
  local-memory-end
  let-names let-addresses let-vars-length
  output-array output-length
  local-memory-max
in
  while true do
    true compiler:expect-next-token let log-item in
      log-item isn-null if drop drop drop log-item return end
    end

    let token-type token-address token-arg in
      token-type TOKEN-TYPE:KEYWORD != if
        LOG-TYPE:UNXPCT-TYPE generate-log0 return
      end
      token-arg KEYWORD:END != if
        LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
      end
      labels-list list64:length is-zero if
        LOG-TYPE:UNREACHABLE generate-log0 return
      end

      labels-list list64:pop-last let label in
        label @64 label 8 + @64 let start-keyword start-address in
          start-keyword KEYWORD:IF = if
            label 16 + @64 label 24 + @64 let start-id start-stack in
              // Overwrite the contents of the local-stack with the old contents.
              start-stack local-stack local-stack-length local-stack.overwrite

              output-stream
              start-id nasm:label
              drop

              // Deallocate 'start-stack'.
              start-stack _local-stack.mfree

              NULLPTR return
            end
          end

          start-keyword KEYWORD:LET = if
            label 16 + @64 label 24 + @64 let new-names old-local-memory-end in
              0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
                name mlength 1 = if name @8 '_' != else true end if
                  name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                    LOG-TYPE:CANNOT-FIND-VAR generate-log0 return
                  end
                end
              end i end inc end drop

              old-local-memory-end local-stack local-stack-length output-stream local-stack.convert-deleted-real

              old-local-memory-end local-memory-end !64

              // Deallocate 'new-names'.
              new-names mfree drop
            end

          else start-keyword KEYWORD:PEEK = if
            label 16 + @64 label 24 + @64 let new-names old-peeked-item in
              0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
                name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                  LOG-TYPE:CANNOT-FIND-VAR generate-log0 return
                end
              end i end inc end drop

              old-peeked-item peeked-item !64

              // Deallocate 'new-names'.
              new-names mfree drop
            end

          else
            start-keyword KEYWORD:MEMORY != if
              LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
            end

            label 16 + @64 label 24 + @64 let new-names old-local-memory-end in
              0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
                name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                  LOG-TYPE:CANNOT-FIND-VAR generate-log0 return
                end
              end i end inc end drop

              old-local-memory-end local-stack local-stack-length output-stream local-stack.convert-deleted-real

              old-local-memory-end local-memory-end !64

              // Deallocate 'new-names'.
              new-names mfree drop
            end
          end end
        end
      end
    end
  end
NULLPTR end end


proc compile-keyword
  // ptr: source-name file-desc: source-file ptr: output-stream
  ptr file-desc ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length ptr: peeked-item
  ptr ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // ptr: labels-list ptr: label-id-counter
  ptr ptr
  // ptr: local-memory-end
  ptr
  // ptr: let-names ptr: let-addresses ptr: let-vars-length
  ptr ptr ptr
  // ptr: output-array int: output-length
  ptr int
  // ptr: local-memory-max
  ptr
  ->
  // bool: end-of-procedure ptr: log-item
  bool ptr
in let
  source-name source-file output-stream
  macro-names macro-tokens macros-length
  procedure-name procedure-address
  local-stack local-stack-length peeked-item
  extended-array extended-start extended-end
  token-type token-address token-arg
  labels-list label-id-counter
  local-memory-end
  let-names let-addresses let-vars-length
  output-array output-length
  local-memory-max
in
  token-arg KEYWORD:END = if
    // -------- Keyword 'end' --------

    labels-list list64:length is-zero if
      // -------- End of 'proc' --------
      local-stack local-stack-length output-stream local-stack.convert-last-items-real

      // Check if the stack is correct.
      output-array output-length local-stack local-stack-length compare-stack-types-types dup is-null swp return
    end

    labels-list list64:pop-last let label in
      label @64 label 8 + @64 let start-keyword start-address in
        start-keyword KEYWORD:IF = if
          // -------- End of 'if' --------
          label 16 + @64 label 24 + @64 let start-id start-stack in
            local-stack local-stack-length output-stream local-stack.convert-last-items-real

            // Check for the stack changes.
            start-stack local-stack local-stack-length compare-stack-types dup isn-null if false swp return end drop

            output-stream
            start-id nasm:label
            drop

            // Deallocate 'start-stack'.
            start-stack _local-stack.mfree
          end

        else start-keyword KEYWORD:ELSE = if
          // -------- End of 'else' --------

          label 16 + @64 label 24 + @64 label 32 + @64 let else-address start-id start-stack in
            local-stack local-stack-length output-stream local-stack.convert-last-items-real

            // Check for the stack changes.
            start-stack local-stack local-stack-length compare-stack-types dup isn-null if false swp return end drop

            output-stream
            start-id nasm:label
            drop

            // Deallocate 'else-address' and 'start-stack'.
            else-address mfree drop
            start-stack _local-stack.mfree
          end

        else start-keyword KEYWORD:DO = if
          // -------- End of 'do' --------

          label 16 + @64 label 24 + @64 label 32 + @64 label 40 + @64 label 48 + @64 label 56 + @64 let
            while-label-id do-address unbroken-end-id broken-end-id while-stack do-stack
          in
            // Check for the stack changes.
            while-stack local-stack local-stack-length compare-stack-types dup isn-null if false swp return end drop

            // Overwrite the contents of the local-stack.
            do-stack local-stack local-stack-length local-stack.overwrite

            output-stream
            while-label-id  nasm:jump-label
            unbroken-end-id nasm:label
            broken-end-id   nasm:label
            drop

            // Deallocate 'do-address', 'while-stack' and 'do-stack'.
            do-address mfree drop
            while-stack _local-stack.mfree
            do-stack _local-stack.mfree
          end

        else start-keyword KEYWORD:LET = if
          // -------- End of 'let' --------

          label 16 + @64 label 24 + @64 let new-names old-local-memory-end in
            0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
              name mlength 1 = if name @8 '_' != else true end if
                name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                  false LOG-TYPE:CANNOT-FIND-VAR generate-log0 return
                end
              end
            end i end inc end drop

            old-local-memory-end local-stack local-stack-length output-stream local-stack.convert-deleted-real

            old-local-memory-end local-memory-end !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end

        else start-keyword KEYWORD:PEEK = if
          // -------- End of 'peek' --------

          label 16 + @64 label 24 + @64 let new-names old-peeked-item in
            0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
              name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                false LOG-TYPE:CANNOT-FIND-VAR generate-log0 return
              end
            end i end inc end drop

            old-peeked-item peeked-item !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end

        else
          start-keyword KEYWORD:MEMORY != if
            false LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
          end

          // -------- End of 'memory' --------

          label 16 + @64 label 24 + @64 let new-names old-local-memory-end in
            0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
              name let-names let-addresses let-vars-length str-map64:remove-dstr ! if
                false LOG-TYPE:CANNOT-FIND-VAR generate-log0 return
              end
            end i end inc end drop

            old-local-memory-end local-stack local-stack-length output-stream local-stack.convert-deleted-real

            old-local-memory-end local-memory-end !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end
        end end end end end

        // Deallocate 'start-address'.
        start-address mfree drop
      end

      // Deallocate label object.
      label mfree drop
    end

  else token-arg KEYWORD:IF = if
    // -------- Keyword 'if' --------
    // <condition> if <any> end
    // <condition> if <any> else <any> end

    // TODO: These are not implemented yet.
    // <condition> if <any> (elif <condition> if <any>)* end

    // Label structure:
    //  0- 7 -> KEYWORD:IF
    //  8-15 -> Starter address
    // 16-23 -> Label ID
    // 24-31 -> Old stack

    1 is-items-available ! if false LOG-TYPE:NOT-ENOUGH-ITEMS generate-log0 return end

    pop-item let item in
      item stack-item:get-type INT-TYPE:BOOL != if
        false LOG-TYPE:INV-ITEM-TYPE generate-log0 return
      end

      output-stream
      item nasm:convert-real
      drop

      item stack-item:mfree
    end

    local-stack local-stack-length local-stack.copy let copy-stack in
      32 malloc let obj in
        obj is-null if false LOG-TYPE:MALLOC-FAILED generate-log0 return end

        compile-procedure:new-label-id let label-id in
          KEYWORD:IF           obj      !64
          token-address dcopy  obj 8  + !64
          label-id             obj 16 + !64
          copy-stack           obj 24 + !64

          obj labels-list list64:append

          output-stream
          "    pop     rax\n"      ostrbuf:puts
          "    test    rax, rax\n" ostrbuf:puts
          label-id                 nasm:jump-zero-label
          drop
        end
      end
    end

  else token-arg KEYWORD:ELSE = if
    // -------- Keyword 'else' --------
    // <condition> if <any> else <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:ELSE
    //  8-15 -> If address
    // 16-23 -> Else address
    // 24-31 -> Label ID
    // 32-39 -> Old stack

    labels-list list64:length is-zero if
      false LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
    end

    local-stack local-stack-length output-stream local-stack.convert-last-items-real

    labels-list list64:pop-last let label in
      label @64 label 8 + @64 let old-keyword old-address in
        old-keyword KEYWORD:IF != if
          false LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
        end

        label 16 + @64 label 24 + @64 let start-id start-stack in
          local-stack local-stack-length local-stack.copy let copy-stack in
            // Overwrite the contents of the local-stack.
            start-stack local-stack local-stack-length local-stack.overwrite

            compile-procedure:new-label-id let label-id in
              output-stream
              label-id nasm:jump-label
              start-id nasm:label
              drop

              40 malloc let new-label in
                new-label is-null if
                  false LOG-TYPE:MALLOC-FAILED generate-log0 return
                end

                KEYWORD:ELSE         new-label      !64
                old-address          new-label 8  + !64
                token-address dcopy  new-label 16 + !64
                label-id             new-label 24 + !64
                copy-stack           new-label 32 + !64

                new-label labels-list list64:append
              end
            end
          end

          // Deallocate 'start-stack'.
          start-stack _local-stack.mfree
        end
      end

      // Deallocate label object.
      label mfree drop
    end

  else token-arg KEYWORD:WHILE = if
    // -------- Keyword 'while' --------
    // while <condition> do <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:WHILE
    //  8-15 -> Starter address
    // 16-23 -> Label ID
    // 24-31 -> Old stack

    local-stack local-stack-length local-stack.copy let copy-stack in
      copy-stack is-null if false LOG-TYPE:MALLOC-FAILED generate-log0 return end

      compile-procedure:new-label-id let label-id in
        local-stack local-stack-length output-stream local-stack.convert-last-items-real

        output-stream
        label-id nasm:label
        drop

        32 malloc let new-label in
          new-label is-null if
            false LOG-TYPE:MALLOC-FAILED generate-log0 return
          end

          KEYWORD:WHILE        new-label      !64
          token-address dcopy  new-label 8  + !64
          label-id             new-label 16 + !64
          copy-stack           new-label 24 + !64

          new-label labels-list list64:append
        end
      end
    end

  else token-arg KEYWORD:DO = if
    // -------- Keyword 'do' --------
    // while <condition> do <any> end

    // TODO: These are not implemented yet.
    // while <condition> do <any> [else <any>] end

    // Label structure:
    //  0- 7 -> KEYWORD:DO
    //  8-15 -> While address
    // 16-23 -> While label label ID
    // 24-31 -> Do address
    // 32-39 -> Unbroken loop end label ID
    // 40-47 -> Broken loop end label ID
    // 48-55 -> While stack
    // 56-63 -> Do stack

    // Check if the local stack contains any item.
    1 is-items-available ! if false LOG-TYPE:NOT-ENOUGH-ITEMS generate-log0 return end

    local-stack local-stack-length output-stream local-stack.convert-last-items-real

    // Remove the bool value from the local-stack.
    pop-item let item in
      item stack-item:get-type INT-TYPE:BOOL != if
        false LOG-TYPE:INV-ITEM-TYPE generate-log0 return
      end

      item stack-item:mfree
    end

    // Get the 'while' label.
    labels-list list64:pop-last let old-label in
      old-label @64 old-label 8 + @64 let old-keyword old-address in
        // Check if the label type is 'while'.
        old-keyword KEYWORD:WHILE != if
          false LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
        end

        old-label 16 + @64 old-label 24 + @64 let old-label-id old-stack in
          compile-procedure:new-label-id compile-procedure:new-label-id let unbroken-end-label-id broken-end-label-id in
            compile-procedure:new-label-id compile-procedure:new-label-id let unbroken-end-id broken-end-id in
              output-stream
              "    pop     rax\n"      ostrbuf:puts
              "    test    rax, rax\n" ostrbuf:puts
              unbroken-end-id          nasm:jump-zero-label
              drop

              local-stack local-stack-length local-stack.copy let copy-stack in
                copy-stack is-null if
                  false LOG-TYPE:MALLOC-FAILED generate-log0 return
                end

                64 malloc let new-label in
                  new-label is-null if
                    false LOG-TYPE:MALLOC-FAILED generate-log0 return
                  end

                  KEYWORD:DO               new-label      !64
                  old-address              new-label 8  + !64
                  old-label-id             new-label 16 + !64
                  token-address dcopy      new-label 24 + !64
                  unbroken-end-id          new-label 32 + !64
                  broken-end-id            new-label 40 + !64
                  old-stack                new-label 48 + !64
                  copy-stack               new-label 56 + !64
                  new-label labels-list list64:append
                end
              end
            end
          end
        end
      end
    end

  else token-arg KEYWORD:BREAK = if
    // -------- Keyword 'break' -------
    // break

    labels-list list64:end-addr while dup labels-list list64:array-addr > do 8 - let label-addr in
      label-addr @64 @64 label-addr @64 8 + @64 let old-keyword old-address in
        old-keyword KEYWORD:DO = if
          label-addr @64 32 + @64 label-addr @64 24 + @64 label-addr @64 56 + @64 let broken-end-id do-address do-stack in
            // Check for the stack contents.
            do-stack local-stack local-stack-length compare-stack-types dup isn-null if false swp return end drop

            local-stack local-stack-length output-stream local-stack.convert-last-items-real

            output-stream
            broken-end-id nasm:jump-label
            drop
          end

          source-name source-file output-stream
          macro-names macro-tokens macros-length
          procedure-name procedure-address
          local-stack local-stack-length
          peeked-item
          extended-array extended-start extended-end
          labels-list label-id-counter
          local-memory-end
          let-names let-addresses let-vars-length
          output-array output-length
          local-memory-max
          compile-unreachable dup isn-null if false swp return end drop

          0 break
        end
      end
    label-addr end end drop

  else token-arg KEYWORD:MEMORY = if
    // -------- Keyword 'memory' -------
    // memory <name> <size> (and <name> <size>)* in <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:MEMORY
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-31 -> Old local-memory-end

    // New names are stored in new-names and new-names-length stack. When the 'end' of 'memory' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) and
           new-sizes-list sizeof(ptr) in
      list64:init let dynamic in
        dynamic is-null if
          false LOG-TYPE:MALLOC-FAILED generate-log0 return
        end

        dynamic new-names-list !64
      end

      list64:init let dynamic in
        dynamic is-null if
          false LOG-TYPE:MALLOC-FAILED generate-log0 return
        end

        dynamic new-sizes-list !64
      end

      // TODO: Add proper pre-compilation for memory size.

      new-names-list new-sizes-list KEYWORD:IN
      source-name source-file
      macro-names macro-tokens macros-length
      extended-array extended-start extended-end
      collect-memory-like-names dup isn-null if false swp return end drop

      0 while dup new-names-list list64:length < do let i in
        i new-names-list list64:get let name in
          INT-TYPE:INT STACK-MODE:LOCAL stack-item:create let replace-item in
            replace-item is-null if
              false LOG-TYPE:MALLOC-FAILED generate-log0 return
            end

            local-memory-end @64 dup
            replace-item stack-item:set-arg1
            i new-sizes-list list64:get + local-memory-end !64

            name replace-item let-names let-addresses let-vars-length str-map64:set-dstr if
              false LOG-TYPE:REDEF-LOCAL-NAME generate-log0 return
            end
          end
        end
      i end inc end drop

      local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

      32 malloc let new-label in
        new-label is-null if false LOG-TYPE:MALLOC-FAILED generate-log0 return end

        KEYWORD:MEMORY                   new-label      !64
        token-address dcopy              new-label  8 + !64
        new-names-list list64:copy-array new-label 16 + !64
        local-memory-end @64             new-label 24 + !64

        new-label labels-list list64:append
      end

      // Deallocate 'new-names-list' and 'new-sizes-list' but keep the 'memory' variable names.
      new-names-list list64:mfree drop
      new-sizes-list list64:mfree drop
    end

  else token-arg KEYWORD:LET = if
    // -------- Keyword 'let' --------
    // let <name>* in <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:LET
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-32 -> Old local-memory-end

    // New names are stored in new-names and new-names-length stack. When the 'end' of 'let' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) in
      list64:init let dynamic in
        dynamic is-null if
          false LOG-TYPE:MALLOC-FAILED generate-log0 return
        end

        dynamic new-names-list !64
      end

      new-names-list
      source-name source-file
      macro-names macro-tokens macros-length
      procedure-name procedure-address
      extended-array extended-start extended-end
      collect-let-like-names dup isn-null if false swp return end drop

      local-memory-end @64 let old-local-memory-end in
        // This loop is separated from the one above, since this loop must run in the reverse order.
        new-names-list list64:length while dup isn-zero do dec let i in
          1 is-items-available ! if false LOG-TYPE:NOT-ENOUGH-ITEMS generate-log0 return end

          pop-item i new-names-list list64:get let item variable-name in
            variable-name mlength 1 = if variable-name @8 '_' = else false end if
              item stack-item:get-mode STACK-MODE:REAL = if
                output-stream
                "    pop     r15\n" ostrbuf:puts
                drop
              end

            else
              item stack-item:get-mode STACK-MODE:IMM         =
              item stack-item:get-mode STACK-MODE:GLOBAL      = |
              item stack-item:get-mode STACK-MODE:@LOCALCONST = |
              item stack-item:get-mode STACK-MODE:LOCAL       = |
              item stack-item:get-mode STACK-MODE:DATA        = | if

                item stack-item:copy

              else
                local-stack local-stack-length output-stream local-stack.convert-last-items-real

                output-stream
                item                             nasm:convert-real
                "    mov     r15, [local_ptr]\n" ostrbuf:puts
                "    pop     qword [r15"         ostrbuf:puts
                local-memory-end @64 isn-zero if
                  " + "                          ostrbuf:puts
                  local-memory-end @64           ostrbuf:putu
                end
                "]\n"                            ostrbuf:puts
                drop

                item stack-item:get-type STACK-MODE:@LOCALCONST stack-item:create let replace-item in
                  replace-item is-null if
                    false LOG-TYPE:MALLOC-FAILED generate-log0 return
                  end

                  local-memory-end @64 replace-item stack-item:set-arg1

                  replace-item
                end

                local-memory-end @64 8 + local-memory-end !64
              end

              let replace-item in
                variable-name replace-item let-names let-addresses let-vars-length str-map64:set-dstr if
                  false LOG-TYPE:REDEF-LOCAL-NAME generate-log0 return
                end
              end

              local-memory-end @64 8 + local-memory-end !64
            end
          end
        i end end drop

        local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

        32 malloc let new-label in
          new-label is-null if false LOG-TYPE:MALLOC-FAILED generate-log0 return end

          KEYWORD:LET                      new-label      !64
          token-address dcopy              new-label  8 + !64
          new-names-list list64:copy-array new-label 16 + !64
          old-local-memory-end             new-label 24 + !64

          new-label labels-list list64:append
        end
      end

      // Deallocate 'new-names-list' but keep the 'let' variable names.
      new-names-list list64:mfree drop
    end

  else token-arg KEYWORD:PEEK = if
    // -------- Keyword 'peek' --------
    // peek <name>* in <any> end

    // Label structure:
    //  0- 7 -> KEYWORD:PEEK
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-32 -> Old peeked-item

    // New names are stored in new-names and new-names-length stack. When the 'end' of 'peek' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) in
      list64:init let dynamic in
        dynamic is-null if
          false LOG-TYPE:MALLOC-FAILED return
        end

        dynamic new-names-list !64
      end

      new-names-list
      source-name source-file
      macro-names macro-tokens macros-length
      procedure-name procedure-address
      extended-array extended-start extended-end
      collect-let-like-names dup isn-null if false swp return end drop

      new-names-list list64:length is-items-available ! if false LOG-TYPE:NOT-ENOUGH-ITEMS generate-log0 return end

      peeked-item @64 let old-peeked-item in
        local-stack-length @64 peeked-item !64

        // This loop is separated from the one above, since this loop must run in the reverse order.
        new-names-list list64:length while dup isn-zero do dec let i in
          local-stack-length @64 new-names-list list64:length - i + let item-index in
            item-index local-stack array64:get let item in
              i new-names-list list64:get let variable-name in
                item stack-item:get-mode STACK-MODE:IMM         =
                item stack-item:get-mode STACK-MODE:GLOBAL      = |
                item stack-item:get-mode STACK-MODE:@LOCALCONST = |
                item stack-item:get-mode STACK-MODE:LOCAL       = |
                item stack-item:get-mode STACK-MODE:DATA        = | if

                  item stack-item:copy

                else
                  item stack-item:get-type STACK-MODE:PEEKED stack-item:create let replace-item in
                    replace-item is-null if
                      false LOG-TYPE:MALLOC-FAILED generate-log0 return
                    end

                    item-index replace-item stack-item:set-arg1
                  replace-item end
                end

                let replace-item in
                  variable-name replace-item let-names let-addresses let-vars-length str-map64:set-dstr if
                    false LOG-TYPE:REDEF-LOCAL-NAME generate-log0 return
                  end
                end
              end
            end
          end
        i end end drop

        32 malloc let new-label in
          new-label is-null if false LOG-TYPE:MALLOC-FAILED generate-log0 return end

          KEYWORD:PEEK                     new-label      !64
          token-address dcopy              new-label  8 + !64
          new-names-list list64:copy-array new-label 16 + !64
          old-peeked-item                  new-label 24 + !64

          new-label labels-list list64:append
        end
      end

      // Deallocate 'new-names-list' but keep the 'peek' variable names.
      new-names-list list64:mfree drop
    end

  else token-arg KEYWORD:RETURN = if
    // -------- Keyword 'return' --------

    local-stack local-stack-length output-stream local-stack.convert-last-items-real

    output-array output-length local-stack local-stack-length compare-stack-types-types dup isn-null if false swp return end drop

    output-stream
    "    jmp     .return\n" ostrbuf:puts
    drop

    source-name source-file output-stream
    macro-names macro-tokens macros-length
    procedure-name procedure-address
    local-stack local-stack-length
    peeked-item
    extended-array extended-start extended-end
    labels-list label-id-counter
    local-memory-end
    let-names let-addresses let-vars-length
    output-array output-length
    local-memory-max
    compile-unreachable dup isn-null if false swp return end drop

  else token-arg KEYWORD:CAST = if
    // -------- Keyword 'cast' --------

    // TODO: Implement check if the stack contains an item.

    // Get the cast intrinsic type.
    false compiler:expect-next-token let log-item in
      log-item isn-null if drop drop drop false log-item return end
    end

    let type-type type-address type-arg in
      // The token after 'cast' should be an 'intrinsic type'.
      type-type TOKEN-TYPE:INT-TYPE != if
        false LOG-TYPE:UNXPCT-TYPE generate-log0 return
      end

      local-stack local-stack-length output-stream local-stack.convert-last-items-real

      // Change the type of the last item.
      local-stack-length @64 dec local-stack array64:get let item in
        type-arg item stack-item:set-type
      end

      // Deallocate 'type-address'.
      type-address mfree drop
    end

  else
    token-arg KEYWORD:SIZEOF != if
      false LOG-TYPE:UNKNOWN-KEYWORD generate-log0 return
    end

    // -------- Keyword 'sizeof' --------
    // sizeof <type>

    // TODO: These are not implemented yet.
    // sizeof <global-variable-name>
    // sizeof <string-immediate>
    // sizeof <local-name>

    true compiler:expect-next-token let log-item in
      log-item isn-null if drop drop drop false log-item return end
    end

    let type-type type-address type-arg in
      // The token afrer 'sizeof' should be an 'intrinsic type'.
      type-type TOKEN-TYPE:INT-TYPE != if
        false LOG-TYPE:UNXPCT-TYPE generate-log0 return
      end

      // Push the size of the intrinsic type.
      type-arg get-int-type-sizeof push-int-immediate
    end
  end end end end end end end end end end end
end false NULLPTR end


proc compile-procedure
  // ptr: source-name file-desc: source-file ptr: output-stream
  ptr file-desc ptr
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length ptr: peeked-item
  ptr ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // ptr: output-array int: output-length ->
  ptr int ->
  // int: local-memory-max ptr: log-item
  int ptr

  // Compiles a Corth procedure.
in let
  source-name source-file output-stream
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names macro-tokens macros-length
  procedure-name procedure-address
  local-stack local-stack-length peeked-item
  extended-array extended-start extended-end
  output-types-array output-types-length
in
  output-stream
  "proc_"        ostrbuf:puts
  procedure-name nasm:put-alpha
  ":\n"          ostrbuf:puts
  drop

  // label-id-counter allows to create unique IDs for label labels.
  // let-names, let-addresses and let-vars-length create a str_map64:
  // local-memory-end keeps track of the first available-dstr position on the local memory.
  // local-memory-max keeps track of the maximum length of the local memory, to later allocate enough space.
  memory labels-list      sizeof(ptr)      and
         label-id-counter sizeof(int)      and
         let-names        LET-MAX-COUNT    and
         let-addresses    LET-MAX-COUNT    and
         let-vars-length  sizeof(int)      and
         local-memory-end sizeof(int)      and
         local-memory-max sizeof(int)      in

    list64:init let dynamic in
      dynamic is-null if 0 LOG-TYPE:MALLOC-FAILED generate-log0 return end

      dynamic labels-list !64
    end

    0 label-id-counter !64
    0 let-vars-length  !64
    0 local-memory-end !64
    0 local-memory-max !64

    while true do
      true compiler:expect-next-token let log-item in
        log-item isn-null if drop drop drop 0 log-item return end
      end

      let token-type token-address token-arg in
        token-type TOKEN-TYPE:INTEGER = if
          // -------- Constant integer --------

          token-arg push-int-immediate

        else token-type TOKEN-TYPE:STRING = if
          // -------- Strings --------

          data-definitions-list list64:length push-data
          token-arg mlength dec               push-int-immediate

          token-arg data-definitions-list list64:append

        else token-type TOKEN-TYPE:NAME = if
          // -------- Names --------

          token-arg let-names let-addresses let-vars-length str-map64:get-dstr if
            // -------- local variables --------

            let replace-item in
              // TODO: This is a quick work-around for 'peek' keyword. This condition should be removed and rewritten ASAP.

              replace-item stack-item:get-mode STACK-MODE:PEEKED = if
                replace-item stack-item:get-type push-real

                output-stream
                "    push    qword [rsp + " ostrbuf:puts
                local-stack-length @64 replace-item stack-item:get-arg1 - 2 - 8 * ostrbuf:puti
                "]\n" ostrbuf:puts
                drop
              else

                replace-item stack-item:copy push-item
              end
            end

          else drop token-arg global-names-array global-sizes-array globals-length str-map64:get-dstr if
            // -------- global 'memory' variables --------

            let address in
              INT-TYPE:INT STACK-MODE:GLOBAL stack-item:create let item in
                item is-null if
                  0 LOG-TYPE:MALLOC-FAILED generate-log0 return
                end

                token-arg item stack-item:set-arg1

                item push-item
              end
            end

          else drop
            token-arg proc-names-array proc-names-array procs-length @64 8 * + str-sorted8:available-dstr ! if
              // TODO: Add Levenshtein distance algoritm to show the nearest matchs; which can be definitions, macros, procedures, keywords and intrinsics.
              drop 0 token-address LOG-TYPE:UNDEF-NAME generate-log1 return
            end

            // -------- 'proc' calls --------

            let name-address in name-address proc-names-array - let delta in
              delta proc-inputs-array + delta proc-outputs-array + let input-address output-address in
                local-stack local-stack-length output-stream local-stack.convert-last-items-real

                input-address @64 input-address @64 mlength 8 /
                local-stack local-stack-length
                compare-sub-stack-types-types dup isn-null if token-address LOG-TYPE:CANNOT-CALL-PROC generate-log2 0 swp return end drop

                0 while dup output-address @64 mlength 8 / < do peek i in
                  i output-address @64 array64:get let output in
                    output push-real
                  end
                end inc end drop

                compile-procedure:new-label-id let label-id in
                  output-stream
                  "    xchg    rsp, [call_ptr]\n"              ostrbuf:puts
                  "    push    .label_"                        ostrbuf:puts
                  label-id                                     ostrbuf:putu
                                                               ostrbuf:putnl
                  "    push    qword [local_ptr]\n"            ostrbuf:puts
                  "    add     qword [local_ptr], "            ostrbuf:puts
                  local-memory-end @64                         ostrbuf:putu
                                                               ostrbuf:putnl
                  "    xchg    rsp, [call_ptr]\n"              ostrbuf:puts
                  "    jmp     proc_"                          ostrbuf:puts
                  token-arg                                    nasm:put-alpha
                                                               ostrbuf:putnl
                  label-id                                     nasm:label
                  drop
                end
              end
            end end
          end end

        else token-type TOKEN-TYPE:INTRINSIC = if
          // -------- Intrinsics --------

          source-name source-file output-stream
          procedure-name procedure-address
          local-stack local-stack-length
          peeked-item
          token-type token-arg
          compile-intrinsic dup isn-null if token-address LOG-TYPE:ERROR-INTRINSIC generate-log2 0 swp return end drop

        else
          token-type TOKEN-TYPE:KEYWORD != if
            0 LOG-TYPE:UNXPCT-TYPE generate-log0 return
          end

          // -------- Keywords --------

          source-name source-file output-stream
          macro-names macro-tokens macros-length
          procedure-name procedure-address
          local-stack local-stack-length
          peeked-item
          extended-array extended-start extended-end
          token-type token-address token-arg
          labels-list label-id-counter
          local-memory-end
          let-names let-addresses let-vars-length
          output-types-array output-types-length
          local-memory-max
          compile-keyword let end-of-proc log-item in
            log-item isn-null if
              0 log-item token-address LOG-TYPE:ERROR-KEYWORD generate-log2 return
            end
            end-of-proc if local-memory-max @64 NULLPTR return end
          end
        end end end end

        // Deallocate the space allocated for token-address.
        token-address mfree drop
      end
    end

    // Deallocate 'labels-list'.
    labels-list list64:mfree-deep drop
  end
end 0 NULLPTR end // dummy return


proc compile-file
  // ptr: source-name ptr: output-stream
  ptr ptr
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // include-paths-set
  ptr
  // libraries-set
  ptr ->
  // ptr: log-item
  ptr

  // Compiles a Corth source file.

  // TODO: Add called-from to improve debugging.
in let
  source-name output-stream
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names macro-tokens macros-length
  include-paths-set
  libraries-set
in
  // Check if the library was included already.
  source-name libraries-set str-set8:add ! if NULLPTR return end

  // Open the source file.
  source-name fopen-r let source-file in
    // Check if the source is opened.
    source-file isn-pos if source-file LOG-TYPE:CANNOT-OPEN-SRC generate-log1 return end

    memory extended-array  EXTENDED-MAX-LENGTH and
           extended-start  sizeof(int)         and
           extended-end    sizeof(int)         and
           namespace-name  sizeof(ptr)         in

      // Reset extended-tokens.
      0 extended-start !64
      0 extended-end   !64

      // Reset namespace.
      NULLPTR namespace-name !64

      while true do
        // Get next token and check if there is one available-dstr.
        true compiler:get-next-token ! if let log-item in
          drop drop drop log-item return
        end end drop
        let token-type token-address token-arg in
          token-type TOKEN-TYPE:KEYWORD != if LOG-TYPE:UNXPCT-TYPE generate-log0 return end

          // -------- Global keywords --------
          token-arg KEYWORD:INCLUDE = if
            // -------- Keyword 'include' --------
            // TODO: Create a function to include.
            // TODO: Allow including packages.

            // Get the next token, which should be the include path:

            false compiler:expect-next-token let log-item in
              log-item isn-null if drop drop drop log-item return end
            end

            let path-token-type path-token-address path-token-arg in
              path-token-type TOKEN-TYPE:STRING != if LOG-TYPE:UNXPCT-TYPE generate-log0 return end

              memory found sizeof(bool) in
                found !reset

                0 while dup include-paths-set list64:length < do let i in
                  i include-paths-set list64:get let directory in
                    directory cstr:str path-token-arg path-token-arg mlength path:merge2-cstr let include-path in
                      // Check if the user has the required permissions.
                      memory stats sizeof(stat) in
                        include-path stats stat drop

                        // Check if user has access to the path:
                        include-path ACCESS-MODE:R_OK access is-zero if
                          // Mark as found.
                          found !set

                          stats 24 + @64 S_IFMT && let masked in
                            masked S_IFREG != if
                              masked S_IFDIR = if
                                // Directory including, should include all sub paths.
                                include-path LOG-TYPE:TODO-DIR-INCLUDE generate-log1 token-address LOG-TYPE:CANNOT-INCLUDE generate-log2 return
                              end

                              include-path LOG-TYPE:UNKNOWN-FILE-TYPE generate-log1 token-address LOG-TYPE:CANNOT-INCLUDE generate-log2 return
                            end

                            // File including, call compile-file on the file.
                            include-path output-stream
                            data-definitions-list
                            global-names-array global-sizes-array globals-length
                            proc-names-array proc-inputs-array proc-outputs-array procs-length
                            macro-names macro-tokens macros-length
                            include-paths-set
                            libraries-set
                            compile-file dup isn-null if return end drop
                          end
                          0 break
                        end
                      end

                      // Deallocate 'include-path'.
                      include-path mfree drop
                    end
                  end
                i end inc end drop

                // Check if any library is found.
                found @bool ! if
                  path-token-arg LOG-TYPE:CANNOT-FIND-SRC generate-log1 token-address LOG-TYPE:CANNOT-INCLUDE generate-log2 return
                end
              end
            end

          else token-arg KEYWORD:MEMORY = if
            // -------- Keyword 'memory' --------

            memory new-names-list sizeof(ptr) and
                   new-sizes-list sizeof(ptr) in
              list64:init let dynamic in
                dynamic is-null if LOG-TYPE:MALLOC-FAILED generate-log0 return end
                dynamic new-names-list !64
              end

              list64:init let dynamic in
                dynamic is-null if LOG-TYPE:MALLOC-FAILED generate-log0 return end
                dynamic new-sizes-list !64
              end

              new-names-list new-sizes-list KEYWORD:END
              source-name source-file
              macro-names macro-tokens macros-length
              extended-array extended-start extended-end
              collect-memory-like-names dup isn-null if
                return
              end drop

              0 while dup new-names-list list64:length < do let i in
                // Get the full name of the variable.
                namespace-name @64 is-null if
                  i new-names-list list64:get
                else
                  namespace-name @64 i new-names-list list64:get djoin
                end

                let name in
                  // Store the variable.
                  name i new-sizes-list list64:get global-names-array global-sizes-array globals-length str-map64:set-dstr if
                    LOG-TYPE:REDEF-GLOBAL-NAME generate-log0 return
                  end
                end
              i end inc end drop

              // Deallocate 'new-names-list' and 'new-sizes-list' but keep the 'memory' variable names.
              new-names-list list64:mfree drop
              new-sizes-list list64:mfree drop
            end

          else token-arg KEYWORD:MACRO = if
            // -------- Keyword 'macro' --------

            // Get the next token, which should be the name of the macro.
            false compiler:expect-next-token let log-item in log-item isn-null if drop drop drop log-item return end end

            let macro-name-token-type macro-name-token-address macro-name-token-arg in
              macro-name-token-type TOKEN-TYPE:NAME != if
                LOG-TYPE:UNXPCT-TYPE generate-log0 return
              end

              // macro-tokens and macro-tokens-length are used to create a STACK for macro tokens.
              memory macro-tokens-list sizeof(ptr) in
                list64:init let dynamic in
                  dynamic is-null if LOG-TYPE:MALLOC-FAILED generate-log0 return end
                  dynamic macro-tokens-list !64
                end

                while true do
                  // Get next tokens, until an 'endmacro' is found.
                  false compiler:expect-next-token let log-item in
                    log-item isn-null if drop drop drop log-item return end
                  end

                  let macro-new-token-type macro-new-token-address macro-new-token-arg in
                    // If the token is an 'endmacro' keyword, break the loop.
                    macro-new-token-type TOKEN-TYPE:KEYWORD = if
                      macro-new-token-arg KEYWORD:ENDMACRO = if
                        break
                      end
                    end

                    // Add the token attributes to the macro-tokens-list.
                    macro-new-token-type    macro-tokens-list list64:append
                    macro-new-token-address macro-tokens-list list64:append
                    macro-new-token-arg     macro-tokens-list list64:append
                  end
                end

                // TODO: Check if the macros stack was filled.
                namespace-name @64 is-null if
                  macro-name-token-arg
                else
                  namespace-name @64 macro-name-token-arg djoin
                end let name in
                  name macro-tokens-list list64:copy-array macro-names macro-tokens macros-length str-map64:set-dstr if
                    LOG-TYPE:REDEF-GLOBAL-NAME generate-log0 return
                  end
                end

                // Deallocate 'macro-tokens-list'.
                macro-tokens-list list64:mfree drop
              end

              // Deallocate 'macro-name-token-address'.
              macro-name-token-address mfree drop
            end

          else token-arg KEYWORD:PROC = if
            // -------- 'proc' keyword --------

            // Get the next token, which should be the name of the procedure.
            false compiler:expect-next-token let log-item in
              log-item isn-null if drop drop drop log-item return end
            end

            let proc-name-token-type proc-name-token-address proc-name-token-arg in
              proc-name-token-type TOKEN-TYPE:NAME != if
                LOG-TYPE:UNXPCT-TYPE generate-log0 return
              end

              memory input-list  sizeof(ptr) and
                     output-list sizeof(ptr) in

                // TODO: Check if the dynamic object is NULLPTR or not.
                list64:init input-list !64
                list64:init output-list !64

                // Get the input types.
                while true do
                  // Get the token.
                  true compiler:expect-next-token let log-item in
                    log-item isn-null if drop drop drop log-item return end
                  end

                  let input-token-type input-token-address input-token-arg in
                    input-token-type TOKEN-TYPE:KEYWORD = if
                      // If the token was a keyword, it must be a 'KEYWORD:RETURN'.
                      input-token-arg KEYWORD:RETURNS != if
                        LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
                      end

                      // Deallocate 'input-token-address'.
                      input-token-address mfree drop

                      // If the token was a 'KEYWORD:RETURNS', break the loop.
                      break
                    end

                    // Check if the token is of type-type.
                    input-token-type TOKEN-TYPE:INT-TYPE != if
                      LOG-TYPE:UNXPCT-TYPE generate-log0 return
                    end

                    input-token-arg input-list list64:append

                    // Deallocate 'input-token-address'.
                    input-token-address mfree drop
                  end
                end

                // Get the output types.
                while true do
                  // Get the token.
                  true compiler:expect-next-token let log-item in
                    log-item isn-null if drop drop drop log-item return end
                  end

                  let output-token-type output-token-address output-token-arg in
                    output-token-type TOKEN-TYPE:KEYWORD = if
                      // If the token is a keyword, it must be a 'KEYWORD:IN'.
                      output-token-arg KEYWORD:IN != if
                        LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
                      end

                      // Deallocate 'output-token-address'.
                      output-token-address mfree drop

                      // If the token was a 'KEYWORD:IN', break the loop.
                      break
                    end

                    // Check if the token is of type-type.
                    output-token-type TOKEN-TYPE:INT-TYPE != if
                      LOG-TYPE:UNXPCT-TYPE generate-log0 return
                    end

                    output-token-arg output-list list64:append

                    // Deallocate 'output-token-address'.
                    output-token-address mfree drop
                  end
                end

                // Store the full name of the procedure, its input and outputs.
                // Check if the procedure was defined already.
                namespace-name @64 is-null if
                  proc-name-token-arg
                else
                  namespace-name @64 proc-name-token-arg djoin
                end

                let full-name in
                  full-name proc-names-array proc-names-array procs-length @64 8 * + str-sorted8:available-dstr if drop
                    LOG-TYPE:REDEF-GLOBAL-NAME generate-log0 return
                  end

                  let name-address in
                    name-address proc-names-array - let delta in
                      proc-inputs-array delta + proc-outputs-array delta + let input-address output-address in
                        // Shift the array to insert the name, input and output.
                        name-address   name-address   8 + procs-length @64 name-address   proc-names-array   - 8 / - memcpy64i
                        input-address  input-address  8 + procs-length @64 input-address  proc-inputs-array  - 8 / - memcpy64i
                        output-address output-address 8 + procs-length @64 output-address proc-outputs-array - 8 / - memcpy64i

                        // Save the name, inputs and outputs of the procedure.
                        full-name               dcopy name-address   !64
                        input-list  list64:copy-array input-address  !64
                        output-list list64:copy-array output-address !64

                        procs-length @inc64
                      end
                    end
                  end

                  // Create the stack for the procedure.
                  memory local-stack        STACK-MAX-ITEMS and
                         local-stack-length sizeof(int)     and
                         peeked-item        sizeof(int)     in

                    0 local-stack-length !64
                    0 peeked-item        !64

                    0 while dup input-list list64:length < do peek i in
                      i input-list list64:get let type in
                        type push-real
                      end
                    end inc end drop

                    source-name source-file output-stream
                    data-definitions-list
                    global-names-array global-sizes-array globals-length
                    proc-names-array proc-inputs-array proc-outputs-array procs-length
                    macro-names macro-tokens macros-length
                    full-name proc-name-token-address
                    local-stack local-stack-length
                    peeked-item
                    extended-array extended-start extended-end
                    output-list list64:to-array
                    compile-procedure let max-memory log-item in
                      log-item isn-null if log-item LOG-TYPE:ERROR-PROC generate-log1 return end
                    end

                    output-stream
                    ".return:\n"                        ostrbuf:puts
                    "    xchg    rsp, [call_ptr]\n"     ostrbuf:puts
                    "    pop     qword [local_ptr]\n"   ostrbuf:puts
                    "    pop     rax\n"                 ostrbuf:puts
                    "    xchg    rsp, [call_ptr]\n"     ostrbuf:puts
                    "    jmp     rax\n"                 ostrbuf:puts
                    drop
                  end
                end

                // Deallocate input-list and output-list.
                input-list  list64:mfree drop
                output-list list64:mfree drop
              end
            end

          else token-arg KEYWORD:NAMESPACE = if
            namespace-name @64 isn-null if
              LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
            end

            // Get the next token, which should be the name of the procedure.
            false compiler:expect-next-token let log-item in
              log-item isn-null if drop drop drop log-item return end
            end

            let name-type name-address name-arg in
              name-type TOKEN-TYPE:NAME != if
                LOG-TYPE:UNXPCT-TYPE generate-log0 return
              end

              ':' name-arg dappend8 namespace-name !64
            end

          else
            token-arg KEYWORD:ENDNAMESPACE != if
              LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
            end

            namespace-name @64 is-null if
              LOG-TYPE:UNXPCT-KEYWORD generate-log0 return
            end

            NULLPTR namespace-name !64
          end end end end end
        end
      end
    end

    source-file fclose drop
  end
NULLPTR end end


proc compile-nasm
  // ptr: source-name ptr: output-name ptr: include-paths-set -> ptr: log-item
  ptr ptr ptr -> ptr
in let source-name output-name include-paths-set in
  // Create the output file.
  output-name 0o777 creat dup isn-pos if
    drop LOG-TYPE:CANNOT-CREAT-OUT generate-log0 return
  end

  let output-file in
    // Check if the file is opened successfully.
    output-file isn-pos if
      LOG-TYPE:CANNOT-OPEN-OUT generate-log0 return
    end

    memory output-stream OUTPUT-STREAM-SIZE in
      output-file OUTPUT-STREAM-SIZE output-stream ostrbuf:init

      output-stream
      "segment .text\n"                                   ostrbuf:puts
      "global _start\n"                                   ostrbuf:puts
      "_start:\n"                                         ostrbuf:puts
      "    mov     qword [call_ptr], call_stack\n"        ostrbuf:puts
      "    add     qword [call_ptr], 0x4000\n"            ostrbuf:puts
      "    mov     qword [local_ptr], local_memory\n"     ostrbuf:puts
      "    xchg    rsp, [call_ptr]\n"                     ostrbuf:puts
      "    push    corth_endofprogram\n"                  ostrbuf:puts
      "    push    qword [local_ptr]\n"                   ostrbuf:puts
      "    xchg    rsp, [call_ptr]\n"                     ostrbuf:puts
      "    mov     rax, [rsp]\n"                          ostrbuf:puts
      "    mov     rbx, rsp\n"                            ostrbuf:puts
      "    add     rbx, 8\n"                              ostrbuf:puts
      "    mov     rdx, rax\n"                            ostrbuf:puts
      "    shl     rdx, 3\n"                              ostrbuf:puts
      "    sub     rsp, rdx\n"                            ostrbuf:puts
      "    push    rax\n"                                 ostrbuf:puts
      "    push    rbx\n"                                 ostrbuf:puts
      "    jmp     proc_main\n"                           ostrbuf:puts
      "corth_endofprogram:\n"                             ostrbuf:puts
      "    mov     rax, 60\n"                             ostrbuf:puts
      "    pop     rdi\n"                                 ostrbuf:puts
      "    syscall\n"                                     ostrbuf:puts
      drop

      memory global-names-array     GLOBALS-MAX-COUNT and
             global-sizes-array     GLOBALS-MAX-COUNT and
             globals-length         sizeof(int)       and

             proc-names-array       PROCS-MAX-COUNT   and
             proc-inputs-array      PROCS-MAX-COUNT   and
             proc-outputs-array     PROCS-MAX-COUNT   and
             procs-length           sizeof(int)       and

             macro-names            MACROS-MAX-COUNT  and
             macro-tokens           MACROS-MAX-COUNT  and
             macros-length          sizeof(int)       and

             data-definitions-list  sizeof(ptr)       and

             libraries-set          sizeof(ptr)       in

        0 globals-length   !64
        0 procs-length     !64
        0 macros-length    !64

        list64:init let dynamic in
          dynamic is-null if LOG-TYPE:MALLOC-FAILED generate-log0 return end
          dynamic data-definitions-list !64
        end

        list64:init let dynamic in
          dynamic is-null if LOG-TYPE:MALLOC-FAILED generate-log0 return end
          dynamic libraries-set !64
        end

        source-name output-stream
        data-definitions-list
        global-names-array global-sizes-array globals-length
        proc-names-array proc-inputs-array proc-outputs-array procs-length
        macro-names macro-tokens macros-length
        include-paths-set
        libraries-set
        compile-file dup isn-null if return end drop

        // Print the data labels.
        output-stream
        "segment .data\n"       ostrbuf:puts
        0 while dup data-definitions-list list64:length < do let i in
          "    data_"           ostrbuf:puts
          i                     ostrbuf:putu
          ": db "               ostrbuf:puts

          i data-definitions-list list64:get let data in
            0 while dup data mlength < do let j in
              j data + @8       ostrbuf:putu
              ", "              ostrbuf:puts
            j end inc end drop
          end

                                ostrbuf:putnl
        i end inc end drop

        // Print the global memory labels.
        "segment .bss\n"                                    ostrbuf:puts
        "    local_memory:   resb 67108864\n"               ostrbuf:puts
        "    local_ptr:      resq 1\n"                      ostrbuf:puts
        "    call_stack:     resb 67108864\n"               ostrbuf:puts
        "    call_ptr:       resq 1\n"                      ostrbuf:puts

        0 while dup globals-length @64 < do let i in
          i global-names-array array64:get i global-sizes-array array64:get let variable-name variable-size in
            "    global_"                    ostrbuf:puts
            i global-names-array array64:get nasm:put-alpha
            ": resb "                        ostrbuf:puts
            variable-size                    ostrbuf:putu
                                             ostrbuf:putnl

            // Deallocate the name of the variable.
            variable-name mfree drop
          end
        i end inc end drop

        // Flush the remaining in the output-stream.
        output-stream ostrbuf:flush
        drop

        // Deallocate space allocated for procedures.
        0 while dup procs-length @64 < do peek i in
          i proc-names-array   array64:get mfree drop
          i proc-inputs-array  array64:get mfree drop
          i proc-outputs-array array64:get mfree drop
        end inc end drop

        // Deallocate space allocated for macros.
        0 while dup macros-length @64 < do peek i in
          i macro-names array64:get mfree drop

          i macro-tokens array64:get let tokens in
            0 while dup tokens mlength 24 / < do peek j in
              j tokens array64:get j inc tokens array64:get j 2 + tokens array64:get let token-type token-address token-arg in
                // Deallocate 'token-address'.
                token-address mfree drop

                // Deallocate 'token-arg' if the token is either a 'name' or a 'string'.
                token-type TOKEN-TYPE:NAME = token-type TOKEN-TYPE:STRING = | if
                  token-arg mfree drop
                end
              end
            end 3 + end drop

            // Deallocate 'tokens'.
            tokens mfree drop
          end
        end inc end drop

        // Deallocate the space allocated for libraries-set.
        libraries-set list64:mfree-deep drop

        // Deallocate the space allocated for data-definitions-list
        data-definitions-list list64:mfree-deep drop
      end
    end

    output-file fclose drop
  end
NULLPTR end end
