include libs/linux_x86/sys.corth
include libs/linux_x86/io/output.corth
include libs/linux_x86/io/input.corth
include libs/core/stack.corth
include libs/core/arithmetic.corth
include libs/core/memory.corth

include libs/dynamic/malloc.corth
include libs/dynamic/utils.corth

macro string-builder.RESIZING 64 endmacro

include libs/linux_x86/path.corth

include libs/collections/list64.corth
include libs/collections/deque64.corth
include libs/collections/queue64.corth
include libs/collections/str_map64.corth
include libs/collections/str_set8.corth

include compiler/lexer.corth
include compiler/debug.corth
include compiler/enums.corth
include compiler/local_stack.corth


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.show-here
  // ptr: token-address
  log-stream fput-here
  procedure-name procedure-address log-stream fput-inside-procedure
  ERROR-EXIT-CODE exit drop
endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.get-next-token let expect-address expect-length extend-macros in
  // str: expect-message bool: extend-macros -- int: token-type ptr: address [int|ptr]: arg
  // Calls get-next-token and checks if a token is available-dstr. If there are no tokens, prints an error message.
  source-name source-file
  line-no char-no
  extended-array extended-start extended-end
  macro-names macro-tokens macros-length
  log-stream extend-macros get-next-token ! if
    LOG.ERR log-stream fputs "Reached EOF while expecting " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs
    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-type let _token_type_ expect-address expect-length expected-token-type in
  // ptr: token-arg ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-type _token_type_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-type log-stream fput-type  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_type_ log-stream fput-type "'.\n" log-stream fputs
    
    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-type-here let _token_type_ _token_addr_ expect-address expect-length expected-token-type in
  // ptr: token-arg ptr: token-addr ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-type _token_type_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-type log-stream fput-type  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_type_ log-stream fput-type "'.\n" log-stream fputs

    _token_addr_ compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-keyword let _token_arg_ expect-address expect-length expected-token-arg in
  // ptr: token-arg ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs

    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-keyword-here let _token_arg_ _token_addr_ expect-address expect-length expected-token-arg in
  // ptr: token-arg ptr: token-addr ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs

    _token_addr_ compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-level-here let _token_arg_ _old_token_addr_ _token_addr_ expect-address expect-length expected-token-arg in
  // ptr: token-arg ptr: old-token-addr ptr: new-token-addr ptr: expect-addr int: expect-length int: expected-token-arg
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs
    _old_token_addr_ compile-procedure.show-here
    _token_addr_ compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-null let expect-address expect-length in
  is-null if
    LOG.ERR log-stream fputs "'malloc' failed while " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs
    
    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-null-here let expect-address expect-length in
  is-null if
    LOG.ERR log-stream fputs "'malloc' failed while " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs

    token-address compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-branch let expect-address expect-length in
  branch-active @8 is-zero if
    LOG.SOFT log-stream fputs "Tried to " log-stream fputs expect-address expect-length log-stream fputs " but the branch was finished.\n" log-stream fputs

    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.check-branch-here let _token_addr_ expect-address expect-length in
  branch-active @8 is-zero if
    LOG.SOFT log-stream fputs "Tried to " log-stream fputs expect-address expect-length log-stream fputs " but the branch was finished.\n" log-stream fputs
    
    _token_addr_ compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-procedure'. Variable names used inside this macro should not be changed as they come from 'compile-procedure'.
macro compile-procedure.new-level-id
  level-id-counter @64 dup inc level-id-counter !64
endmacro


/*

items:
  type (8)
  mode (8)

bool:
  real:
    type (8)
    mode (8)

int:
  real:
    type (8)
    mode (8)

  imm:
    type (8)
    mode (8)
    arg1 (8)

  global:
    type (8)
    mode (8)
    arg1 (8)

*/


macro invalid-usage-of-intrinsic
  LOG.ERR log-stream fputs "Invalid argument types.\n" log-stream fputs
  token-address log-stream fput-here
  ERROR-EXIT-CODE exit drop
endmacro


proc compare-stack-types
  // ptr: old-stack ptr: local-stack ptr: local-stack-length -- bool: is-equal
  ptr ptr ptr -- bool
in let old-stack local-stack local-stack-length in
  local-stack-length @64 8 * old-stack mlength != if false return end

  0 while dup local-stack-length @64 < do let i in
    i old-stack array64.get get-type i local-stack array64.get get-type != if false return end
  i end inc end drop
end true end


proc compare-stack-types-types
  // ptr: types-array int: types-length ptr: local-stack ptr: local-stack-length -- bool: is-equal
  ptr int ptr ptr -- bool
in let
  types-array types-length
  local-stack local-stack-length
in
  types-length local-stack-length @64 != if false return end

  0 while dup types-length < do let i in
    i local-stack array64.get get-type i types-array array64.get != if false return end
  i end inc end drop
end true end


proc compare-sub-stack-types-types
  // ptr: types-array int: types-length ptr: local-stack ptr: local-stack-length -- bool: is-equal
  ptr int ptr ptr -- bool
in let
  types-array types-length
  local-stack local-stack-length
in
  types-length local-stack-length @64 > if false return end

  types-length while dup isn-zero do dec let i in
    pop-item let item in
      i types-array array64.get let expected in
        item get-type expected != if false return end
      end
    end
  i end end drop
end true end


proc fput-stack-contents
  // ptr: stack-ptr int: stack-length file-desc: log-stream --
  ptr int file-desc --
in let stack length log-stream in
  length is-zero if
    "<empty>\n" log-stream fputs
    return
  end

  0 while dup length dec < do let i in
    i stack array64.get get-type log-stream fput-int-type " " log-stream fputs
  i end inc end drop

  length dec stack array64.get get-type log-stream fput-int-type
end end


proc fput-types
  // ptr: types-array int: types-length file-desc: log-stream --
  ptr int file-desc --
in let types-array types-length log-stream in
  types-length is-zero if
    "<empty>\n" log-stream fputs
    return
  end

  0 while dup types-length dec < do let i in
    i types-array array64.get log-stream fput-int-type " " log-stream fputs
  i end inc end drop

  types-length dec types-array array64.get log-stream fput-int-type
end end


proc check-stack-types
  // ptr: old-stack ptr: old-address ptr: local-stack ptr: local-stack-length ptr: token-address file-desc: log-stream --
  ptr ptr ptr ptr ptr file-desc --
in let old-stack old-address local-stack local-stack-length token-address log-stream in
  old-stack local-stack local-stack-length compare-stack-types ! if
    LOG.ERR log-stream fputs "Stack contents do not match.\n" log-stream fputs
    old-address log-stream fput-here
    LOG.INFO log-stream fputs old-stack old-stack mlength 8 / log-stream fput-stack-contents log-stream fputnl
    token-address log-stream fput-here
    LOG.INFO log-stream fputs local-stack local-stack-length @64 log-stream fput-stack-contents log-stream fputnl

    ERROR-EXIT-CODE exit drop
  end
end end


proc check-stack-types-types
  // ptr: types-array int: types-length
  ptr int
  // ptr: token-address
  ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // file-desc: log-stream
  file-desc --
in let
  types-array types-length
  token-address
  local-stack local-stack-length
  log-stream
in
  types-array types-length local-stack local-stack-length compare-stack-types-types ! if
    LOG.ERR log-stream fputs "Stack contents do not match.\n" log-stream fputs
    token-address log-stream fput-here
    LOG.INFO log-stream fputs "Expected '" log-stream fputs types-array types-length log-stream fput-types "'.\n" log-stream fputs
    LOG.INFO log-stream fputs "Got '" log-stream fputs local-stack local-stack-length @64 log-stream fput-stack-contents "'.\n" log-stream fputs

    ERROR-EXIT-CODE exit drop
  end
end end


proc check-sub-stack-types-types
  // ptr: types-array int: types-length
  ptr int
  // ptr: token-address
  ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // file-desc: log-stream
  file-desc --
in let
  types-array types-length
  token-address
  local-stack local-stack-length
  log-stream
in
  types-array types-length local-stack local-stack-length compare-sub-stack-types-types ! if
    LOG.ERR log-stream fputs "Stack contents do not match.\n" log-stream fputs
    token-address log-stream fput-here
    LOG.INFO log-stream fputs "Expected '" log-stream fputs types-array types-length log-stream fput-types "'.\n" log-stream fputs
    LOG.INFO log-stream fputs "Got '" log-stream fputs local-stack local-stack-length @64 log-stream fput-stack-contents "'.\n" log-stream fputs

    ERROR-EXIT-CODE exit drop
  end
end end


proc add-intrinsic
  // ptr: token-address ptr: local-stack ptr: local-stack-length file-desc: output-file file-desc: log-stream --
  ptr ptr ptr file-desc file-desc --
in let token-address local-stack local-stack-length output-file log-stream in
  local-stack-length @64 2 < if invalid-usage-of-intrinsic end

  pop-item pop-item let item2 item1 in
    item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
    item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end

    item1 get-mode MODE-IMM = if
      item2 get-mode MODE-IMM = if
        item1 get-arg1 item2 get-arg1 + push-int-immediate

      else item2 get-mode MODE-LOCAL = if
        item1 get-arg1 item2 get-arg1 + push-int-local

      else
        INT-TYPE-INT push-real

        item2          output-file nasm.push-int
        item1 get-arg1 output-file nasm.add-int-immediate
      end end

    else item2 get-mode MODE-IMM = if
      item1 get-mode MODE-LOCAL = if
        item1 get-arg1 item2 get-arg1 + push-int-local
        
      else
        INT-TYPE-INT push-real

        item1          output-file nasm.push-int
        item2 get-arg1 output-file nasm.add-int-immediate
      end

    else
      INT-TYPE-INT push-real

      item2 "rax" output-file nasm.mov-reg-item
      item1       output-file nasm.push-int

      "    add     [rsp], rax\n" output-file fputs
    end end

    item1 stack-item.mfree
    item2 stack-item.mfree
  end
end end


proc get-register-name
  // int: intrinsic -- ptr: register-name int: register-name-length
  int -- ptr int
in let intrinsic in
       intrinsic INTRINSIC-STORE8  = if "al"
  else intrinsic INTRINSIC-STORE16 = if "ax"
  else intrinsic INTRINSIC-STORE32 = if "eax"
  else intrinsic INTRINSIC-STORE64 = if "rax"
  else intrinsic INTRINSIC-LOAD8   = if "al"
  else intrinsic INTRINSIC-LOAD16  = if "ax"
  else intrinsic INTRINSIC-LOAD32  = if "eax"
  else intrinsic INTRINSIC-LOAD64  = if "rax"
  else
    LOG.ERR STDERR fputs "Not a 'load' or 'store' intrinsic.\n" STDERR fputs
    1 exit drop
    NULLPTR 0 // dummy
  end end end end end end end end
end end


proc load-intrinsic
  // ptr: token-address int: intrinsic ptr: local-stack ptr: local-stack-length file-desc: output-file file-desc: log-stream --
  ptr int ptr ptr file-desc file-desc --
  // NOTE: Register is one of 'al', 'ax', 'eax', 'rax'.
in let token-address intrinsic local-stack local-stack-length output-file log-stream in
  local-stack-length @64 1 < if invalid-usage-of-intrinsic end

  pop-item let item in
    item get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end

    item get-mode MODE-LOCAL = if
      intrinsic INTRINSIC-LOAD64 = if item get-arg1 push-@64local return end
      intrinsic INTRINSIC-LOAD8  = if item get-arg1 push-@8local  return end
    end

    item get-mode MODE-GLOBAL = if
      intrinsic INTRINSIC-LOAD64 = if item get-arg1 push-@64global return end
      intrinsic INTRINSIC-LOAD8  = if item get-arg1 push-@8global  return end
    end
    
    INT-TYPE-INT push-real

    intrinsic INTRINSIC-LOAD64 = if    
      item "rbx" output-file nasm.mov-reg-item

      "    push    qword [rbx]\n" output-file fputs
      
    else     
      item "rbx" output-file nasm.mov-reg-item
           "rax" output-file nasm.mov-reg-zero

      "    mov     " output-file fputs intrinsic get-register-name output-file fputs ", [rbx]\n" output-file fputs
      "    push    rax\n" output-file fputs
    end
  end
end end


proc store-intrinsic-sub
  // ptr: value-item ptr: address-item int: address-item-length ptr: token-address int: intrinsic file-desc: output-file file-desc: log-stream --
  ptr ptr int ptr int file-desc file-desc --
in let value-item address-item address-item-length token-address intrinsic output-file log-stream in
  value-item get-mode MODE-REAL = if
    intrinsic INTRINSIC-STORE64 = if
      "    pop     qword [" output-file fputs address-item address-item-length output-file fputs "]\n" output-file fputs
      return
    end
  end

  value-item get-mode MODE-IMM = if
    intrinsic INTRINSIC-STORE64 = if
      value-item get-arg1 is-signed-dword if
        "    mov     qword [" output-file fputs address-item address-item-length output-file fputs
        "], " output-file fputs value-item get-arg1 output-file fputi output-file fputnl
        return
      end
    else intrinsic INTRINSIC-STORE8 = if
      "    mov     byte [" output-file fputs address-item address-item-length output-file fputs
      "], " output-file fputs value-item get-arg1 output-file fputi output-file fputnl
      return
    end end
  end

  value-item get-mode MODE-GLOBAL = if
    intrinsic INTRINSIC-STORE64 != if
      LOG.ERR log-stream fputs "Global variable addresses can not be stored in less than 64 bits.\n" log-stream fputs
      token-address log-stream fput-here
      1 exit drop
    end

    "    mov     qword [" output-file fputs address-item address-item-length output-file fputs
    "], global_" output-file fputs value-item get-arg1 output-file fput-alpha output-file fputnl
    return
  end

  value-item get-mode MODE-DATA = if
    intrinsic INTRINSIC-STORE64 != if
      LOG.ERR log-stream fputs "Data addresses can not be stored in less than 64 bits.\n" log-stream fputs
      token-address log-stream fput-here
      1 exit drop
    end

    "    mov     qword [" output-file fputs address-item address-item-length output-file fputs
      "], data_" output-file fputs value-item get-arg1 output-file fputu output-file fputnl
    return
  end

  value-item   "rax" output-file nasm.mov-reg-item
  "    mov     [" output-file fputs address-item address-item-length output-file fputs
  "], " output-file fputs intrinsic get-register-name output-file fputs output-file fputnl
end end
  


proc store-intrinsic
  // ptr: token-address int: intrinsic ptr: local-stack ptr: local-stack-length file-desc: output-file file-desc: log-stream --
  ptr int ptr ptr file-desc file-desc --
  // NOTE: Register is one of 'bl', 'bx', 'ebx', 'rbx'.
in let token-address intrinsic local-stack local-stack-length output-file log-stream in
  local-stack-length @64 2 < if invalid-usage-of-intrinsic end

  pop-item pop-item let address-item value-item in
    value-item   get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
    address-item get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end

    local-stack local-stack-length output-file local-stack.convert-@local-real

    address-item get-mode MODE-IMM = if
      LOG.ERR log-stream fputs "Store intrinsics do not take immediate value as address argument.\n" log-stream fputs
      token-address log-stream fput-here
      1 exit drop
      
    else address-item get-mode MODE-LOCAL = if
      // TODO: Fix this disgusting hack.
      "    mov     rbx, [local_ptr]\n" output-file fputs

      memory buffer 20 in
        buffer address-item get-arg1 intconvud let buffer-start in
          "rbx + " buffer-start buffer 20 + buffer-start - to-dynamic8-join
        end
      end
      
      let object in
        value-item object object mlength token-address intrinsic output-file log-stream store-intrinsic-sub
        object mfree drop
      end

    else address-item get-mode MODE-GLOBAL = if
      address-item get-arg1 global-label let label in
        value-item label label mlength token-address intrinsic output-file log-stream store-intrinsic-sub
        label mfree drop
      end

    else
      address-item "rbx" output-file nasm.mov-reg-item
      value-item "rbx" token-address intrinsic output-file log-stream store-intrinsic-sub
    end end end
  end
end end


proc geometric-full-binary-intrinsic
  // ptr: token-address ptr: instruction int: instruction-length ptr: local-stack ptr: local-stack-length file-desc: output-file file-desc: log-stream --
  ptr ptr int ptr ptr file-desc file-desc --
in let token-address instruction instruction-length local-stack local-stack-length output-file log-stream in
  local-stack-length @64 2 < if invalid-usage-of-intrinsic end

  pop-item pop-item let item2 item1 in
    item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
    item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end

    INT-TYPE-INT push-real
    INT-TYPE-INT push-real

    item2 "rbx" output-file nasm.mov-reg-item
    item1 "rax" output-file nasm.mov-reg-item
          "rdx" output-file nasm.mov-reg-zero

    "    " output-file fputs instruction instruction-length output-file fputs  "    rbx\n" output-file fputs
    "    push    rax\n" output-file fputs
    "    push    rdx\n" output-file fputs

    item1 stack-item.mfree
    item2 stack-item.mfree
  end
end end


proc geometric-binary-intrinsic
  // ptr: token-address ptr: instruction int: instruction-length ptr: register-name int: register-length ptr: local-stack ptr: local-stack-length file-desc: output-file file-desc: log-stream --
  ptr ptr int ptr int ptr ptr file-desc file-desc --
in let token-address instruction instruction-length register-name register-length local-stack local-stack-length output-file log-stream in
  local-stack-length @64 2 < if invalid-usage-of-intrinsic end

  pop-item pop-item let item2 item1 in
    item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
    item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end

    INT-TYPE-INT push-real

    item2 "rbx" output-file nasm.mov-reg-item
    item1 "rax" output-file nasm.mov-reg-item
          "rdx" output-file nasm.mov-reg-zero

    "    " output-file fputs instruction instruction-length output-file fputs  "    rbx\n" output-file fputs
    "    push    " output-file fputs register-name register-length output-file fputs output-file fputnl

    item1 stack-item.mfree
    item2 stack-item.mfree
  end
end end


proc compile-intrinsic
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // file-desc: log-stream
  file-desc --

  // Compiles an intrinsic in a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let 
  source-name source-file output-file
  line-no char-no
  procedure-name procedure-address
  local-stack local-stack-length
  token-type token-address token-arg
  log-stream
in
       token-arg INTRINSIC-ADD = if token-address local-stack local-stack-length output-file log-stream add-intrinsic
  else token-arg INTRINSIC-SUB = if
    // -------- Intrinsic '-' --------
    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end

      item2 get-mode MODE-IMM = if
        INT-TYPE-INT push-real

        item1              output-file nasm.push-int
        item2 get-arg1 neg output-file nasm.add-int-immediate

      else
        INT-TYPE-INT push-real

        item2 "rax" output-file nasm.mov-reg-item
        item1       output-file nasm.push-int

        "    sub     [rsp], rax\n" output-file fputs
      end

      item1 stack-item.mfree
      item2 stack-item.mfree
    end
    
  else token-arg INTRINSIC-BOR = if
    // -------- Intrinsic '||' --------
    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let item2 item1 in
      item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      
      INT-TYPE-INT push-real

      item2 "rax" output-file nasm.mov-reg-item
      item1       output-file nasm.push-int

      "    or      [rsp], rax\n" output-file fputs
      
      item1 stack-item.mfree
      item2 stack-item.mfree
    end
    
  else token-arg INTRINSIC-BNOT = if
    // -------- Intrinsic '!!' --------

    local-stack-length @64 1 < if invalid-usage-of-intrinsic end

    pop-item let item in
      item get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end

      item get-mode MODE-IMM = if
        item get-arg1 !! push-int-immediate

      else
        INT-TYPE-INT push-real
        
        item output-file nasm.push-int
        "    not     qword [rsp]\n" output-file fputs
      end

      item stack-item.mfree
    end
    
  else token-arg INTRINSIC-MUL      = if token-address "imul" "rax" local-stack local-stack-length output-file log-stream geometric-binary-intrinsic
  else token-arg INTRINSIC-MUL2     = if token-address "imul" "rdx" local-stack local-stack-length output-file log-stream geometric-binary-intrinsic
  else token-arg INTRINSIC-DIV      = if token-address "idiv" "rax" local-stack local-stack-length output-file log-stream geometric-binary-intrinsic
  else token-arg INTRINSIC-MOD      = if token-address "idiv" "rdx" local-stack local-stack-length output-file log-stream geometric-binary-intrinsic
    
  else token-arg INTRINSIC-UMUL     = if token-address  "mul" "rax" local-stack local-stack-length output-file log-stream geometric-binary-intrinsic
  else token-arg INTRINSIC-UMUL2    = if token-address  "mul" "rdx" local-stack local-stack-length output-file log-stream geometric-binary-intrinsic
  else token-arg INTRINSIC-UDIV     = if token-address  "div" "rax" local-stack local-stack-length output-file log-stream geometric-binary-intrinsic
  else token-arg INTRINSIC-UMOD     = if token-address  "div" "rdx" local-stack local-stack-length output-file log-stream geometric-binary-intrinsic
  
  else token-arg INTRINSIC-FULLMUL  = if token-address "imul" local-stack local-stack-length output-file log-stream geometric-full-binary-intrinsic
  else token-arg INTRINSIC-UFULLMUL = if token-address  "mul" local-stack local-stack-length output-file log-stream geometric-full-binary-intrinsic
  else token-arg INTRINSIC-DIVMOD   = if token-address "idiv" local-stack local-stack-length output-file log-stream geometric-full-binary-intrinsic
  else token-arg INTRINSIC-UDIVMOD  = if token-address  "div" local-stack local-stack-length output-file log-stream geometric-full-binary-intrinsic

  else token-arg INTRINSIC-LOAD8   = if token-address token-arg local-stack local-stack-length output-file log-stream load-intrinsic
  else token-arg INTRINSIC-LOAD16  = if token-address token-arg local-stack local-stack-length output-file log-stream load-intrinsic
  else token-arg INTRINSIC-LOAD32  = if token-address token-arg local-stack local-stack-length output-file log-stream load-intrinsic
  else token-arg INTRINSIC-LOAD64  = if token-address token-arg local-stack local-stack-length output-file log-stream load-intrinsic
  
  else token-arg INTRINSIC-STORE8  = if token-address token-arg local-stack local-stack-length output-file log-stream store-intrinsic
  else token-arg INTRINSIC-STORE16 = if token-address token-arg local-stack local-stack-length output-file log-stream store-intrinsic
  else token-arg INTRINSIC-STORE32 = if token-address token-arg local-stack local-stack-length output-file log-stream store-intrinsic
  else token-arg INTRINSIC-STORE64 = if token-address token-arg local-stack local-stack-length output-file log-stream store-intrinsic
        
  else token-arg INTRINSIC-SYSCALL0 = if
    // -------- Intrinsic 'syscall0' --------

    local-stack-length @64 1 < if invalid-usage-of-intrinsic end

    pop-item let op-item in
      op-item   get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      
      INT-TYPE-INT push-real

      op-item   "rax" output-file nasm.mov-reg-item

      "    syscall\n"     output-file fputs
      "    push    rax\n" output-file fputs

      op-item   stack-item.mfree
    end
        
  else token-arg INTRINSIC-SYSCALL1 = if
    // -------- Intrinsic 'syscall1' --------

    local-stack-length @64 2 < if invalid-usage-of-intrinsic end

    pop-item pop-item let op-item arg-item1 in
      arg-item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      op-item   get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      
      INT-TYPE-INT push-real

      op-item   "rax" output-file nasm.mov-reg-item
      arg-item1 "rdi" output-file nasm.mov-reg-item

      "    syscall\n"     output-file fputs
      "    push    rax\n" output-file fputs

      arg-item1 stack-item.mfree
      op-item   stack-item.mfree
    end
        
  else token-arg INTRINSIC-SYSCALL2 = if
    // -------- Intrinsic 'syscall2' --------

    local-stack-length @64 3 < if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item let op-item arg-item2 arg-item1 in
      arg-item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      op-item   get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      
      INT-TYPE-INT push-real

      op-item   "rax" output-file nasm.mov-reg-item
      arg-item2 "rsi" output-file nasm.mov-reg-item
      arg-item1 "rdi" output-file nasm.mov-reg-item

      "    syscall\n"     output-file fputs
      "    push    rax\n" output-file fputs

      arg-item1 stack-item.mfree
      arg-item2 stack-item.mfree
      op-item   stack-item.mfree
    end
        
  else token-arg INTRINSIC-SYSCALL3 = if
    // -------- Intrinsic 'syscall3' --------

    local-stack-length @64 4 < if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item pop-item  let op-item arg-item3 arg-item2 arg-item1 in
      arg-item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item3 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      op-item   get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      
      INT-TYPE-INT push-real

      op-item   "rax" output-file nasm.mov-reg-item
      arg-item3 "rdx" output-file nasm.mov-reg-item
      arg-item2 "rsi" output-file nasm.mov-reg-item
      arg-item1 "rdi" output-file nasm.mov-reg-item

      "    syscall\n"     output-file fputs
      "    push    rax\n" output-file fputs

      arg-item1 stack-item.mfree
      arg-item2 stack-item.mfree
      arg-item3 stack-item.mfree
      op-item   stack-item.mfree
    end

  else token-arg INTRINSIC-SYSCALL4 = if
    // -------- Intrinsic 'syscall4' --------

    local-stack-length @64 5 < if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item pop-item pop-item let op-item arg-item4 arg-item3 arg-item2 arg-item1 in
      arg-item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item3 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item4 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      op-item   get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      
      INT-TYPE-INT push-real

      op-item   "rax" output-file nasm.mov-reg-item
      arg-item4 "r10" output-file nasm.mov-reg-item
      arg-item3 "rdx" output-file nasm.mov-reg-item
      arg-item2 "rsi" output-file nasm.mov-reg-item
      arg-item1 "rdi" output-file nasm.mov-reg-item

      "    syscall\n"     output-file fputs
      "    push    rax\n" output-file fputs

      arg-item1 stack-item.mfree
      arg-item2 stack-item.mfree
      arg-item3 stack-item.mfree
      arg-item4 stack-item.mfree
      op-item   stack-item.mfree
    end

  else token-arg INTRINSIC-SYSCALL5 = if
    // -------- Intrinsic 'syscall5' --------

    local-stack-length @64 6 < if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item pop-item pop-item pop-item let op-item arg-item5 arg-item4 arg-item3 arg-item2 arg-item1 in
      arg-item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item3 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item4 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item5 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      op-item   get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      
      INT-TYPE-INT push-real

      op-item   "rax" output-file nasm.mov-reg-item
      arg-item5 "r8"  output-file nasm.mov-reg-item
      arg-item4 "r10" output-file nasm.mov-reg-item
      arg-item3 "rdx" output-file nasm.mov-reg-item
      arg-item2 "rsi" output-file nasm.mov-reg-item
      arg-item1 "rdi" output-file nasm.mov-reg-item

      "    syscall\n"     output-file fputs
      "    push    rax\n" output-file fputs

      arg-item1 stack-item.mfree
      arg-item2 stack-item.mfree
      arg-item3 stack-item.mfree
      arg-item4 stack-item.mfree
      arg-item5 stack-item.mfree
      op-item   stack-item.mfree
    end

  else token-arg INTRINSIC-SYSCALL6 = if
    // -------- Intrinsic 'syscall6' --------

    local-stack-length @64 7 < if invalid-usage-of-intrinsic end

    pop-item pop-item pop-item pop-item pop-item pop-item pop-item let op-item arg-item6 arg-item5 arg-item4 arg-item3 arg-item2 arg-item1 in
      arg-item1 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item2 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item3 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item4 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item5 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      arg-item6 get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      op-item   get-type INT-TYPE-INT != if invalid-usage-of-intrinsic end
      
      INT-TYPE-INT push-real

      op-item   "rax" output-file nasm.mov-reg-item
      arg-item6 "r9"  output-file nasm.mov-reg-item
      arg-item5 "r8"  output-file nasm.mov-reg-item
      arg-item4 "r10" output-file nasm.mov-reg-item
      arg-item3 "rdx" output-file nasm.mov-reg-item
      arg-item2 "rsi" output-file nasm.mov-reg-item
      arg-item1 "rdi" output-file nasm.mov-reg-item

      "    syscall\n"     output-file fputs
      "    push    rax\n" output-file fputs

      arg-item1 stack-item.mfree
      arg-item2 stack-item.mfree
      arg-item3 stack-item.mfree
      arg-item4 stack-item.mfree
      arg-item5 stack-item.mfree
      arg-item6 stack-item.mfree
      op-item   stack-item.mfree
    end

  else
    LOG.TODO log-stream fputs "Intrinsic '" log-stream fputs token-arg log-stream fput-intrinsic "' is not implemented yet.\n" log-stream fputs
    token-address log-stream fput-here
    procedure-name procedure-address log-stream fput-inside-procedure
    ERROR-EXIT-CODE exit drop
  end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end end
end end


proc compile-keyword
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr ptr file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // int: token-type ptr: token-address [int|ptr]: token-arg
  int ptr int
  // ptr: levels-list ptr: level-id-counter
  ptr ptr
  // ptr: local-memory-end
  ptr 
  // ptr: let-names ptr: let-addresses ptr: let-vars-length
  ptr ptr ptr
  // ptr: branch-active
  ptr
  // ptr: output-array int: output-length
  ptr int
  // file-desc: log-stream
  file-desc
  // ptr: local-memory-max
  ptr
  --
  // bool: end-of-procedure
  bool
in let
  source-name source-file output-file
  line-no char-no
  macro-names macro-tokens macros-length
  procedure-name procedure-address
  local-stack local-stack-length
  extended-array extended-start extended-end
  token-type token-address token-arg
  levels-list level-id-counter
  local-memory-end
  let-names let-addresses let-vars-length
  branch-active
  output-array output-length
  log-stream
  local-memory-max
in
  token-arg KEYWORD-END = if
    // -------- Keyword 'end' --------

    levels-list list64.length is-zero if
      // -------- End of 'proc' --------

      // Branch should not be cut before the main procedure return.
      token-address "finish a procedure" compile-procedure.check-branch-here

      local-stack local-stack-length output-file local-stack.convert-last-items-real

      // Check if the stack is correct.
      output-array output-length
      token-address
      local-stack local-stack-length
      log-stream
      check-stack-types-types
      
      true return
    end

    levels-list list64.pop-last let level in
      level @64 level 8 + @64 let start-keyword start-address in                
        start-keyword KEYWORD-IF = if
          // -------- End of 'if' --------
          level 16 + @64 level 24 + @64 let start-id start-stack in
            branch-active @8 is-zero if
              // Overwrite the contents of the local-stack with the old contents.
              start-stack local-stack local-stack-length local-stack.overwrite

              // Reset the branch.
              0xff branch-active !8
            end
            
            local-stack local-stack-length output-file local-stack.convert-last-items-real

            // Check for the stack changes.
            start-stack start-address local-stack local-stack-length token-address log-stream check-stack-types

            start-id output-file nasm.level

            // Deallocate 'start-stack'.
            start-stack _local-stack.mfree
          end

        else start-keyword KEYWORD-ELSE = if
          // -------- End of 'else' --------

          // Branch should not be cut before the end of else.
          token-address "finish an 'if-else'" compile-procedure.check-branch-here

          level 16 + @64 level 24 + @64 level 32 + @64 let else-address start-id start-stack in
            local-stack local-stack-length output-file local-stack.convert-last-items-real

            // Check for the stack changes.
            start-stack else-address local-stack local-stack-length token-address log-stream check-stack-types

            start-id output-file nasm.level

            // Deallocate 'else-address' and 'start-stack'.
            else-address mfree drop
            start-stack _local-stack.mfree
          end

        else start-keyword KEYWORD-WHILE = if
          // -------- End of 'while' --------

          LOG.ERR  log-stream fputs "You probably forgot a 'do' after 'while'.\n" log-stream fputs
          LOG.INFO log-stream fputs "A 'while-do' loop can be created as: 'while <condition> do <code> end'\n" log-stream fputs
          
          token-address log-stream fput-here
          start-address compile-procedure.show-here
          
          ERROR-EXIT-CODE exit drop

        else start-keyword KEYWORD-DO = if
          // -------- End of 'do' --------

          // Branch should not be cut before the end of do.
          token-address "finish a while-do loop" compile-procedure.check-branch-here

          level 16 + @64 level 24 + @64 level 32 + @64 level 40 + @64 level 48 + @64 level 56 + @64 let
            while-level-id do-address unbroken-end-id broken-end-id while-stack do-stack
          in
            // Check for the stack changes.
            while-stack start-address local-stack local-stack-length token-address log-stream check-stack-types

            // Overwrite the contents of the local-stack.
            do-stack local-stack local-stack-length local-stack.overwrite

            while-level-id  output-file nasm.jump-level
            unbroken-end-id output-file nasm.level
            broken-end-id   output-file nasm.level

            // Deallocate 'do-address', 'while-stack' and 'do-stack'.
            do-address mfree drop
            while-stack _local-stack.mfree
            do-stack _local-stack.mfree
          end

        else start-keyword KEYWORD-LET = if
          // -------- End of 'let' --------

          level 16 + @64 level 24 + @64 let new-names old-local-memory-end in
            0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
              name mlength 1 = if name @8 '_' != else true end if
                name let-names let-addresses let-vars-length str-map64.remove-dstr ! if
                  LOG.ERR  log-stream fputs "Could not find the 'let' variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs
                  log-stream report-bug
                  start-address compile-procedure.show-here
                  ERROR-EXIT-CODE exit drop
                end
              end
            end i end inc end drop

            old-local-memory-end local-stack local-stack-length output-file local-stack.convert-deleted-real

            old-local-memory-end local-memory-end !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end

        else start-keyword KEYWORD-MEMORY = if
          // -------- End of 'memory' --------

          level 16 + @64 level 24 + @64 let new-names old-local-memory-end in
            0 while dup new-names mlength 8 / < do let i in i 8 * new-names + @64 let name in
              name let-names let-addresses let-vars-length str-map64.remove-dstr ! if
                LOG.ERR  log-stream fputs "Could not find the local variable name '" log-stream fputs name name mlength log-stream fputs "'.\n" log-stream fputs

                log-stream report-bug
                token-address log-stream fput-here
                start-address compile-procedure.show-here
                ERROR-EXIT-CODE exit drop
              end
            end i end inc end drop

            old-local-memory-end local-stack local-stack-length output-file local-stack.convert-deleted-real

            old-local-memory-end local-memory-end !64

            // Deallocate 'new-names'.
            new-names mfree drop
          end

        else
          LOG.TODO log-stream fputs "'end' after keyword '" log-stream fputs start-keyword log-stream fput-keyword "' is not implemented yet.\n" log-stream fputs
          token-address log-stream fput-here
          start-address compile-procedure.show-here
          ERROR-EXIT-CODE exit drop
        end end end end end end

        // Deallocate 'start-address'.
        start-address mfree drop
      end

      // Deallocate level object.
      level mfree drop
    end

  else token-arg KEYWORD-IF = if
    // -------- Keyword 'if' --------
    // <condition> if <any> end
    // <condition> if <any> else <any> end

    // TODO: These are not implemented yet.
    // <condition> if <any> (elif <condition> if <any>)* end

    // Level structure:
    //  0- 7 -> KEYWORD-IF
    //  8-15 -> Starter address
    // 16-23 -> Level ID
    // 24-31 -> Old stack

    // Branch should not be cut before 'else'.
    token-address "before 'if'" compile-procedure.check-branch-here

    local-stack-length @64 is-zero if
      LOG.ERR log-stream fputs "'if' requires a bool, there was no items in the stack.\n" log-stream fputs
      token-address compile-procedure.show-here
      ERROR-EXIT-CODE exit drop
    end

    pop-item let item in
      item get-type INT-TYPE-BOOL != if
        LOG.ERR log-stream fputs "'if' requires a bool\n" log-stream fputs
        token-address compile-procedure.show-here
        ERROR-EXIT-CODE exit drop
      end

      item output-file nasm.convert-bool-to-real

      item stack-item.mfree
    end

    local-stack local-stack-length local-stack.copy let copy-stack in
      32 malloc let obj in
        obj "creating a level object for 'if'" compile-procedure.check-null-here

        compile-procedure.new-level-id let level-id in
          KEYWORD-IF           obj      !64
          token-address dcopy  obj 8  + !64
          level-id             obj 16 + !64
          copy-stack           obj 24 + !64

          obj levels-list list64.append

          "    pop     rax\n"      output-file fputs
          "    test    rax, rax\n" output-file fputs
          level-id output-file nasm.jump-zero-level
        end
      end
    end

  else token-arg KEYWORD-ELSE = if
    // -------- Keyword 'else' --------
    // <condition> if <any> else <any> end

    // Level structure:
    //  0- 7 -> KEYWORD-ELSE
    //  8-15 -> If address
    // 16-23 -> Else address
    // 24-31 -> Level ID
    // 32-39 -> Old stack

    // Branch should not be cut before 'else'.
    token-address "before 'else'" compile-procedure.check-branch-here

    levels-list list64.length is-zero if
      LOG.ERR log-stream fputs "'else' requires 'if'.\n" log-stream fputs
      token-address compile-procedure.show-here
      ERROR-EXIT-CODE exit drop
    end

    local-stack local-stack-length output-file local-stack.convert-last-items-real

    levels-list list64.pop-last let level in
      level @64 level 8 + @64 let old-keyword old-address in
        old-keyword old-address token-address "before 'else'" KEYWORD-IF compile-procedure.check-level-here

        level 16 + @64 level 24 + @64 let start-id start-stack in
          local-stack local-stack-length local-stack.copy let copy-stack in
            // Overwrite the contents of the local-stack.
            start-stack local-stack local-stack-length local-stack.overwrite

            compile-procedure.new-level-id let level-id in
              level-id output-file nasm.jump-level
              start-id output-file nasm.level

              40 malloc let new-level in
                new-level "creating a level object for 'else'" compile-procedure.check-null-here

                KEYWORD-ELSE         new-level      !64
                old-address          new-level 8  + !64
                token-address dcopy  new-level 16 + !64
                level-id             new-level 24 + !64
                copy-stack           new-level 32 + !64

                new-level levels-list list64.append
              end
            end
          end

          // Deallocate 'start-stack'.
          start-stack _local-stack.mfree
        end
      end

      // Deallocate level object.
      level mfree drop
    end

  else token-arg KEYWORD-WHILE = if
    // -------- Keyword 'while' --------
    // while <condition> do <any> end

    // Level structure:
    //  0- 7 -> KEYWORD-WHILE
    //  8-15 -> Starter address 
    // 16-23 -> Level ID
    // 24-31 -> Old stack

    // Branch should not be cut before 'while'.
    token-address "call 'while'" compile-procedure.check-branch-here

    local-stack local-stack-length local-stack.copy let copy-stack in
      copy-stack "creating a level object for 'while'" compile-procedure.check-null-here

      compile-procedure.new-level-id let level-id in
        local-stack local-stack-length output-file local-stack.convert-last-items-real

        level-id output-file nasm.level

        32 malloc let new-level in
          new-level "creating a level object for 'while'" compile-procedure.check-null-here

          KEYWORD-WHILE        new-level      !64
          token-address dcopy  new-level 8  + !64
          level-id             new-level 16 + !64
          copy-stack           new-level 24 + !64

          new-level levels-list list64.append
        end
      end
    end

  else token-arg KEYWORD-DO = if
    // -------- Keyword 'do' --------
    // while <condition> do <any> end

    // TODO: These are not implemented yet.
    // while <condition> do <any> [else <any>] end

    // Level structure:
    //  0- 7 -> KEYWORD-DO
    //  8-15 -> While address
    // 16-23 -> While label level ID
    // 24-31 -> Do address
    // 32-39 -> Unbroken loop end level ID
    // 40-47 -> Broken loop end level ID
    // 48-55 -> While stack
    // 56-63 -> Do stack

    // Branch should not be cut between 'while' and 'do'.
    token-address "call 'do'" compile-procedure.check-branch-here

    // Check if the local stack contains any item.
    local-stack-length @64 is-zero if
      LOG.ERR log-stream fputs "'do' requires a bool, there was no items in the stack.\n" log-stream fputs
      token-address compile-procedure.show-here
      ERROR-EXIT-CODE exit drop
    end

    local-stack local-stack-length output-file local-stack.convert-last-items-real
    
    // Remove the bool value from the local-stack.
    pop-item let item in
      item get-type INT-TYPE-BOOL != if        
        LOG.ERR log-stream fputs "'do' requires a bool.\n" log-stream fputs
        token-address compile-procedure.show-here
        ERROR-EXIT-CODE exit drop
      end
      
      item stack-item.mfree
    end

    // Get the 'while' level.
    levels-list list64.pop-last let old-level in
      old-level @64 old-level 8 + @64 let old-keyword old-address in
        // Check if the level type is 'while'.
        old-keyword old-address token-address "before 'do'" KEYWORD-WHILE compile-procedure.check-level-here

        old-level 16 + @64 old-level 24 + @64 let old-level-id old-stack in
          compile-procedure.new-level-id compile-procedure.new-level-id let unbroken-end-level-id broken-end-level-id in
            compile-procedure.new-level-id compile-procedure.new-level-id let unbroken-end-id broken-end-id in
              "    pop     rax\n"      output-file fputs
              "    test    rax, rax\n" output-file fputs
              unbroken-end-id output-file nasm.jump-zero-level

              local-stack local-stack-length local-stack.copy let copy-stack in
                copy-stack "copying the stack for 'do'" compile-procedure.check-null-here

                64 malloc let new-level in
                  new-level "creating a level object for 'do' after 'while'" compile-procedure.check-null-here

                  KEYWORD-DO               new-level      !64
                  old-address              new-level 8  + !64
                  old-level-id             new-level 16 + !64
                  token-address dcopy      new-level 24 + !64
                  unbroken-end-id          new-level 32 + !64
                  broken-end-id            new-level 40 + !64
                  old-stack                new-level 48 + !64
                  copy-stack               new-level 56 + !64
                  new-level levels-list list64.append
                end
              end
            end
          end
        end
      end
    end        

  else token-arg KEYWORD-BREAK = if 
    // -------- Keyword 'break' -------
    // break

    // Branch should not be cut before 'break'.
    token-address "call 'break'" compile-procedure.check-branch-here

    levels-list list64.end-addr while dup levels-list list64.array-addr > do 8 - let level-addr in
      level-addr @64 @64 level-addr @64 8 + @64 let old-keyword old-address in
        old-keyword KEYWORD-DO = if
          level-addr @64 32 + @64 level-addr @64 24 + @64 level-addr @64 56 + @64 let broken-end-id do-address do-stack in
            // Check for the stack contents.
            do-stack do-address local-stack local-stack-length token-address log-stream check-stack-types
            
            local-stack local-stack-length output-file local-stack.convert-last-items-real

            broken-end-id output-file nasm.jump-level
          end

          0 branch-active !8
          0 break
        end
      end
    level-addr end end drop

    branch-active @8 isn-zero if
      LOG.ERR log-stream fputs "Expected a 'while-do' structure before 'break'.\n" log-stream fputs
      token-address compile-procedure.show-here
      ERROR-EXIT-CODE exit drop
    end

  else token-arg KEYWORD-MEMORY = if
    // -------- Keyword 'memory' -------
    // memory <name> <size> in <any> end

    // TODO: These are not implemented yet.
    // memory <name> <size> (and <name> <size>)* in <any> end

    // Level structure:
    //  0- 7 -> KEYWORD-MEMORY
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-31 -> Old local-memory-end

    // Branch should not be cut before 'memory'.
    token-address "call 'memory'" compile-procedure.check-branch-here

    // New names are stored in new-names and new-names-length queue. When the 'end' of 'memory' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) in
      16 list64.init let dynamic in
        dynamic "creating list dynamic object for 'memory'" compile-procedure.check-null-here

        dynamic new-names-list !64
      end

      // TODO: Add 'and' keyword.
      // TODO: Add proper pre-compilation for memory size.

      // Get the variable name.
      "a local variable name after 'memory'" false compile-procedure.get-next-token

      let memory-name-type memory-name-address memory-name-arg in
        // The token after 'memory' should be a 'name'.
        memory-name-type memory-name-address "after 'memory' for local variable name" TYPE-NAME compile-procedure.check-type-here

        // Get the variable size.
        "a local variable size after 'memory'" true compile-procedure.get-next-token

        let memory-size-type memory-size-address memory-size-arg in
          // The token after variable name should be an 'integer'.
          memory-size-type memory-size-address "after 'memory' for local variable size" TYPE-INTEGER compile-procedure.check-type-here

          "an 'end' after 'memory'" true compile-procedure.get-next-token

          let memory-end-type memory-end-address memory-end-arg in
            // The token after variable size should be a 'keyword'.
            memory-end-type memory-end-address "after 'memory'" TYPE-KEYWORD compile-procedure.check-type-here

            memory-end-arg KEYWORD-AND = if
              LOG.TODO log-stream fputs "'and' after 'memory' for local variable allocation is not implemented yet.\n" log-stream fputs
              memory-end-address compile-procedure.show-here
              ERROR-EXIT-CODE exit drop
            end

            // Check if the keyword is 'in'.
            memory-end-arg memory-end-address "after 'memory'" KEYWORD-IN compile-procedure.check-keyword-here

            memory-name-arg new-names-list list64.append

            INT-TYPE-INT MODE-LOCAL stack-item.create let replace-item in
              local-memory-end @64 replace-item set-arg1
              
              memory-name-arg replace-item let-names let-addresses let-vars-length str-map64.set-dstr if
                LOG.ERR log-stream fputs "Local variable '" log-stream fputs memory-name-arg memory-name-arg mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                memory-name-address compile-procedure.show-here
                ERROR-EXIT-CODE exit drop
              end

              local-memory-end @64 memory-size-arg + local-memory-end !64
            end

            // Deallocate 'memory-end-address'.
            memory-end-address mfree drop
          end

          // Deallocate 'memory-size-address'.
          memory-size-address mfree drop
        end

        // Deallocate 'memory-name-address'.
        memory-name-address mfree drop
      end

      local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

      32 malloc let new-level in
        new-level "creating a level object for 'memory'" compile-procedure.check-null-here

        KEYWORD-MEMORY                   new-level      !64
        token-address dcopy              new-level  8 + !64
        new-names-list list64.copy-array new-level 16 + !64
        local-memory-end @64             new-level 24 + !64

        new-level levels-list list64.append
      end

      // Deallocate 'new-names-list' but keep the 'memory' variable names.
      new-names-list list64.mfree drop
    end

  else token-arg KEYWORD-LET = if
    // -------- Keyword 'let' --------
    // let <name>* in <any> end

    // Level structure:
    //  0- 7 -> KEYWORD-LET
    //  8-15 -> Starter address
    // 16-23 -> New names
    // 24-32 -> Old local-memory-end

    // Branch should not be cut before 'let'.
    token-address "call 'let'" compile-procedure.check-branch-here

    // New names are stored in new-names and new-names-length queue. When the 'end' of 'let' is reached, new names are deleted from the namespace.
    memory new-names-list sizeof(ptr) in
      16 list64.init let dynamic in
        dynamic "creating list dynamic object for 'let'" compile-procedure.check-null-here

        dynamic new-names-list !64
      end

      // Get the names of the 'let' variables.
      while true do
        // Get the name of the variable.
        "a 'name' for 'let' variable" false compile-procedure.get-next-token

        let new-token-type new-token-address new-token-arg in
          new-token-type TYPE-KEYWORD = if
            // If token is a keyword, it must be a 'in' keyword.
            new-token-arg new-token-address "after 'let'" KEYWORD-IN compile-procedure.check-keyword-here

            // Deallocate 'new-token-address'.
            new-token-address mfree drop

            // If the token is a 'in' keyword, break the loop.
            break
          end

          // Check the type of the token.
          new-token-type new-token-address "after 'let'" TYPE-NAME compile-procedure.check-type-here

          // TODO: Change the way that the variables are stored, so that we can also store their addresses.
          new-token-arg new-names-list list64.append

          // Deallocate 'new-token-address'.
          new-token-address mfree drop
        end
      end

      local-memory-end @64 let old-local-memory-end in
        // This loop is separated from the one above, since this loop must run in the reverse order.
        new-names-list list64.length while dup isn-zero do dec let i in
          local-stack-length @64 is-zero if
            LOG.ERR log-stream fputs "Expected a data before 'let' variable, but the stack was empty.\n" log-stream fputs
            token-address compile-procedure.show-here
            ERROR-EXIT-CODE exit drop
          end

          pop-item i new-names-list list64.get let item variable-name in
            variable-name mlength 1 = if variable-name @8 '_' = else false end if
              item get-mode MODE-REAL = if
                "    pop     r15\n" output-file fputs
              end
              
            else
              item get-mode MODE-IMM         =
              item get-mode MODE-GLOBAL      = |
              item get-mode MODE-@LOCALCONST = |
              item get-mode MODE-LOCAL       = |
              item get-mode MODE-DATA        = | if
                   
                item stack-item.copy
                
              else
                local-stack local-stack-length output-file local-stack.convert-last-items-real
                item output-file nasm.convert-item-to-real

                "    mov     r15, [local_ptr]\n" output-file fputs
                local-memory-end @64 is-zero if
                  "    pop     qword [r15]\n" output-file fputs
                else
                  "    pop     qword [r15 + " output-file fputs local-memory-end @64 output-file fputu "]\n" output-file fputs
                end
                
                item get-type MODE-@LOCALCONST stack-item.create let replace-item in
                  local-memory-end @64 replace-item set-arg1

                  replace-item
                end

                local-memory-end @64 8 + local-memory-end !64
              end
              
              let replace-item in
                variable-name replace-item let-names let-addresses let-vars-length str-map64.set-dstr if
                  LOG.ERR log-stream fputs "'let' variable '" log-stream fputs variable-name dup mlength log-stream fputs "' was already defined before.\n" log-stream fputs

                  // TODO: This does not show the address of the 'let' variable. This should be changed.
                  token-address compile-procedure.show-here
                  ERROR-EXIT-CODE exit drop
                end
              end

              local-memory-end @64 8 + local-memory-end !64
            end
          end
        i end end drop

        local-memory-max @64 local-memory-end @64 max2 local-memory-max !64

        32 malloc let new-level in
          new-level "creating a level object for 'let'" compile-procedure.check-null-here

          KEYWORD-LET                      new-level      !64
          token-address dcopy              new-level  8 + !64
          new-names-list list64.copy-array new-level 16 + !64
          old-local-memory-end             new-level 24 + !64

          new-level levels-list list64.append
        end
      end

      // Deallocate 'new-names-list' but keep the 'let' variable names.
      new-names-list list64.mfree drop
    end

  else token-arg KEYWORD-RETURN = if
    // -------- Keyword 'return' --------

    // Branch should not be cut before 'return'.
    token-address "call 'return'" compile-procedure.check-branch-here

    local-stack local-stack-length output-file local-stack.convert-last-items-real

    output-array output-length
    token-address
    local-stack local-stack-length
    log-stream
    check-stack-types-types

    "    jmp     .return\n" output-file fputs

    0 branch-active !8

  else token-arg KEYWORD-CAST = if
    // -------- Keyword 'cast' --------

    // Branch should not be cut before 'cast'.
    token-address "cast" compile-procedure.check-branch-here

    // Get the variable name.
    "a local variable name after 'memory'" false compile-procedure.get-next-token

    let type-type type-address type-arg in
      // The token after 'cast' should be an 'intrinsic type'.
      type-type type-address "after 'cast'" TYPE-INT-TYPE compile-procedure.check-type-here

      local-stack local-stack-length output-file local-stack.convert-last-items-real

      // Change the type of the last item.
      local-stack-length @64 dec local-stack array64.get let item in
        type-arg item set-type
      end

      // Deallocate 'type-address'.
      type-address mfree drop
    end   

  else
    LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
    token-address compile-procedure.show-here
    ERROR-EXIT-CODE exit drop
  end end end end end end end end end end
end false end


proc compile-procedure
  // ptr: source-name file-desc: source-file file-desc: output-file
  ptr file-desc file-desc
  // ptr: line-no ptr: char-no
  ptr ptr
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names-array ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // ptr: procedure-name ptr: procedure-address
  ptr ptr
  // ptr: local-stack ptr: local-stack-length
  ptr ptr
  // ptr: extended-array ptr: extended-start ptr: extended-end
  ptr ptr ptr
  // ptr: output-array int: output-length
  ptr int
  // file-desc: log-stream -- 
  file-desc --
  // local-memory-max: int
  int
  
  // Compiles a Corth procedure.
  // Compilation warning and errors are dumped to log-stream.
in let 
  source-name source-file output-file
  line-no char-no
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names macro-tokens macros-length
  procedure-name procedure-address
  local-stack local-stack-length
  extended-array extended-start extended-end
  output-types-array output-types-length
  log-stream
in
    
  "proc_" output-file fputs procedure-name output-file fput-alpha ":\n" output-file fputs

  memory levels-list      sizeof(ptr)      in

  // level-id-counter allows to create unique IDs for level labels.
  memory level-id-counter sizeof(int)      in

  // let-names, let-addresses and let-vars-length create a str_map64.
  memory let-names        LET-MAX-COUNT    in
  memory let-addresses    LET-MAX-COUNT    in
  memory let-vars-length  sizeof(int)      in

  // local-memory-end keeps track of the first available-dstr position on the local memory.
  memory local-memory-end sizeof(int)      in

  // local-memory-max keeps track of the maximum length of the local memory, to later allocate enough space.
  memory local-memory-max sizeof(int)      in

  // branch-active keeps track of if the branch of the code ended.
  memory branch-active    1                in

    16 list64.init let dynamic in
      dynamic "creating a list dynamic object" compile-procedure.check-null

      dynamic levels-list !64
    end

    0 level-id-counter !64
    0 let-vars-length  !64
    0 local-memory-end !64
    0 local-memory-max !64
    
    0xff branch-active !8

    while true do
      "end of procedure or procedure definition" true compile-procedure.get-next-token

      let token-type token-address token-arg in
        // -- debug --
        // LOG.INFO log-stream fputs token-type token-arg log-stream fput-token log-stream fputnl
        // token-address log-stream fput-here
        // ";; " output-file fputs token-type token-arg output-file fput-token output-file fputnl

        token-type TYPE-INTEGER = if
          // -------- Constant integer --------

          // Branch should not be cut before integer immediate.
          token-address "push an integer" compile-procedure.check-branch-here

          token-arg push-int-immediate

        else token-type TYPE-STRING = if
          // -------- Strings --------

          // Branch should not be cut before string immediate.
          token-address "push a string" compile-procedure.check-branch-here

          data-definitions-list list64.length push-data
          token-arg mlength dec               push-int-immediate

          token-arg data-definitions-list list64.append

        else token-type TYPE-NAME = if
          // -------- Names --------

          // Branch should not be cut before name.
          token-address "calling a name" compile-procedure.check-branch-here
            
          token-arg let-names let-addresses let-vars-length str-map64.get-dstr if
            // -------- local variables --------
            
            let replace-item in
              replace-item stack-item.copy push-item
            end
            
          else drop token-arg global-names-array global-sizes-array globals-length str-map64.get-dstr if
            // -------- global 'memory' variables --------

            let address in
              INT-TYPE-INT MODE-GLOBAL stack-item.create let item in
                token-arg item set-arg1

                item push-item
              end
            end

          else drop token-arg proc-names-array proc-names-array procs-length @64 8 * + str-sorted8.available-dstr if
            // -------- 'proc' calls --------
            
            let name-address in name-address proc-names-array - let delta in
              delta proc-inputs-array + delta proc-outputs-array + let input-address output-address in
                local-stack local-stack-length output-file local-stack.convert-last-items-real

                input-address @64 input-address @64 mlength 8 /
                token-address
                local-stack local-stack-length
                log-stream
                check-sub-stack-types-types

                0 while dup output-address @64 mlength 8 / < do let i in                    
                  i output-address @64 array64.get let output in
                    output push-real
                  end
                i end inc end drop

                compile-procedure.new-level-id let level-id in
                  "    xchg    rsp, [call_ptr]\n"              output-file fputs         
                  "    push    .level_"                        output-file fputs level-id output-file fputu output-file fputnl
                  "    push    qword [local_ptr]\n"            output-file fputs         
                  "    add     qword [local_ptr], "            output-file fputs local-memory-end @64 output-file fputu output-file fputnl
                  "    xchg    rsp, [call_ptr]\n"              output-file fputs         
                  "    jmp     proc_"                          output-file fputs token-arg output-file fput-alpha output-file fputnl
                  level-id output-file nasm.level
                end
              end
            end end
            
          else drop
            // TODO: Add Levenshtein distance algoritm to show the nearest matchs; which can be definitions, macros, procedures, keywords and intrinsics.
            
            LOG.ERR log-stream fputs "Name '" log-stream fputs token-arg token-arg mlength log-stream fputs "' is not defined as a local variable or a macro.\n" log-stream fputs
            token-address compile-procedure.show-here
            ERROR-EXIT-CODE exit drop
          end end end

        else token-type TYPE-INTRINSIC = if
          // -------- Intrinsics --------

          // Branch should not be cut before calling an intrinsic.
          token-address "calling an intrinsic" compile-procedure.check-branch-here
          
          source-name source-file output-file
          line-no char-no
          procedure-name procedure-address
          local-stack local-stack-length
          token-type token-address token-arg
          log-stream
          compile-intrinsic

        else token-type TYPE-KEYWORD = if          
          // -------- Keywords --------

          source-name source-file output-file
          line-no char-no
          macro-names macro-tokens macros-length
          procedure-name procedure-address
          local-stack local-stack-length
          extended-array extended-start extended-end
          token-type token-address token-arg
          levels-list level-id-counter
          local-memory-end
          let-names let-addresses let-vars-length
          branch-active
          output-types-array output-types-length
          log-stream
          local-memory-max
          compile-keyword if local-memory-max @64 return end

        else
          LOG.ERR log-stream fputs "Unexpected type while expecting a keyword, an intrinsic, a string or an integer, got '" log-stream fputs token-type log-stream fput-type "'.\n" log-stream fputs
          token-address compile-procedure.show-here
          ERROR-EXIT-CODE exit drop
        end end end end end
        
        // Deallocate the space allocated for token-address.
        token-address mfree drop
      end
    end

    // Deallocate 'levels-list'.
    levels-list list64.mfree-deep drop
  end end end end end end end end
end 0 end // dummy return


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.get-next-token let
  expect-address expect-length extend-macros
in
  // str: expect-message bool: extend-macros --
  // int: token-type ptr: address [int|ptr]: arg

  source-name source-file
  line-no char-no
  extended-array extended-start extended-end
  macro-names macro-tokens macros-length
  log-stream extend-macros get-next-token ! if
    LOG.ERR log-stream fputs "Reached EOF while expecting " log-stream fputs expect-address expect-length log-stream fputs log-stream fputnl
    ERROR-EXIT-CODE exit drop
  end
end endmacro
 

// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-type let _token_type_ expect-address expect-length expected-token-type in
  expected-token-type _token_type_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-type log-stream fput-type  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_type_ log-stream fput-type "'.\n" log-stream fputs
    
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-type-here let _token_type_ _token_addr_ expect-address expect-length expected-token-type in
  expected-token-type _token_type_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-type log-stream fput-type  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_type_ log-stream fput-type "'.\n" log-stream fputs

    _token_addr_ log-stream fput-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-keyword let _token_arg_ expect-address expect-length expected-token-arg in
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs
    
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-keyword-here let _token_arg_ _token_addr_ expect-address expect-length expected-token-arg in
  expected-token-arg _token_arg_ != if
    LOG.ERR log-stream fputs "Expected a '" log-stream fputs expected-token-arg log-stream fput-keyword  "' " log-stream fputs expect-address expect-length log-stream fputs ", got '" log-stream fputs _token_arg_ log-stream fput-keyword "'.\n" log-stream fputs

    _token_addr_ log-stream fput-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-null let expect-address expect-length in
  is-null if
    LOG.ERR log-stream fputs "malloc failed while " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs
    
    ERROR-EXIT-CODE exit drop
  end
end endmacro


// NOTE: Designed to be used inside 'compile-file'. Variable names used inside this macro should not be changed as they come from 'compile-file'.
macro compile-file.check-null-here let expect-address expect-length in
  is-null if
    LOG.ERR log-stream fputs "malloc failed while " log-stream fputs expect-address expect-length log-stream fputs ".\n" log-stream fputs

    token-address log-stream fput-here
    ERROR-EXIT-CODE exit drop
  end
end endmacro


proc compile-file
  // ptr: source-name file-desc: output-file
  ptr file-desc
  // ptr: data-definitions-list
  ptr
  // ptr: global-names-array ptr: global-sizes-array ptr: globals-length 
  ptr ptr ptr
  // ptr: proc-names-array ptr: proc-inputs-array ptr: proc-outputs-array ptr: procs-length
  ptr ptr ptr ptr
  // ptr: macro-names ptr: macro-tokens-array ptr: macros-length
  ptr ptr ptr
  // include-paths-set
  ptr
  // libraries-set
  ptr 
  // file-desc: log-stream
  file-desc --
  
  // Compiles a Corth source file.
  // Compilation warning and errors are dumped to log-stream.

  // TODO: Add called-from to improve debugging.
  // TODO: Add called-from to improve debugging.
in let
  source-name output-file
  data-definitions-list
  global-names-array global-sizes-array globals-length
  proc-names-array proc-inputs-array proc-outputs-array procs-length
  macro-names macro-tokens macros-length
  include-paths-set
  libraries-set
  log-stream
in
  // Check if the library was included already.
  source-name libraries-set str-set8.add ! if return end
  
  // Open the source file.
  source-name fopen-r let source-file in
    // Check if the source is opened.
    source-file isn-pos if
      LOG.ERR log-stream fputs "Could not open source file '" log-stream fputs source-name source-name mlength dec log-stream fputs "'\n" log-stream fputs
      ERROR-EXIT-CODE exit drop
    end

    memory extended-array  EXTENDED-MAX-LENGTH in
    memory extended-start  sizeof(int)         in
    memory extended-end    sizeof(int)         in
           
    memory line-no         sizeof(int)         in
    memory char-no         sizeof(int)         in

      // Reset extended-tokens.
      0 extended-start !64
      0 extended-end   !64

      // Reset line-no and char-no variables.
      1 line-no !64
      0 char-no !64

      // Get next token and check if there is one available-dstr.
      while source-name source-file line-no char-no extended-array extended-start extended-end macro-names macro-tokens macros-length log-stream true get-next-token do
        let token-type token-address token-arg in
          token-type token-address "" TYPE-KEYWORD compile-file.check-type-here
                
          // -------- Global keywords --------
          token-arg KEYWORD-INCLUDE = if
            // -------- Keyword 'include' -------- 
            // TODO: Create a function to include.
            // TODO: Allow including packages.

            // Get the next token, which should be the include path.
            "a 'name' for include path" false compile-file.get-next-token

            let path-token-type path-token-address path-token-arg in
              path-token-type path-token-address "as path after 'include'" TYPE-NAME compile-file.check-type-here
              memory found 1 in
                0 found !8
                
                0 while dup include-paths-set list64.length < do let i in
                  i include-paths-set list64.get let directory in
                    directory cstr.str path-token-arg path-token-arg mlength path.merge2-cstr let include-path in    
                      // Check if the user has the required permissions.
                      memory stats sizeof(stat) in
                        include-path stats stat drop

                        // Check if user has access to the path.
                        include-path R_OK access is-zero if
                          // Mark as found.
                          0xff found !8

                          stats 24 + @64 S_IFMT && let masked in
                            masked S_IFREG = if
                              // File including, call compile-file on the file.
                              include-path output-file
                              data-definitions-list
                              global-names-array global-sizes-array globals-length
                              proc-names-array proc-inputs-array proc-outputs-array procs-length
                              macro-names macro-tokens macros-length
                              include-paths-set
                              libraries-set
                              log-stream compile-file

                            else masked S_IFDIR = if
                              // Directory including, should include all sub paths.
                              LOG.TODO log-stream fputs "Including directories is not implemented yet.\n" log-stream fputs
                              path-token-address log-stream fput-here
                              ERROR-EXIT-CODE exit drop

                            else
                              LOG.ERR log-stream fputs "Invalid file type, got " log-stream fputs masked log-stream fputo ".\n" log-stream fputs
                              path-token-address log-stream fput-here
                              ERROR-EXIT-CODE exit drop
                            end end
                          end
                          
                          i break
                        end
                      end

                      // Deallocate 'include-path'.
                      include-path mfree drop
                    end
                  end
                i end inc end drop

                // Check if any library is found.
                found @8 is-zero if
                  LOG.ERR log-stream fputs "Could not find library '" log-stream fputs path-token-arg dup mlength log-stream fputs "'.\n" log-stream fputs
                  path-token-address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                end
              end
            end

          else token-arg KEYWORD-MEMORY = if
            // -------- Keyword 'memory' --------

            // Get the next token, which sould be the include path.
            "a 'name' after 'memory' while defining a global varible" false compile-file.get-next-token

            let memory-name-type memory-name-address memory-name-arg in
              memory-name-type memory-name-address "as global variable name after 'memory'" TYPE-NAME compile-file.check-type-here

              // TODO: Implement size calculation.
              "size after 'memory' while defining a global varible" true compile-file.get-next-token

              let memory-size-type memory-size-address memory-size-arg in
                memory-size-type memory-size-address "as global variable size after 'memory'" TYPE-INTEGER compile-file.check-type-here

                // Get the next keyword, which should be an 'end' keyword.
                "an 'end' after 'memory' while defining a global varible" true compile-file.get-next-token

                // Check the token type and keyword.
                // Add 'and' keyword.
                let end-token-type end-token-address end-token-arg in
                  end-token-type end-token-address "after 'memory' while defining a global variable" TYPE-KEYWORD compile-file.check-type-here
                  
                  end-token-arg KEYWORD-AND = if
                    LOG.TODO log-stream fputs "'and' after 'memory' for global variable allocation is not implemented yet.\n" log-stream fputs
                    end-token-address log-stream fput-here
                    ERROR-EXIT-CODE exit drop
                  end
                  
                  end-token-arg end-token-address "after 'memory' while defining a global variable" KEYWORD-END compile-file.check-keyword-here

                  // Deallocate 'end-token-address'.
                  end-token-address mfree drop
                end

                // TODO: Check if the global variable queue was filled.
                memory-name-arg memory-size-arg global-names-array global-sizes-array globals-length str-map64.set-dstr drop

                // Deallocate 'memory-size-address'.
                memory-size-address mfree drop
              end

              // Deallocate 'memory-name-address'.
              memory-name-address mfree drop
            end

          else token-arg KEYWORD-MACRO = if
            // -------- Keyword 'macro' --------

            // Get the next token, which should be the name of the macro.
            "a 'name' after 'macro'" false compile-file.get-next-token

            let macro-name-token-type macro-name-token-address macro-name-token-arg in
              macro-name-token-type macro-name-token-address "as macro name after 'macro'" TYPE-NAME compile-file.check-type-here

              // macro-tokens and macro-tokens-length are used to create a QUEUE for macro tokens.
              memory macro-tokens-list sizeof(ptr) in
                16 list64.init let dynamic in
                  dynamic "creating list dynamic object for 'macro'" compile-file.check-null-here

                  dynamic macro-tokens-list !64
                end

                while true do
                  // Get next tokens, until an 'endmacro' is found.
                  "an 'endmacro' after 'macro'" false compile-file.get-next-token

                  let macro-new-token-type macro-new-token-address macro-new-token-arg in
                    // If the token is an 'endmacro' keyword, break the loop.
                    macro-new-token-type TYPE-KEYWORD = if
                      macro-new-token-arg KEYWORD-ENDMACRO = if
                        break
                      end
                    end

                    // Add the token attributes to the macro-tokens-list.
                    macro-new-token-type    macro-tokens-list list64.append
                    macro-new-token-address macro-tokens-list list64.append
                    macro-new-token-arg     macro-tokens-list list64.append
                  end
                end

                // TODO: Check if the macros queue was filled.
                macro-name-token-arg macro-tokens-list list64.copy-array macro-names macro-tokens macros-length str-map64.set-dstr drop

                // Deallocate 'macro-tokens-list'.
                macro-tokens-list list64.mfree drop
              end

              // Deallocate 'macro-name-token-address'.
              macro-name-token-address mfree drop
            end

          else token-arg KEYWORD-PROC = if
            // -------- 'proc' keyword --------

            // Get the next token, which should be the name of the procedure.
            "a 'name' after 'proc'" false compile-file.get-next-token
            
            let proc-name-token-type proc-name-token-address proc-name-token-arg in
              proc-name-token-type proc-name-token-address "as procedure name after 'procedure'" TYPE-NAME compile-file.check-type-here

              memory input-list sizeof(ptr) in
              memory output-list sizeof(ptr) in

                // TODO: Check if the dynamic object is NULLPTR or not.
                16 list64.init input-list !64
                16 list64.init output-list !64

                // Get the input types.
                while true do
                  // Get the token.
                  "a 'type' after 'proc' for input" true compile-file.get-next-token

                  let input-token-type input-token-address input-token-arg in
                    input-token-type TYPE-KEYWORD = if
                      // If the token was a keyword, it must be a 'KEYWORD-RETURN'.
                      input-token-arg input-token-address "after 'proc' inputs" KEYWORD-RETURNS compile-file.check-keyword-here

                      // Deallocate 'input-token-address'.
                      input-token-address mfree drop

                      // If the token was a 'KEYWORD-RETURNS', break the loop.
                      break
                    end

                    // Check if the token is of type-type.
                    input-token-type input-token-address "after 'proc'" TYPE-INT-TYPE compile-file.check-type-here

                    input-token-arg input-list list64.append

                    // Deallocate 'input-token-address'.
                    input-token-address mfree drop
                  end
                end

                // Get the output types.
                while true do
                  // Get the token.
                  "a 'type' after 'proc' for output" true compile-file.get-next-token

                  let output-token-type output-token-address output-token-arg in
                    output-token-type TYPE-KEYWORD = if
                      // If the token is a keyword, it must be a 'KEYWORD-IN'.
                      output-token-arg output-token-address "after 'proc' outputs" KEYWORD-IN compile-file.check-keyword-here

                      // Deallocate 'output-token-address'.
                      output-token-address mfree drop

                      // If the token was a 'KEYWORD-IN', break the loop.
                      break
                    end

                    // Check if the token is of type-type.
                    output-token-type output-token-address "after '--'" TYPE-INT-TYPE compile-file.check-type-here

                    output-token-arg output-list list64.append

                    // Deallocate 'output-token-address'.
                    output-token-address mfree drop
                  end
                end

                // Store the procedure name, input and outputs.
                // Check if the procedure was defined already.
                proc-name-token-arg proc-names-array proc-names-array procs-length @64 8 * + str-sorted8.available-dstr if
                  drop
                  LOG.ERR log-stream fputs "Procedure '" log-stream fputs proc-name-token-arg proc-name-token-arg mlength log-stream fputs "' was already defined before.\n" log-stream fputs
                  proc-name-token-address log-stream fput-here
                  ERROR-EXIT-CODE exit drop
                  return
                end

                let name-address in
                  name-address proc-names-array - let delta in
                    proc-inputs-array delta + proc-outputs-array delta + let input-address output-address in
                      // Shift the array to insert the name, input and output.
                      name-address   name-address   8 + procs-length @64 name-address   proc-names-array   - 8 / - memcpy64i
                      input-address  input-address  8 + procs-length @64 input-address  proc-inputs-array  - 8 / - memcpy64i
                      output-address output-address 8 + procs-length @64 output-address proc-outputs-array - 8 / - memcpy64i

                      // Save the name, inputs and outputs of the procedure.
                      proc-name-token-arg             dcopy name-address   !64
                      input-list          list64.copy-array input-address  !64 
                      output-list         list64.copy-array output-address !64

                      procs-length @inc64
                    end
                  end
                end

                // Create the stack for the procedure.
                memory local-stack        STACK-MAX-ITEMS in
                memory local-stack-length sizeof(int)     in

                  0 local-stack-length !64

                  0 while dup input-list list64.length < do let i in
                    i input-list list64.get let type in
                      type push-real
                    end
                  i end inc end drop

                  source-name source-file output-file
                  line-no char-no
                  data-definitions-list
                  global-names-array global-sizes-array globals-length
                  proc-names-array proc-inputs-array proc-outputs-array procs-length
                  macro-names macro-tokens macros-length
                  proc-name-token-arg proc-name-token-address
                  local-stack local-stack-length
                  extended-array extended-start extended-end
                  output-list list64.to-array
                  log-stream
                  compile-procedure drop

                  ".return:\n"                        output-file fputs
                  "    xchg    rsp, [call_ptr]\n"     output-file fputs
                  "    pop     qword [local_ptr]\n"   output-file fputs
                  "    pop     rax\n"                 output-file fputs
                  "    xchg    rsp, [call_ptr]\n"     output-file fputs
                  "    jmp     rax\n"                 output-file fputs
                end end

                // Deallocate input-list and output-list.
                input-list  list64.mfree drop
                output-list list64.mfree drop
              end end 
            end
          else
            LOG.ERR log-stream fputs "Unexpected keyword, got '" log-stream fputs token-arg log-stream fput-keyword "'.\n" log-stream fputs
            token-address log-stream fput-here
            ERROR-EXIT-CODE exit drop
          end end end end
        end
      end drop drop drop
    end end end end end
    
    source-file fclose drop
  end
end end


proc compile-nasm
  // ptr: source-name ptr: output-name ptr: include-paths-set file-desc: log-stream --
  ptr ptr ptr file-desc --
in let source-name output-name include-paths-set log-stream in
  // Create the output file.
  output-name 0o777 creat dup isn-pos if
    LOG.ERR log-stream fputs "Could not create output file '" log-stream fputs output-name output-name cstr.len log-stream fputs "'.\n" log-stream fputs
    ERROR-EXIT-CODE exit drop
  end

  let output-file in
    // Check if the file is opened successfully.
    output-file isn-pos if
      LOG.ERR log-stream fputs "Could not open output file '" log-stream fputs output-name output-name cstr.len log-stream fputs "'.\n" log-stream fputs
      ERROR-EXIT-CODE exit drop
    end

    "segment .text\n"                                   output-file fputs
    "global _start\n"                                   output-file fputs

    "_start:\n"                                         output-file fputs
    "    mov     qword [call_ptr], call_stack\n"        output-file fputs
    "    add     qword [call_ptr], 0x4000\n"            output-file fputs
    "    mov     qword [local_ptr], local_memory\n"     output-file fputs

    "    xchg    rsp, [call_ptr]\n"                     output-file fputs
    "    push    corth_endofprogram\n"                  output-file fputs
    "    push    qword [local_ptr]\n"                   output-file fputs
    "    xchg    rsp, [call_ptr]\n"                     output-file fputs

    "    mov     rax, [rsp]\n"                          output-file fputs
    "    mov     rbx, rsp\n"                            output-file fputs
    "    add     rbx, 8\n"                              output-file fputs
    "    mov     rdx, rax\n"                            output-file fputs
    "    shl     rdx, 3\n"                              output-file fputs
    "    sub     rsp, rdx\n"                            output-file fputs
    "    push    rax\n"                                 output-file fputs
    "    push    rbx\n"                                 output-file fputs

    "    jmp     proc_main\n"                           output-file fputs

    "corth_endofprogram:\n"                             output-file fputs
    "    mov     rax, 60\n"                             output-file fputs
    "    pop     rdi\n"                                 output-file fputs
    "    syscall\n"                                     output-file fputs

    memory global-names-array     GLOBALS-MAX-COUNT in
    memory global-sizes-array     GLOBALS-MAX-COUNT in
    memory globals-length         sizeof(int)       in

    memory proc-names-array       PROCS-MAX-COUNT   in
    memory proc-inputs-array      PROCS-MAX-COUNT   in
    memory proc-outputs-array     PROCS-MAX-COUNT   in
    memory procs-length           sizeof(int)       in

    memory macro-names            MACROS-MAX-COUNT  in
    memory macro-tokens           MACROS-MAX-COUNT  in
    memory macros-length          sizeof(int)       in

    memory data-definitions-list  sizeof(ptr)       in

    memory libraries-set          sizeof(ptr)       in

      0 globals-length   !64
      0 procs-length     !64
      0 macros-length    !64

      16 list64.init let dynamic in
        dynamic "creating a list dynamic object for data-definitions-list" compile-file.check-null
        
        dynamic data-definitions-list !64
      end

      16 list64.init let dynamic in
        dynamic "creating a list dynamic object for libraries-set.\n" compile-file.check-null
        
        dynamic libraries-set !64
      end

      source-name output-file
      data-definitions-list
      global-names-array global-sizes-array globals-length
      proc-names-array proc-inputs-array proc-outputs-array procs-length
      macro-names macro-tokens macros-length
      include-paths-set
      libraries-set
      log-stream
      compile-file

      // Deallocate space allocated for procedures.
      0 while dup procs-length @64 < do let i in
        i proc-names-array   array64.get mfree drop
        i proc-inputs-array  array64.get mfree drop
        i proc-outputs-array array64.get mfree drop
      i end inc end drop

      // Deallocate space allocated for macros.
      0 while dup macros-length @64 < do let i in
        i macro-names array64.get mfree drop

        i macro-tokens array64.get let tokens in
          0 while dup tokens mlength 24 / < do let j in
            j tokens array64.get j inc tokens array64.get j 2 + tokens array64.get let token-type token-address token-arg in
              // Deallocate 'token-address'.
              token-address mfree drop

              // Deallocate 'token-arg' if the token is either a 'name' or a 'string'.
              token-type TYPE-NAME = token-type TYPE-STRING = | if
                token-arg mfree drop
              end
            end
          j end 3 + end drop

          // Deallocate 'tokens'.
          tokens mfree drop
        end
      i end inc end drop

      // Deallocate the space allocated for libraries-set.
      libraries-set list64.mfree-deep drop

      "segment .data\n" output-file fputs
      0 while dup data-definitions-list list64.length < do let i in
        "    data_" output-file fputs i output-file fputu ": db " output-file fputs
        i data-definitions-list list64.get let data in
          0 while dup data mlength < do let j in
            j data + @8 output-file fputu ", " output-file fputs
          j end inc end drop
        end
        output-file fputnl
      i end inc end drop

      // Deallocate the space allocated for data-definitions-list
      data-definitions-list list64.mfree-deep drop
      
      "segment .bss\n"                                    output-file fputs
      "    local_memory:   resb 67108864\n"               output-file fputs
      "    local_ptr:      resq 1\n"                      output-file fputs
      "    call_stack:     resb 67108864\n"               output-file fputs
      "    call_ptr:       resq 1\n"                      output-file fputs

      0 while dup globals-length @64 < do let i in
        i global-names-array array64.get i global-sizes-array array64.get let variable-name variable-size in
          "    global_"  output-file fputs
          i global-names-array array64.get output-file fput-alpha
          ": resb " output-file fputs
          variable-size output-file fputu
          output-file fputnl

          // Deallocate the name of the variable.
          variable-name mfree drop
        end
      i end inc end drop
    end end end end end end end end end end end end

    output-file fclose drop
  end
end end




/*

Name definitions:
  Public:
    Global variables
    Macros
    Procedures

  Private:
    Local variables
    Let variables

Syscall register arguments:
  %rdi %rsi %rdx %r10 %r8 %r9
*/
